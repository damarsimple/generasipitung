import 'package:json_annotation/json_annotation.dart';
part 'schema.graphql.g.dart';

@JsonSerializable(explicitToJson: true)
class Input$BoolFieldUpdateOperationsInput {
  Input$BoolFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$BoolFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$BoolFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final bool? $set;

  Map<String, dynamic> toJson() =>
      _$Input$BoolFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$BoolFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$BoolFieldUpdateOperationsInput copyWith({bool? Function()? $set}) =>
      Input$BoolFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$BoolFilter {
  Input$BoolFilter({this.equals, this.not});

  @override
  factory Input$BoolFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$BoolFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolFilter? not;

  Map<String, dynamic> toJson() => _$Input$BoolFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([l$equals, l$not]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$BoolFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$BoolFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolFilter? Function()? not}) =>
      Input$BoolFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$BoolWithAggregatesFilter {
  Input$BoolWithAggregatesFilter(
      {this.equals, this.not, this.$_count, this.$_min, this.$_max});

  @override
  factory Input$BoolWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$BoolWithAggregatesFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedBoolFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedBoolFilter? $_max;

  Map<String, dynamic> toJson() => _$Input$BoolWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([l$equals, l$not, l$$_count, l$$_min, l$$_max]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$BoolWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$BoolWithAggregatesFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedBoolFilter? Function()? $_min,
          Input$NestedBoolFilter? Function()? $_max}) =>
      Input$BoolWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCountOrderByAggregateInput {
  Input$ChatCountOrderByAggregateInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? fromId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? readAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? fromId,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? readAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? chatSessionId}) =>
      Input$ChatCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateInput {
  Input$ChatCreateInput(
      {this.id,
      required this.from,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      required this.chatSession});

  @override
  factory Input$ChatCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatCreateInputFromJson(json);

  final String? id;

  final Input$UserCreateNestedOneWithoutMyChatsInput from;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChatSessionCreateNestedOneWithoutChatsInput chatSession;

  Map<String, dynamic> toJson() => _$Input$ChatCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$from = from;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSession = chatSession;
    return Object.hashAll([
      l$id,
      l$from,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSession
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$from = from;
    final lOther$from = other.from;
    if (l$from != lOther$from) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSession = chatSession;
    final lOther$chatSession = other.chatSession;
    if (l$chatSession != lOther$chatSession) return false;
    return true;
  }

  Input$ChatCreateInput copyWith(
          {String? Function()? id,
          Input$UserCreateNestedOneWithoutMyChatsInput? from,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChatSessionCreateNestedOneWithoutChatsInput? chatSession}) =>
      Input$ChatCreateInput(
          id: id == null ? this.id : id(),
          from: from == null ? this.from : from,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSession: chatSession == null ? this.chatSession : chatSession);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateManyChatSessionInput {
  Input$ChatCreateManyChatSessionInput(
      {this.id,
      required this.fromId,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatCreateManyChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateManyChatSessionInputFromJson(json);

  final String? id;

  final String fromId;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateManyChatSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateManyChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatCreateManyChatSessionInput copyWith(
          {String? Function()? id,
          String? fromId,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChatCreateManyChatSessionInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateManyChatSessionInputEnvelope {
  Input$ChatCreateManyChatSessionInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ChatCreateManyChatSessionInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateManyChatSessionInputEnvelopeFromJson(json);

  final Input$ChatCreateManyChatSessionInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateManyChatSessionInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateManyChatSessionInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ChatCreateManyChatSessionInputEnvelope copyWith(
          {Input$ChatCreateManyChatSessionInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ChatCreateManyChatSessionInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateManyFromInput {
  Input$ChatCreateManyFromInput(
      {this.id,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      required this.chatSessionId});

  @override
  factory Input$ChatCreateManyFromInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatCreateManyFromInputFromJson(json);

  final String? id;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  final String chatSessionId;

  Map<String, dynamic> toJson() => _$Input$ChatCreateManyFromInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateManyFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatCreateManyFromInput copyWith(
          {String? Function()? id,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? chatSessionId}) =>
      Input$ChatCreateManyFromInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateManyFromInputEnvelope {
  Input$ChatCreateManyFromInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ChatCreateManyFromInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateManyFromInputEnvelopeFromJson(json);

  final Input$ChatCreateManyFromInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateManyFromInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateManyFromInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ChatCreateManyFromInputEnvelope copyWith(
          {Input$ChatCreateManyFromInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ChatCreateManyFromInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateManyInput {
  Input$ChatCreateManyInput(
      {this.id,
      required this.fromId,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      required this.chatSessionId});

  @override
  factory Input$ChatCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatCreateManyInputFromJson(json);

  final String? id;

  final String fromId;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  final String chatSessionId;

  Map<String, dynamic> toJson() => _$Input$ChatCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatCreateManyInput copyWith(
          {String? Function()? id,
          String? fromId,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? chatSessionId}) =>
      Input$ChatCreateManyInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateNestedManyWithoutChatSessionInput {
  Input$ChatCreateNestedManyWithoutChatSessionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChatCreateNestedManyWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateNestedManyWithoutChatSessionInputFromJson(json);

  final List<Input$ChatCreateWithoutChatSessionInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutChatSessionInput?>?
      connectOrCreate;

  final Input$ChatCreateManyChatSessionInputEnvelope? createMany;

  final List<Input$ChatWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateNestedManyWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateNestedManyWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChatCreateNestedManyWithoutChatSessionInput copyWith(
          {List<Input$ChatCreateWithoutChatSessionInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutChatSessionInput?>? Function()?
              connectOrCreate,
          Input$ChatCreateManyChatSessionInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? connect}) =>
      Input$ChatCreateNestedManyWithoutChatSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateNestedManyWithoutFromInput {
  Input$ChatCreateNestedManyWithoutFromInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChatCreateNestedManyWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateNestedManyWithoutFromInputFromJson(json);

  final List<Input$ChatCreateWithoutFromInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutFromInput?>? connectOrCreate;

  final Input$ChatCreateManyFromInputEnvelope? createMany;

  final List<Input$ChatWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateNestedManyWithoutFromInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateNestedManyWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChatCreateNestedManyWithoutFromInput copyWith(
          {List<Input$ChatCreateWithoutFromInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutFromInput?>? Function()?
              connectOrCreate,
          Input$ChatCreateManyFromInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? connect}) =>
      Input$ChatCreateNestedManyWithoutFromInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateOrConnectWithoutChatSessionInput {
  Input$ChatCreateOrConnectWithoutChatSessionInput(
      {required this.where, required this.create});

  @override
  factory Input$ChatCreateOrConnectWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateOrConnectWithoutChatSessionInputFromJson(json);

  final Input$ChatWhereUniqueInput where;

  final Input$ChatUncheckedCreateWithoutChatSessionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateOrConnectWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateOrConnectWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChatCreateOrConnectWithoutChatSessionInput copyWith(
          {Input$ChatWhereUniqueInput? where,
          Input$ChatUncheckedCreateWithoutChatSessionInput? create}) =>
      Input$ChatCreateOrConnectWithoutChatSessionInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateOrConnectWithoutFromInput {
  Input$ChatCreateOrConnectWithoutFromInput(
      {required this.where, required this.create});

  @override
  factory Input$ChatCreateOrConnectWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateOrConnectWithoutFromInputFromJson(json);

  final Input$ChatWhereUniqueInput where;

  final Input$ChatUncheckedCreateWithoutFromInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateOrConnectWithoutFromInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateOrConnectWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChatCreateOrConnectWithoutFromInput copyWith(
          {Input$ChatWhereUniqueInput? where,
          Input$ChatUncheckedCreateWithoutFromInput? create}) =>
      Input$ChatCreateOrConnectWithoutFromInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateWithoutChatSessionInput {
  Input$ChatCreateWithoutChatSessionInput(
      {this.id,
      required this.from,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatCreateWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateWithoutChatSessionInputFromJson(json);

  final String? id;

  final Input$UserCreateNestedOneWithoutMyChatsInput from;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$from = from;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$from,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$from = from;
    final lOther$from = other.from;
    if (l$from != lOther$from) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatCreateWithoutChatSessionInput copyWith(
          {String? Function()? id,
          Input$UserCreateNestedOneWithoutMyChatsInput? from,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChatCreateWithoutChatSessionInput(
          id: id == null ? this.id : id(),
          from: from == null ? this.from : from,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatCreateWithoutFromInput {
  Input$ChatCreateWithoutFromInput(
      {this.id,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      required this.chatSession});

  @override
  factory Input$ChatCreateWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatCreateWithoutFromInputFromJson(json);

  final String? id;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChatSessionCreateNestedOneWithoutChatsInput chatSession;

  Map<String, dynamic> toJson() =>
      _$Input$ChatCreateWithoutFromInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSession = chatSession;
    return Object.hashAll([
      l$id,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSession
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatCreateWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSession = chatSession;
    final lOther$chatSession = other.chatSession;
    if (l$chatSession != lOther$chatSession) return false;
    return true;
  }

  Input$ChatCreateWithoutFromInput copyWith(
          {String? Function()? id,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChatSessionCreateNestedOneWithoutChatsInput? chatSession}) =>
      Input$ChatCreateWithoutFromInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSession: chatSession == null ? this.chatSession : chatSession);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatListRelationFilter {
  Input$ChatListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ChatListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatListRelationFilterFromJson(json);

  final Input$ChatWhereInput? every;

  final Input$ChatWhereInput? some;

  final Input$ChatWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$ChatListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ChatListRelationFilter copyWith(
          {Input$ChatWhereInput? Function()? every,
          Input$ChatWhereInput? Function()? some,
          Input$ChatWhereInput? Function()? none}) =>
      Input$ChatListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatMaxOrderByAggregateInput {
  Input$ChatMaxOrderByAggregateInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? fromId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? readAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? fromId,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? readAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? chatSessionId}) =>
      Input$ChatMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatMinOrderByAggregateInput {
  Input$ChatMinOrderByAggregateInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? fromId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? readAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? fromId,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? readAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? chatSessionId}) =>
      Input$ChatMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatOrderByRelationAggregateInput {
  Input$ChatOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ChatOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ChatOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ChatOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ChatOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatOrderByWithAggregationInput {
  Input$ChatOrderByWithAggregationInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$ChatOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? fromId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? readAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chatSessionId;

  @JsonKey(name: '_count')
  final Input$ChatCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$ChatMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ChatMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$ChatOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$ChatOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? fromId,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? readAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? chatSessionId,
          Input$ChatCountOrderByAggregateInput? Function()? $_count,
          Input$ChatMaxOrderByAggregateInput? Function()? $_max,
          Input$ChatMinOrderByAggregateInput? Function()? $_min}) =>
      Input$ChatOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatOrderByWithRelationInput {
  Input$ChatOrderByWithRelationInput(
      {this.id,
      this.fromId,
      this.from,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId,
      this.chatSession});

  @override
  factory Input$ChatOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? fromId;

  final Input$UserOrderByWithRelationInput? from;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? readAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chatSessionId;

  final Input$ChatSessionOrderByWithRelationInput? chatSession;

  Map<String, dynamic> toJson() =>
      _$Input$ChatOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$from = from;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    final l$chatSession = chatSession;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$from,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId,
      l$chatSession
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$from = from;
    final lOther$from = other.from;
    if (l$from != lOther$from) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    final l$chatSession = chatSession;
    final lOther$chatSession = other.chatSession;
    if (l$chatSession != lOther$chatSession) return false;
    return true;
  }

  Input$ChatOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? fromId,
          Input$UserOrderByWithRelationInput? Function()? from,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? readAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? chatSessionId,
          Input$ChatSessionOrderByWithRelationInput? Function()?
              chatSession}) =>
      Input$ChatOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          from: from == null ? this.from : from(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId(),
          chatSession: chatSession == null ? this.chatSession : chatSession());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatScalarWhereInput {
  Input$ChatScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatScalarWhereInputFromJson(json);

  final List<Input$ChatScalarWhereInput?>? AND;

  final List<Input$ChatScalarWhereInput?>? OR;

  final List<Input$ChatScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? fromId;

  final Input$EnumContentTypeFilter? contentType;

  final Input$StringFilter? content;

  final Input$DateTimeNullableFilter? readAt;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$StringFilter? chatSessionId;

  Map<String, dynamic> toJson() => _$Input$ChatScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatScalarWhereInput copyWith(
          {List<Input$ChatScalarWhereInput?>? Function()? AND,
          List<Input$ChatScalarWhereInput?>? Function()? OR,
          List<Input$ChatScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? fromId,
          Input$EnumContentTypeFilter? Function()? contentType,
          Input$StringFilter? Function()? content,
          Input$DateTimeNullableFilter? Function()? readAt,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$StringFilter? Function()? chatSessionId}) =>
      Input$ChatScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatScalarWhereWithAggregatesInput {
  Input$ChatScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ChatScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ChatScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ChatScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? fromId;

  final Input$EnumContentTypeWithAggregatesFilter? contentType;

  final Input$StringWithAggregatesFilter? content;

  final Input$DateTimeNullableWithAggregatesFilter? readAt;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  final Input$StringWithAggregatesFilter? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatScalarWhereWithAggregatesInput copyWith(
          {List<Input$ChatScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$ChatScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ChatScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? fromId,
          Input$EnumContentTypeWithAggregatesFilter? Function()? contentType,
          Input$StringWithAggregatesFilter? Function()? content,
          Input$DateTimeNullableWithAggregatesFilter? Function()? readAt,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt,
          Input$StringWithAggregatesFilter? Function()? chatSessionId}) =>
      Input$ChatScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCountOrderByAggregateInput {
  Input$ChatSessionCountOrderByAggregateInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? participantsIds;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastReadAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$participantsIds, l$lastReadAt, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != lOther$participantsIds) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? participantsIds,
          Enum$SortOrder? Function()? lastReadAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChatSessionCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCreateInput {
  Input$ChatSessionCreateInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.chats});

  @override
  factory Input$ChatSessionCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatSessionCreateInputFromJson(json);

  final String? id;

  final List<String?>? participantsIds;

  final String? lastReadAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChatCreateNestedManyWithoutChatSessionInput? chats;

  Map<String, dynamic> toJson() => _$Input$ChatSessionCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chats = chats;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$chats
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chats = chats;
    final lOther$chats = other.chats;
    if (l$chats != lOther$chats) return false;
    return true;
  }

  Input$ChatSessionCreateInput copyWith(
          {String? Function()? id,
          List<String?>? Function()? participantsIds,
          String? Function()? lastReadAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChatCreateNestedManyWithoutChatSessionInput? Function()?
              chats}) =>
      Input$ChatSessionCreateInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chats: chats == null ? this.chats : chats());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCreateManyInput {
  Input$ChatSessionCreateManyInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionCreateManyInputFromJson(json);

  final String? id;

  final List<String?>? participantsIds;

  final String? lastReadAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionCreateManyInput copyWith(
          {String? Function()? id,
          List<String?>? Function()? participantsIds,
          String? Function()? lastReadAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChatSessionCreateManyInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCreateNestedOneWithoutChatsInput {
  Input$ChatSessionCreateNestedOneWithoutChatsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ChatSessionCreateNestedOneWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionCreateNestedOneWithoutChatsInputFromJson(json);

  final Input$ChatSessionUncheckedCreateWithoutChatsInput? create;

  final Input$ChatSessionCreateOrConnectWithoutChatsInput? connectOrCreate;

  final Input$ChatSessionWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionCreateNestedOneWithoutChatsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCreateNestedOneWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ChatSessionCreateNestedOneWithoutChatsInput copyWith(
          {Input$ChatSessionUncheckedCreateWithoutChatsInput? Function()?
              create,
          Input$ChatSessionCreateOrConnectWithoutChatsInput? Function()?
              connectOrCreate,
          Input$ChatSessionWhereUniqueInput? Function()? connect}) =>
      Input$ChatSessionCreateNestedOneWithoutChatsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCreateOrConnectWithoutChatsInput {
  Input$ChatSessionCreateOrConnectWithoutChatsInput(
      {required this.where, required this.create});

  @override
  factory Input$ChatSessionCreateOrConnectWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionCreateOrConnectWithoutChatsInputFromJson(json);

  final Input$ChatSessionWhereUniqueInput where;

  final Input$ChatSessionUncheckedCreateWithoutChatsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionCreateOrConnectWithoutChatsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCreateOrConnectWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChatSessionCreateOrConnectWithoutChatsInput copyWith(
          {Input$ChatSessionWhereUniqueInput? where,
          Input$ChatSessionUncheckedCreateWithoutChatsInput? create}) =>
      Input$ChatSessionCreateOrConnectWithoutChatsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCreateparticipantsIdsInput {
  Input$ChatSessionCreateparticipantsIdsInput({required this.$set});

  @override
  factory Input$ChatSessionCreateparticipantsIdsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionCreateparticipantsIdsInputFromJson(json);

  @JsonKey(name: 'set')
  final String $set;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionCreateparticipantsIdsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCreateparticipantsIdsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$ChatSessionCreateparticipantsIdsInput copyWith({String? $set}) =>
      Input$ChatSessionCreateparticipantsIdsInput(
          $set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionCreateWithoutChatsInput {
  Input$ChatSessionCreateWithoutChatsInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionCreateWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionCreateWithoutChatsInputFromJson(json);

  final String? id;

  final List<String?>? participantsIds;

  final String? lastReadAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionCreateWithoutChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionCreateWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionCreateWithoutChatsInput copyWith(
          {String? Function()? id,
          List<String?>? Function()? participantsIds,
          String? Function()? lastReadAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChatSessionCreateWithoutChatsInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionMaxOrderByAggregateInput {
  Input$ChatSessionMaxOrderByAggregateInput(
      {this.id, this.lastReadAt, this.createdAt, this.updatedAt});

  @override
  factory Input$ChatSessionMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastReadAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$lastReadAt, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? lastReadAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChatSessionMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionMinOrderByAggregateInput {
  Input$ChatSessionMinOrderByAggregateInput(
      {this.id, this.lastReadAt, this.createdAt, this.updatedAt});

  @override
  factory Input$ChatSessionMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastReadAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$lastReadAt, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? lastReadAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChatSessionMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionOrderByWithAggregationInput {
  Input$ChatSessionOrderByWithAggregationInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$ChatSessionOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? participantsIds;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastReadAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ChatSessionCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$ChatSessionMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ChatSessionMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$participantsIds,
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != lOther$participantsIds) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$ChatSessionOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? participantsIds,
          Enum$SortOrder? Function()? lastReadAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ChatSessionCountOrderByAggregateInput? Function()? $_count,
          Input$ChatSessionMaxOrderByAggregateInput? Function()? $_max,
          Input$ChatSessionMinOrderByAggregateInput? Function()? $_min}) =>
      Input$ChatSessionOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionOrderByWithRelationInput {
  Input$ChatSessionOrderByWithRelationInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.chats});

  @override
  factory Input$ChatSessionOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? participantsIds;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastReadAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ChatOrderByRelationAggregateInput? chats;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chats = chats;
    return Object.hashAll([
      l$id,
      l$participantsIds,
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$chats
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != lOther$participantsIds) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chats = chats;
    final lOther$chats = other.chats;
    if (l$chats != lOther$chats) return false;
    return true;
  }

  Input$ChatSessionOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? participantsIds,
          Enum$SortOrder? Function()? lastReadAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ChatOrderByRelationAggregateInput? Function()? chats}) =>
      Input$ChatSessionOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chats: chats == null ? this.chats : chats());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionRelationFilter {
  Input$ChatSessionRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ChatSessionRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatSessionRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ChatSessionWhereInput? $is;

  final Input$ChatSessionWhereInput? isNot;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ChatSessionRelationFilter copyWith(
          {Input$ChatSessionWhereInput? Function()? $is,
          Input$ChatSessionWhereInput? Function()? isNot}) =>
      Input$ChatSessionRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionScalarWhereWithAggregatesInput {
  Input$ChatSessionScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ChatSessionScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ChatSessionScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ChatSessionScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringNullableListFilter? participantsIds;

  final Input$DateTimeNullableWithAggregatesFilter? lastReadAt;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$participantsIds,
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != lOther$participantsIds) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionScalarWhereWithAggregatesInput copyWith(
          {List<Input$ChatSessionScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ChatSessionScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$ChatSessionScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringNullableListFilter? Function()? participantsIds,
          Input$DateTimeNullableWithAggregatesFilter? Function()? lastReadAt,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ChatSessionScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUncheckedCreateInput {
  Input$ChatSessionUncheckedCreateInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.chats});

  @override
  factory Input$ChatSessionUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUncheckedCreateInputFromJson(json);

  final String? id;

  final List<String?>? participantsIds;

  final String? lastReadAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput? chats;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chats = chats;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$chats
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chats = chats;
    final lOther$chats = other.chats;
    if (l$chats != lOther$chats) return false;
    return true;
  }

  Input$ChatSessionUncheckedCreateInput copyWith(
          {String? Function()? id,
          List<String?>? Function()? participantsIds,
          String? Function()? lastReadAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput?
                  Function()?
              chats}) =>
      Input$ChatSessionUncheckedCreateInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chats: chats == null ? this.chats : chats());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUncheckedCreateWithoutChatsInput {
  Input$ChatSessionUncheckedCreateWithoutChatsInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionUncheckedCreateWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUncheckedCreateWithoutChatsInputFromJson(json);

  final String? id;

  final List<String?>? participantsIds;

  final String? lastReadAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUncheckedCreateWithoutChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUncheckedCreateWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionUncheckedCreateWithoutChatsInput copyWith(
          {String? Function()? id,
          List<String?>? Function()? participantsIds,
          String? Function()? lastReadAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChatSessionUncheckedCreateWithoutChatsInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUncheckedUpdateInput {
  Input$ChatSessionUncheckedUpdateInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.chats});

  @override
  factory Input$ChatSessionUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final List<String?>? participantsIds;

  final Input$NullableDateTimeFieldUpdateOperationsInput? lastReadAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChatUncheckedUpdateManyWithoutChatSessionInput? chats;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chats = chats;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$chats
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chats = chats;
    final lOther$chats = other.chats;
    if (l$chats != lOther$chats) return false;
    return true;
  }

  Input$ChatSessionUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<String?>? Function()? participantsIds,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              lastReadAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChatUncheckedUpdateManyWithoutChatSessionInput? Function()?
              chats}) =>
      Input$ChatSessionUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chats: chats == null ? this.chats : chats());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUncheckedUpdateManyInput {
  Input$ChatSessionUncheckedUpdateManyInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final List<String?>? participantsIds;

  final Input$NullableDateTimeFieldUpdateOperationsInput? lastReadAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<String?>? Function()? participantsIds,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              lastReadAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatSessionUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUncheckedUpdateWithoutChatsInput {
  Input$ChatSessionUncheckedUpdateWithoutChatsInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionUncheckedUpdateWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUncheckedUpdateWithoutChatsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final List<String?>? participantsIds;

  final Input$NullableDateTimeFieldUpdateOperationsInput? lastReadAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUncheckedUpdateWithoutChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUncheckedUpdateWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionUncheckedUpdateWithoutChatsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<String?>? Function()? participantsIds,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              lastReadAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatSessionUncheckedUpdateWithoutChatsInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUpdateInput {
  Input$ChatSessionUpdateInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.chats});

  @override
  factory Input$ChatSessionUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatSessionUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final List<String?>? participantsIds;

  final Input$NullableDateTimeFieldUpdateOperationsInput? lastReadAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChatUpdateManyWithoutChatSessionInput? chats;

  Map<String, dynamic> toJson() => _$Input$ChatSessionUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chats = chats;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$chats
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chats = chats;
    final lOther$chats = other.chats;
    if (l$chats != lOther$chats) return false;
    return true;
  }

  Input$ChatSessionUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<String?>? Function()? participantsIds,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              lastReadAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChatUpdateManyWithoutChatSessionInput? Function()? chats}) =>
      Input$ChatSessionUpdateInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chats: chats == null ? this.chats : chats());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUpdateManyMutationInput {
  Input$ChatSessionUpdateManyMutationInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final List<String?>? participantsIds;

  final Input$NullableDateTimeFieldUpdateOperationsInput? lastReadAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<String?>? Function()? participantsIds,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              lastReadAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatSessionUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUpdateOneRequiredWithoutChatsInput {
  Input$ChatSessionUpdateOneRequiredWithoutChatsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ChatSessionUpdateOneRequiredWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUpdateOneRequiredWithoutChatsInputFromJson(json);

  final Input$ChatSessionUncheckedCreateWithoutChatsInput? create;

  final Input$ChatSessionCreateOrConnectWithoutChatsInput? connectOrCreate;

  final Input$ChatSessionUpsertWithoutChatsInput? upsert;

  final Input$ChatSessionWhereUniqueInput? connect;

  final Input$ChatSessionUncheckedUpdateWithoutChatsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUpdateOneRequiredWithoutChatsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUpdateOneRequiredWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ChatSessionUpdateOneRequiredWithoutChatsInput copyWith(
          {Input$ChatSessionUncheckedCreateWithoutChatsInput? Function()?
              create,
          Input$ChatSessionCreateOrConnectWithoutChatsInput? Function()?
              connectOrCreate,
          Input$ChatSessionUpsertWithoutChatsInput? Function()? upsert,
          Input$ChatSessionWhereUniqueInput? Function()? connect,
          Input$ChatSessionUncheckedUpdateWithoutChatsInput? Function()?
              update}) =>
      Input$ChatSessionUpdateOneRequiredWithoutChatsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUpdateparticipantsIdsInput {
  Input$ChatSessionUpdateparticipantsIdsInput({this.$set, this.push});

  @override
  factory Input$ChatSessionUpdateparticipantsIdsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUpdateparticipantsIdsInputFromJson(json);

  @JsonKey(name: 'set')
  final List<String?>? $set;

  final List<String?>? push;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUpdateparticipantsIdsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUpdateparticipantsIdsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$ChatSessionUpdateparticipantsIdsInput copyWith(
          {List<String?>? Function()? $set, List<String?>? Function()? push}) =>
      Input$ChatSessionUpdateparticipantsIdsInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUpdateWithoutChatsInput {
  Input$ChatSessionUpdateWithoutChatsInput(
      {this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatSessionUpdateWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUpdateWithoutChatsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final List<String?>? participantsIds;

  final Input$NullableDateTimeFieldUpdateOperationsInput? lastReadAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUpdateWithoutChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$participantsIds == null
          ? null
          : Object.hashAll(l$participantsIds.map((v) => v)),
      l$lastReadAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUpdateWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != null && lOther$participantsIds != null) {
      if (l$participantsIds.length != lOther$participantsIds.length)
        return false;
      for (int i = 0; i < l$participantsIds.length; i++) {
        final l$participantsIds$entry = l$participantsIds[i];
        final lOther$participantsIds$entry = lOther$participantsIds[i];
        if (l$participantsIds$entry != lOther$participantsIds$entry)
          return false;
      }
    } else if (l$participantsIds != lOther$participantsIds) {
      return false;
    }

    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatSessionUpdateWithoutChatsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<String?>? Function()? participantsIds,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              lastReadAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatSessionUpdateWithoutChatsInput(
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionUpsertWithoutChatsInput {
  Input$ChatSessionUpsertWithoutChatsInput(
      {required this.update, required this.create});

  @override
  factory Input$ChatSessionUpsertWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionUpsertWithoutChatsInputFromJson(json);

  final Input$ChatSessionUncheckedUpdateWithoutChatsInput update;

  final Input$ChatSessionUncheckedCreateWithoutChatsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionUpsertWithoutChatsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionUpsertWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChatSessionUpsertWithoutChatsInput copyWith(
          {Input$ChatSessionUncheckedUpdateWithoutChatsInput? update,
          Input$ChatSessionUncheckedCreateWithoutChatsInput? create}) =>
      Input$ChatSessionUpsertWithoutChatsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionWhereInput {
  Input$ChatSessionWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.participantsIds,
      this.lastReadAt,
      this.createdAt,
      this.updatedAt,
      this.chats});

  @override
  factory Input$ChatSessionWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatSessionWhereInputFromJson(json);

  final List<Input$ChatSessionWhereInput?>? AND;

  final List<Input$ChatSessionWhereInput?>? OR;

  final List<Input$ChatSessionWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringNullableListFilter? participantsIds;

  final Input$DateTimeNullableFilter? lastReadAt;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ChatListRelationFilter? chats;

  Map<String, dynamic> toJson() => _$Input$ChatSessionWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$participantsIds = participantsIds;
    final l$lastReadAt = lastReadAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chats = chats;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$participantsIds,
      l$lastReadAt,
      l$createdAt,
      l$updatedAt,
      l$chats
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$participantsIds = participantsIds;
    final lOther$participantsIds = other.participantsIds;
    if (l$participantsIds != lOther$participantsIds) return false;
    final l$lastReadAt = lastReadAt;
    final lOther$lastReadAt = other.lastReadAt;
    if (l$lastReadAt != lOther$lastReadAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chats = chats;
    final lOther$chats = other.chats;
    if (l$chats != lOther$chats) return false;
    return true;
  }

  Input$ChatSessionWhereInput copyWith(
          {List<Input$ChatSessionWhereInput?>? Function()? AND,
          List<Input$ChatSessionWhereInput?>? Function()? OR,
          List<Input$ChatSessionWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringNullableListFilter? Function()? participantsIds,
          Input$DateTimeNullableFilter? Function()? lastReadAt,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ChatListRelationFilter? Function()? chats}) =>
      Input$ChatSessionWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          participantsIds: participantsIds == null
              ? this.participantsIds
              : participantsIds(),
          lastReadAt: lastReadAt == null ? this.lastReadAt : lastReadAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chats: chats == null ? this.chats : chats());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatSessionWhereUniqueInput {
  Input$ChatSessionWhereUniqueInput({this.id});

  @override
  factory Input$ChatSessionWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatSessionWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$ChatSessionWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatSessionWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ChatSessionWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ChatSessionWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedCreateInput {
  Input$ChatUncheckedCreateInput(
      {this.id,
      required this.fromId,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      required this.chatSessionId});

  @override
  factory Input$ChatUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatUncheckedCreateInputFromJson(json);

  final String? id;

  final String fromId;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  final String chatSessionId;

  Map<String, dynamic> toJson() => _$Input$ChatUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? fromId,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? chatSessionId}) =>
      Input$ChatUncheckedCreateInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput {
  Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedCreateNestedManyWithoutChatSessionInputFromJson(
          json);

  final List<Input$ChatCreateWithoutChatSessionInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutChatSessionInput?>?
      connectOrCreate;

  final Input$ChatCreateManyChatSessionInputEnvelope? createMany;

  final List<Input$ChatWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedCreateNestedManyWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput copyWith(
          {List<Input$ChatCreateWithoutChatSessionInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutChatSessionInput?>? Function()?
              connectOrCreate,
          Input$ChatCreateManyChatSessionInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? connect}) =>
      Input$ChatUncheckedCreateNestedManyWithoutChatSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedCreateNestedManyWithoutFromInput {
  Input$ChatUncheckedCreateNestedManyWithoutFromInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChatUncheckedCreateNestedManyWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedCreateNestedManyWithoutFromInputFromJson(json);

  final List<Input$ChatCreateWithoutFromInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutFromInput?>? connectOrCreate;

  final Input$ChatCreateManyFromInputEnvelope? createMany;

  final List<Input$ChatWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedCreateNestedManyWithoutFromInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedCreateNestedManyWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChatUncheckedCreateNestedManyWithoutFromInput copyWith(
          {List<Input$ChatCreateWithoutFromInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutFromInput?>? Function()?
              connectOrCreate,
          Input$ChatCreateManyFromInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? connect}) =>
      Input$ChatUncheckedCreateNestedManyWithoutFromInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedCreateWithoutChatSessionInput {
  Input$ChatUncheckedCreateWithoutChatSessionInput(
      {this.id,
      required this.fromId,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatUncheckedCreateWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedCreateWithoutChatSessionInputFromJson(json);

  final String? id;

  final String fromId;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedCreateWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedCreateWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatUncheckedCreateWithoutChatSessionInput copyWith(
          {String? Function()? id,
          String? fromId,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChatUncheckedCreateWithoutChatSessionInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedCreateWithoutFromInput {
  Input$ChatUncheckedCreateWithoutFromInput(
      {this.id,
      required this.contentType,
      required this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      required this.chatSessionId});

  @override
  factory Input$ChatUncheckedCreateWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedCreateWithoutFromInputFromJson(json);

  final String? id;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  final String? readAt;

  final String? createdAt;

  final String? updatedAt;

  final String chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedCreateWithoutFromInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedCreateWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatUncheckedCreateWithoutFromInput copyWith(
          {String? Function()? id,
          Enum$ContentType? contentType,
          String? content,
          String? Function()? readAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? chatSessionId}) =>
      Input$ChatUncheckedCreateWithoutFromInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateInput {
  Input$ChatUncheckedUpdateInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? fromId;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$StringFieldUpdateOperationsInput? chatSessionId;

  Map<String, dynamic> toJson() => _$Input$ChatUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? fromId,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$StringFieldUpdateOperationsInput? Function()? chatSessionId}) =>
      Input$ChatUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateManyInput {
  Input$ChatUncheckedUpdateManyInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? fromId;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$StringFieldUpdateOperationsInput? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? fromId,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$StringFieldUpdateOperationsInput? Function()? chatSessionId}) =>
      Input$ChatUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateManyWithoutChatSessionInput {
  Input$ChatUncheckedUpdateManyWithoutChatSessionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChatUncheckedUpdateManyWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateManyWithoutChatSessionInputFromJson(json);

  final List<Input$ChatCreateWithoutChatSessionInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutChatSessionInput?>?
      connectOrCreate;

  final List<Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput?>? upsert;

  final Input$ChatCreateManyChatSessionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChatWhereUniqueInput?>? $set;

  final List<Input$ChatWhereUniqueInput?>? disconnect;

  final List<Input$ChatWhereUniqueInput?>? delete;

  final List<Input$ChatWhereUniqueInput?>? connect;

  final List<Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput?>? update;

  final List<Input$ChatUpdateManyWithWhereWithoutChatSessionInput?>? updateMany;

  final List<Input$ChatScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateManyWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateManyWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChatUncheckedUpdateManyWithoutChatSessionInput copyWith(
          {List<Input$ChatCreateWithoutChatSessionInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutChatSessionInput?>? Function()?
              connectOrCreate,
          List<Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput?>?
                  Function()?
              upsert,
          Input$ChatCreateManyChatSessionInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? $set,
          List<Input$ChatWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChatWhereUniqueInput?>? Function()? delete,
          List<Input$ChatWhereUniqueInput?>? Function()? connect,
          List<Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput?>?
                  Function()?
              update,
          List<Input$ChatUpdateManyWithWhereWithoutChatSessionInput?>?
                  Function()?
              updateMany,
          List<Input$ChatScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChatUncheckedUpdateManyWithoutChatSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateManyWithoutChatsInput {
  Input$ChatUncheckedUpdateManyWithoutChatsInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatUncheckedUpdateManyWithoutChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateManyWithoutChatsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? fromId;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateManyWithoutChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateManyWithoutChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatUncheckedUpdateManyWithoutChatsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? fromId,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatUncheckedUpdateManyWithoutChatsInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateManyWithoutFromInput {
  Input$ChatUncheckedUpdateManyWithoutFromInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChatUncheckedUpdateManyWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateManyWithoutFromInputFromJson(json);

  final List<Input$ChatCreateWithoutFromInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutFromInput?>? connectOrCreate;

  final List<Input$ChatUpsertWithWhereUniqueWithoutFromInput?>? upsert;

  final Input$ChatCreateManyFromInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChatWhereUniqueInput?>? $set;

  final List<Input$ChatWhereUniqueInput?>? disconnect;

  final List<Input$ChatWhereUniqueInput?>? delete;

  final List<Input$ChatWhereUniqueInput?>? connect;

  final List<Input$ChatUpdateWithWhereUniqueWithoutFromInput?>? update;

  final List<Input$ChatUpdateManyWithWhereWithoutFromInput?>? updateMany;

  final List<Input$ChatScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateManyWithoutFromInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateManyWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChatUncheckedUpdateManyWithoutFromInput copyWith(
          {List<Input$ChatCreateWithoutFromInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutFromInput?>? Function()?
              connectOrCreate,
          List<Input$ChatUpsertWithWhereUniqueWithoutFromInput?>? Function()?
              upsert,
          Input$ChatCreateManyFromInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? $set,
          List<Input$ChatWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChatWhereUniqueInput?>? Function()? delete,
          List<Input$ChatWhereUniqueInput?>? Function()? connect,
          List<Input$ChatUpdateWithWhereUniqueWithoutFromInput?>? Function()?
              update,
          List<Input$ChatUpdateManyWithWhereWithoutFromInput?>? Function()?
              updateMany,
          List<Input$ChatScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChatUncheckedUpdateManyWithoutFromInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateManyWithoutMyChatsInput {
  Input$ChatUncheckedUpdateManyWithoutMyChatsInput(
      {this.id,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatUncheckedUpdateManyWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateManyWithoutMyChatsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$StringFieldUpdateOperationsInput? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateManyWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateManyWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatUncheckedUpdateManyWithoutMyChatsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$StringFieldUpdateOperationsInput? Function()? chatSessionId}) =>
      Input$ChatUncheckedUpdateManyWithoutMyChatsInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateWithoutChatSessionInput {
  Input$ChatUncheckedUpdateWithoutChatSessionInput(
      {this.id,
      this.fromId,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatUncheckedUpdateWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateWithoutChatSessionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? fromId;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$fromId = fromId;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$fromId,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatUncheckedUpdateWithoutChatSessionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? fromId,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatUncheckedUpdateWithoutChatSessionInput(
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUncheckedUpdateWithoutFromInput {
  Input$ChatUncheckedUpdateWithoutFromInput(
      {this.id,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId});

  @override
  factory Input$ChatUncheckedUpdateWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUncheckedUpdateWithoutFromInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$StringFieldUpdateOperationsInput? chatSessionId;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUncheckedUpdateWithoutFromInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    return Object.hashAll([
      l$id,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUncheckedUpdateWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    return true;
  }

  Input$ChatUncheckedUpdateWithoutFromInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$StringFieldUpdateOperationsInput? Function()? chatSessionId}) =>
      Input$ChatUncheckedUpdateWithoutFromInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateInput {
  Input$ChatUpdateInput(
      {this.id,
      this.from,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSession});

  @override
  factory Input$ChatUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$UserUpdateOneRequiredWithoutMyChatsInput? from;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChatSessionUpdateOneRequiredWithoutChatsInput? chatSession;

  Map<String, dynamic> toJson() => _$Input$ChatUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$from = from;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSession = chatSession;
    return Object.hashAll([
      l$id,
      l$from,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSession
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$from = from;
    final lOther$from = other.from;
    if (l$from != lOther$from) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSession = chatSession;
    final lOther$chatSession = other.chatSession;
    if (l$chatSession != lOther$chatSession) return false;
    return true;
  }

  Input$ChatUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$UserUpdateOneRequiredWithoutMyChatsInput? Function()? from,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChatSessionUpdateOneRequiredWithoutChatsInput? Function()?
              chatSession}) =>
      Input$ChatUpdateInput(
          id: id == null ? this.id : id(),
          from: from == null ? this.from : from(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSession: chatSession == null ? this.chatSession : chatSession());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateManyMutationInput {
  Input$ChatUpdateManyMutationInput(
      {this.id,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$contentType, l$content, l$readAt, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateManyWithoutChatSessionInput {
  Input$ChatUpdateManyWithoutChatSessionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChatUpdateManyWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateManyWithoutChatSessionInputFromJson(json);

  final List<Input$ChatCreateWithoutChatSessionInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutChatSessionInput?>?
      connectOrCreate;

  final List<Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput?>? upsert;

  final Input$ChatCreateManyChatSessionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChatWhereUniqueInput?>? $set;

  final List<Input$ChatWhereUniqueInput?>? disconnect;

  final List<Input$ChatWhereUniqueInput?>? delete;

  final List<Input$ChatWhereUniqueInput?>? connect;

  final List<Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput?>? update;

  final List<Input$ChatUpdateManyWithWhereWithoutChatSessionInput?>? updateMany;

  final List<Input$ChatScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateManyWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateManyWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChatUpdateManyWithoutChatSessionInput copyWith(
          {List<Input$ChatCreateWithoutChatSessionInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutChatSessionInput?>? Function()?
              connectOrCreate,
          List<Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput?>?
                  Function()?
              upsert,
          Input$ChatCreateManyChatSessionInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? $set,
          List<Input$ChatWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChatWhereUniqueInput?>? Function()? delete,
          List<Input$ChatWhereUniqueInput?>? Function()? connect,
          List<Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput?>?
                  Function()?
              update,
          List<Input$ChatUpdateManyWithWhereWithoutChatSessionInput?>?
                  Function()?
              updateMany,
          List<Input$ChatScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChatUpdateManyWithoutChatSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateManyWithoutFromInput {
  Input$ChatUpdateManyWithoutFromInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChatUpdateManyWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateManyWithoutFromInputFromJson(json);

  final List<Input$ChatCreateWithoutFromInput?>? create;

  final List<Input$ChatCreateOrConnectWithoutFromInput?>? connectOrCreate;

  final List<Input$ChatUpsertWithWhereUniqueWithoutFromInput?>? upsert;

  final Input$ChatCreateManyFromInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChatWhereUniqueInput?>? $set;

  final List<Input$ChatWhereUniqueInput?>? disconnect;

  final List<Input$ChatWhereUniqueInput?>? delete;

  final List<Input$ChatWhereUniqueInput?>? connect;

  final List<Input$ChatUpdateWithWhereUniqueWithoutFromInput?>? update;

  final List<Input$ChatUpdateManyWithWhereWithoutFromInput?>? updateMany;

  final List<Input$ChatScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateManyWithoutFromInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateManyWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChatUpdateManyWithoutFromInput copyWith(
          {List<Input$ChatCreateWithoutFromInput?>? Function()? create,
          List<Input$ChatCreateOrConnectWithoutFromInput?>? Function()?
              connectOrCreate,
          List<Input$ChatUpsertWithWhereUniqueWithoutFromInput?>? Function()?
              upsert,
          Input$ChatCreateManyFromInputEnvelope? Function()? createMany,
          List<Input$ChatWhereUniqueInput?>? Function()? $set,
          List<Input$ChatWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChatWhereUniqueInput?>? Function()? delete,
          List<Input$ChatWhereUniqueInput?>? Function()? connect,
          List<Input$ChatUpdateWithWhereUniqueWithoutFromInput?>? Function()?
              update,
          List<Input$ChatUpdateManyWithWhereWithoutFromInput?>? Function()?
              updateMany,
          List<Input$ChatScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChatUpdateManyWithoutFromInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateManyWithWhereWithoutChatSessionInput {
  Input$ChatUpdateManyWithWhereWithoutChatSessionInput(
      {required this.where, required this.data});

  @override
  factory Input$ChatUpdateManyWithWhereWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateManyWithWhereWithoutChatSessionInputFromJson(json);

  final Input$ChatScalarWhereInput where;

  final Input$ChatUncheckedUpdateManyWithoutChatsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateManyWithWhereWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateManyWithWhereWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChatUpdateManyWithWhereWithoutChatSessionInput copyWith(
          {Input$ChatScalarWhereInput? where,
          Input$ChatUncheckedUpdateManyWithoutChatsInput? data}) =>
      Input$ChatUpdateManyWithWhereWithoutChatSessionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateManyWithWhereWithoutFromInput {
  Input$ChatUpdateManyWithWhereWithoutFromInput(
      {required this.where, required this.data});

  @override
  factory Input$ChatUpdateManyWithWhereWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateManyWithWhereWithoutFromInputFromJson(json);

  final Input$ChatScalarWhereInput where;

  final Input$ChatUncheckedUpdateManyWithoutMyChatsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateManyWithWhereWithoutFromInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateManyWithWhereWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChatUpdateManyWithWhereWithoutFromInput copyWith(
          {Input$ChatScalarWhereInput? where,
          Input$ChatUncheckedUpdateManyWithoutMyChatsInput? data}) =>
      Input$ChatUpdateManyWithWhereWithoutFromInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateWithoutChatSessionInput {
  Input$ChatUpdateWithoutChatSessionInput(
      {this.id,
      this.from,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChatUpdateWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateWithoutChatSessionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$UserUpdateOneRequiredWithoutMyChatsInput? from;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$from = from;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$from,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$from = from;
    final lOther$from = other.from;
    if (l$from != lOther$from) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChatUpdateWithoutChatSessionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$UserUpdateOneRequiredWithoutMyChatsInput? Function()? from,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChatUpdateWithoutChatSessionInput(
          id: id == null ? this.id : id(),
          from: from == null ? this.from : from(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateWithoutFromInput {
  Input$ChatUpdateWithoutFromInput(
      {this.id,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSession});

  @override
  factory Input$ChatUpdateWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateWithoutFromInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$NullableDateTimeFieldUpdateOperationsInput? readAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChatSessionUpdateOneRequiredWithoutChatsInput? chatSession;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateWithoutFromInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSession = chatSession;
    return Object.hashAll([
      l$id,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSession
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSession = chatSession;
    final lOther$chatSession = other.chatSession;
    if (l$chatSession != lOther$chatSession) return false;
    return true;
  }

  Input$ChatUpdateWithoutFromInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? readAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChatSessionUpdateOneRequiredWithoutChatsInput? Function()?
              chatSession}) =>
      Input$ChatUpdateWithoutFromInput(
          id: id == null ? this.id : id(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSession: chatSession == null ? this.chatSession : chatSession());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput {
  Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput(
      {required this.where, required this.data});

  @override
  factory Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateWithWhereUniqueWithoutChatSessionInputFromJson(json);

  final Input$ChatWhereUniqueInput where;

  final Input$ChatUncheckedUpdateWithoutChatSessionInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateWithWhereUniqueWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput copyWith(
          {Input$ChatWhereUniqueInput? where,
          Input$ChatUncheckedUpdateWithoutChatSessionInput? data}) =>
      Input$ChatUpdateWithWhereUniqueWithoutChatSessionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpdateWithWhereUniqueWithoutFromInput {
  Input$ChatUpdateWithWhereUniqueWithoutFromInput(
      {required this.where, required this.data});

  @override
  factory Input$ChatUpdateWithWhereUniqueWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpdateWithWhereUniqueWithoutFromInputFromJson(json);

  final Input$ChatWhereUniqueInput where;

  final Input$ChatUncheckedUpdateWithoutFromInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpdateWithWhereUniqueWithoutFromInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpdateWithWhereUniqueWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChatUpdateWithWhereUniqueWithoutFromInput copyWith(
          {Input$ChatWhereUniqueInput? where,
          Input$ChatUncheckedUpdateWithoutFromInput? data}) =>
      Input$ChatUpdateWithWhereUniqueWithoutFromInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput {
  Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpsertWithWhereUniqueWithoutChatSessionInputFromJson(json);

  final Input$ChatWhereUniqueInput where;

  final Input$ChatUncheckedUpdateWithoutChatSessionInput update;

  final Input$ChatUncheckedCreateWithoutChatSessionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpsertWithWhereUniqueWithoutChatSessionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput copyWith(
          {Input$ChatWhereUniqueInput? where,
          Input$ChatUncheckedUpdateWithoutChatSessionInput? update,
          Input$ChatUncheckedCreateWithoutChatSessionInput? create}) =>
      Input$ChatUpsertWithWhereUniqueWithoutChatSessionInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatUpsertWithWhereUniqueWithoutFromInput {
  Input$ChatUpsertWithWhereUniqueWithoutFromInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ChatUpsertWithWhereUniqueWithoutFromInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChatUpsertWithWhereUniqueWithoutFromInputFromJson(json);

  final Input$ChatWhereUniqueInput where;

  final Input$ChatUncheckedUpdateWithoutFromInput update;

  final Input$ChatUncheckedCreateWithoutFromInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChatUpsertWithWhereUniqueWithoutFromInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatUpsertWithWhereUniqueWithoutFromInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChatUpsertWithWhereUniqueWithoutFromInput copyWith(
          {Input$ChatWhereUniqueInput? where,
          Input$ChatUncheckedUpdateWithoutFromInput? update,
          Input$ChatUncheckedCreateWithoutFromInput? create}) =>
      Input$ChatUpsertWithWhereUniqueWithoutFromInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChatWhereInput {
  Input$ChatWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.fromId,
      this.from,
      this.contentType,
      this.content,
      this.readAt,
      this.createdAt,
      this.updatedAt,
      this.chatSessionId,
      this.chatSession});

  @override
  factory Input$ChatWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatWhereInputFromJson(json);

  final List<Input$ChatWhereInput?>? AND;

  final List<Input$ChatWhereInput?>? OR;

  final List<Input$ChatWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? fromId;

  final Input$UserWhereInput? from;

  final Input$EnumContentTypeFilter? contentType;

  final Input$StringFilter? content;

  final Input$DateTimeNullableFilter? readAt;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$StringFilter? chatSessionId;

  final Input$ChatSessionWhereInput? chatSession;

  Map<String, dynamic> toJson() => _$Input$ChatWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$fromId = fromId;
    final l$from = from;
    final l$contentType = contentType;
    final l$content = content;
    final l$readAt = readAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chatSessionId = chatSessionId;
    final l$chatSession = chatSession;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$fromId,
      l$from,
      l$contentType,
      l$content,
      l$readAt,
      l$createdAt,
      l$updatedAt,
      l$chatSessionId,
      l$chatSession
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (l$fromId != lOther$fromId) return false;
    final l$from = from;
    final lOther$from = other.from;
    if (l$from != lOther$from) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$readAt = readAt;
    final lOther$readAt = other.readAt;
    if (l$readAt != lOther$readAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chatSessionId = chatSessionId;
    final lOther$chatSessionId = other.chatSessionId;
    if (l$chatSessionId != lOther$chatSessionId) return false;
    final l$chatSession = chatSession;
    final lOther$chatSession = other.chatSession;
    if (l$chatSession != lOther$chatSession) return false;
    return true;
  }

  Input$ChatWhereInput copyWith(
          {List<Input$ChatWhereInput?>? Function()? AND,
          List<Input$ChatWhereInput?>? Function()? OR,
          List<Input$ChatWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? fromId,
          Input$UserWhereInput? Function()? from,
          Input$EnumContentTypeFilter? Function()? contentType,
          Input$StringFilter? Function()? content,
          Input$DateTimeNullableFilter? Function()? readAt,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$StringFilter? Function()? chatSessionId,
          Input$ChatSessionWhereInput? Function()? chatSession}) =>
      Input$ChatWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          fromId: fromId == null ? this.fromId : fromId(),
          from: from == null ? this.from : from(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          readAt: readAt == null ? this.readAt : readAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chatSessionId:
              chatSessionId == null ? this.chatSessionId : chatSessionId(),
          chatSession: chatSession == null ? this.chatSession : chatSession());
}

@JsonSerializable(explicitToJson: true)
class Input$ChatWhereUniqueInput {
  Input$ChatWhereUniqueInput({this.id});

  @override
  factory Input$ChatWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChatWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() => _$Input$ChatWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChatWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ChatWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ChatWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomAvgOrderByAggregateInput {
  Input$ClassroomAvgOrderByAggregateInput({this.level});

  @override
  factory Input$ClassroomAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$level = level;
    return Object.hashAll([l$level]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    return true;
  }

  Input$ClassroomAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? level}) =>
      Input$ClassroomAvgOrderByAggregateInput(
          level: level == null ? this.level : level());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCountOrderByAggregateInput {
  Input$ClassroomCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? level,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateInput {
  Input$ClassroomCreateInput(
      {this.id,
      required this.name,
      this.school,
      required this.user,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomCreateInputFromJson(json);

  final String? id;

  final String name;

  final Input$SchoolCreateNestedOneWithoutClassroomsInput? school;

  final Input$UserCreateNestedOneWithoutClassroomsInput user;

  final Input$ClassroomStudentCreateNestedManyWithoutClassroomInput? students;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ClassroomCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$school = school;
    final l$user = user;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$school,
      l$user,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Input$SchoolCreateNestedOneWithoutClassroomsInput? Function()? school,
          Input$UserCreateNestedOneWithoutClassroomsInput? user,
          Input$ClassroomStudentCreateNestedManyWithoutClassroomInput?
                  Function()?
              students,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          school: school == null ? this.school : school(),
          user: user == null ? this.user : user,
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateManyInput {
  Input$ClassroomCreateManyInput(
      {this.id,
      required this.name,
      this.schoolId,
      required this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String? schoolId;

  final String userId;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ClassroomCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? schoolId,
          String? userId,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId,
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateManySchoolInput {
  Input$ClassroomCreateManySchoolInput(
      {this.id,
      required this.name,
      required this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateManySchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateManySchoolInputFromJson(json);

  final String? id;

  final String name;

  final String userId;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateManySchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$userId, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateManySchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateManySchoolInput copyWith(
          {String? Function()? id,
          String? name,
          String? userId,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateManySchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          userId: userId == null ? this.userId : userId,
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateManySchoolInputEnvelope {
  Input$ClassroomCreateManySchoolInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ClassroomCreateManySchoolInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateManySchoolInputEnvelopeFromJson(json);

  final Input$ClassroomCreateManySchoolInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateManySchoolInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateManySchoolInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ClassroomCreateManySchoolInputEnvelope copyWith(
          {Input$ClassroomCreateManySchoolInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ClassroomCreateManySchoolInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateManyUserInput {
  Input$ClassroomCreateManyUserInput(
      {this.id,
      required this.name,
      this.schoolId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateManyUserInputFromJson(json);

  final String? id;

  final String name;

  final String? schoolId;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$schoolId, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateManyUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? schoolId,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateManyUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateManyUserInputEnvelope {
  Input$ClassroomCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ClassroomCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateManyUserInputEnvelopeFromJson(json);

  final Input$ClassroomCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ClassroomCreateManyUserInputEnvelope copyWith(
          {Input$ClassroomCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ClassroomCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateNestedManyWithoutSchoolInput {
  Input$ClassroomCreateNestedManyWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomCreateNestedManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateNestedManyWithoutSchoolInputFromJson(json);

  final List<Input$ClassroomCreateWithoutSchoolInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final Input$ClassroomCreateManySchoolInputEnvelope? createMany;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateNestedManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateNestedManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomCreateNestedManyWithoutSchoolInput copyWith(
          {List<Input$ClassroomCreateWithoutSchoolInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          Input$ClassroomCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect}) =>
      Input$ClassroomCreateNestedManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateNestedManyWithoutUserInput {
  Input$ClassroomCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomCreateWithoutUserInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ClassroomCreateManyUserInputEnvelope? createMany;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ClassroomCreateWithoutUserInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ClassroomCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect}) =>
      Input$ClassroomCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateNestedOneWithoutStudentsInput {
  Input$ClassroomCreateNestedOneWithoutStudentsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ClassroomCreateNestedOneWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateNestedOneWithoutStudentsInputFromJson(json);

  final Input$ClassroomUncheckedCreateWithoutStudentsInput? create;

  final Input$ClassroomCreateOrConnectWithoutStudentsInput? connectOrCreate;

  final Input$ClassroomWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateNestedOneWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateNestedOneWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ClassroomCreateNestedOneWithoutStudentsInput copyWith(
          {Input$ClassroomUncheckedCreateWithoutStudentsInput? Function()?
              create,
          Input$ClassroomCreateOrConnectWithoutStudentsInput? Function()?
              connectOrCreate,
          Input$ClassroomWhereUniqueInput? Function()? connect}) =>
      Input$ClassroomCreateNestedOneWithoutStudentsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateOrConnectWithoutSchoolInput {
  Input$ClassroomCreateOrConnectWithoutSchoolInput(
      {required this.where, required this.create});

  @override
  factory Input$ClassroomCreateOrConnectWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateOrConnectWithoutSchoolInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateOrConnectWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateOrConnectWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomCreateOrConnectWithoutSchoolInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedCreateWithoutSchoolInput? create}) =>
      Input$ClassroomCreateOrConnectWithoutSchoolInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateOrConnectWithoutStudentsInput {
  Input$ClassroomCreateOrConnectWithoutStudentsInput(
      {required this.where, required this.create});

  @override
  factory Input$ClassroomCreateOrConnectWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateOrConnectWithoutStudentsInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedCreateWithoutStudentsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateOrConnectWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateOrConnectWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomCreateOrConnectWithoutStudentsInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedCreateWithoutStudentsInput? create}) =>
      Input$ClassroomCreateOrConnectWithoutStudentsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateOrConnectWithoutUserInput {
  Input$ClassroomCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ClassroomCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomCreateOrConnectWithoutUserInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedCreateWithoutUserInput? create}) =>
      Input$ClassroomCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateWithoutSchoolInput {
  Input$ClassroomCreateWithoutSchoolInput(
      {this.id,
      required this.name,
      required this.user,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final Input$UserCreateNestedOneWithoutClassroomsInput user;

  final Input$ClassroomStudentCreateNestedManyWithoutClassroomInput? students;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$user, l$students, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          Input$UserCreateNestedOneWithoutClassroomsInput? user,
          Input$ClassroomStudentCreateNestedManyWithoutClassroomInput?
                  Function()?
              students,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          user: user == null ? this.user : user,
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateWithoutStudentsInput {
  Input$ClassroomCreateWithoutStudentsInput(
      {this.id,
      required this.name,
      this.school,
      required this.user,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateWithoutStudentsInputFromJson(json);

  final String? id;

  final String name;

  final Input$SchoolCreateNestedOneWithoutClassroomsInput? school;

  final Input$UserCreateNestedOneWithoutClassroomsInput user;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$school = school;
    final l$user = user;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$school, l$user, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateWithoutStudentsInput copyWith(
          {String? Function()? id,
          String? name,
          Input$SchoolCreateNestedOneWithoutClassroomsInput? Function()? school,
          Input$UserCreateNestedOneWithoutClassroomsInput? user,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          school: school == null ? this.school : school(),
          user: user == null ? this.user : user,
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomCreateWithoutUserInput {
  Input$ClassroomCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.school,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final Input$SchoolCreateNestedOneWithoutClassroomsInput? school;

  final Input$ClassroomStudentCreateNestedManyWithoutClassroomInput? students;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$school = school;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$school,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          Input$SchoolCreateNestedOneWithoutClassroomsInput? Function()? school,
          Input$ClassroomStudentCreateNestedManyWithoutClassroomInput?
                  Function()?
              students,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          school: school == null ? this.school : school(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomListRelationFilter {
  Input$ClassroomListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ClassroomListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomListRelationFilterFromJson(json);

  final Input$ClassroomWhereInput? every;

  final Input$ClassroomWhereInput? some;

  final Input$ClassroomWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ClassroomListRelationFilter copyWith(
          {Input$ClassroomWhereInput? Function()? every,
          Input$ClassroomWhereInput? Function()? some,
          Input$ClassroomWhereInput? Function()? none}) =>
      Input$ClassroomListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomMaxOrderByAggregateInput {
  Input$ClassroomMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? level,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomMinOrderByAggregateInput {
  Input$ClassroomMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? level,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomOrderByRelationAggregateInput {
  Input$ClassroomOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ClassroomOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ClassroomOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ClassroomOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomOrderByWithAggregationInput {
  Input$ClassroomOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ClassroomOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ClassroomCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ClassroomAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ClassroomMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ClassroomMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ClassroomSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ClassroomOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? level,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ClassroomCountOrderByAggregateInput? Function()? $_count,
          Input$ClassroomAvgOrderByAggregateInput? Function()? $_avg,
          Input$ClassroomMaxOrderByAggregateInput? Function()? $_max,
          Input$ClassroomMinOrderByAggregateInput? Function()? $_min,
          Input$ClassroomSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ClassroomOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomOrderByWithRelationInput {
  Input$ClassroomOrderByWithRelationInput(
      {this.id,
      this.name,
      this.schoolId,
      this.school,
      this.userId,
      this.user,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  final Input$SchoolOrderByWithRelationInput? school;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  final Input$ClassroomStudentOrderByRelationAggregateInput? students;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$school = school;
    final l$userId = userId;
    final l$user = user;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$school,
      l$userId,
      l$user,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? schoolId,
          Input$SchoolOrderByWithRelationInput? Function()? school,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Input$ClassroomStudentOrderByRelationAggregateInput? Function()?
              students,
          Enum$SortOrder? Function()? level,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          school: school == null ? this.school : school(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomRelationFilter {
  Input$ClassroomRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ClassroomRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ClassroomWhereInput? $is;

  final Input$ClassroomWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$ClassroomRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ClassroomRelationFilter copyWith(
          {Input$ClassroomWhereInput? Function()? $is,
          Input$ClassroomWhereInput? Function()? isNot}) =>
      Input$ClassroomRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomScalarWhereInput {
  Input$ClassroomScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomScalarWhereInputFromJson(json);

  final List<Input$ClassroomScalarWhereInput?>? AND;

  final List<Input$ClassroomScalarWhereInput?>? OR;

  final List<Input$ClassroomScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringNullableFilter? schoolId;

  final Input$StringFilter? userId;

  final Input$IntFilter? level;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomScalarWhereInput copyWith(
          {List<Input$ClassroomScalarWhereInput?>? Function()? AND,
          List<Input$ClassroomScalarWhereInput?>? Function()? OR,
          List<Input$ClassroomScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringNullableFilter? Function()? schoolId,
          Input$StringFilter? Function()? userId,
          Input$IntFilter? Function()? level,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ClassroomScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomScalarWhereWithAggregatesInput {
  Input$ClassroomScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ClassroomScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ClassroomScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ClassroomScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringNullableWithAggregatesFilter? schoolId;

  final Input$StringWithAggregatesFilter? userId;

  final Input$IntWithAggregatesFilter? level;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomScalarWhereWithAggregatesInput copyWith(
          {List<Input$ClassroomScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ClassroomScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ClassroomScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringNullableWithAggregatesFilter? Function()? schoolId,
          Input$StringWithAggregatesFilter? Function()? userId,
          Input$IntWithAggregatesFilter? Function()? level,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ClassroomScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCountOrderByAggregateInput {
  Input$ClassroomStudentCountOrderByAggregateInput(
      {this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? classroomId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? classroomId,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomStudentCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateInput {
  Input$ClassroomStudentCreateInput(
      {this.id,
      required this.user,
      this.classroom,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateInputFromJson(json);

  final String? id;

  final Input$UserCreateNestedOneWithoutClassroomStudentsInput user;

  final Input$ClassroomCreateNestedOneWithoutStudentsInput? classroom;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$user = user;
    final l$classroom = classroom;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$user, l$classroom, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$classroom = classroom;
    final lOther$classroom = other.classroom;
    if (l$classroom != lOther$classroom) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCreateInput copyWith(
          {String? Function()? id,
          Input$UserCreateNestedOneWithoutClassroomStudentsInput? user,
          Input$ClassroomCreateNestedOneWithoutStudentsInput? Function()?
              classroom,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentCreateInput(
          id: id == null ? this.id : id(),
          user: user == null ? this.user : user,
          classroom: classroom == null ? this.classroom : classroom(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateManyClassroomInput {
  Input$ClassroomStudentCreateManyClassroomInput(
      {this.id,
      required this.userId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentCreateManyClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateManyClassroomInputFromJson(json);

  final String? id;

  final String userId;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateManyClassroomInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateManyClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCreateManyClassroomInput copyWith(
          {String? Function()? id,
          String? userId,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentCreateManyClassroomInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateManyClassroomInputEnvelope {
  Input$ClassroomStudentCreateManyClassroomInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ClassroomStudentCreateManyClassroomInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateManyClassroomInputEnvelopeFromJson(json);

  final Input$ClassroomStudentCreateManyClassroomInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateManyClassroomInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateManyClassroomInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ClassroomStudentCreateManyClassroomInputEnvelope copyWith(
          {Input$ClassroomStudentCreateManyClassroomInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ClassroomStudentCreateManyClassroomInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateManyInput {
  Input$ClassroomStudentCreateManyInput(
      {this.id,
      required this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateManyInputFromJson(json);

  final String? id;

  final String userId;

  final String? classroomId;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCreateManyInput copyWith(
          {String? Function()? id,
          String? userId,
          String? Function()? classroomId,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentCreateManyInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateManyUserInput {
  Input$ClassroomStudentCreateManyUserInput(
      {this.id, this.classroomId, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateManyUserInputFromJson(json);

  final String? id;

  final String? classroomId;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCreateManyUserInput copyWith(
          {String? Function()? id,
          String? Function()? classroomId,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentCreateManyUserInput(
          id: id == null ? this.id : id(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateManyUserInputEnvelope {
  Input$ClassroomStudentCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ClassroomStudentCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateManyUserInputEnvelopeFromJson(json);

  final Input$ClassroomStudentCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ClassroomStudentCreateManyUserInputEnvelope copyWith(
          {Input$ClassroomStudentCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ClassroomStudentCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateNestedManyWithoutClassroomInput {
  Input$ClassroomStudentCreateNestedManyWithoutClassroomInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomStudentCreateNestedManyWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateNestedManyWithoutClassroomInputFromJson(
          json);

  final List<Input$ClassroomStudentCreateWithoutClassroomInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
      connectOrCreate;

  final Input$ClassroomStudentCreateManyClassroomInputEnvelope? createMany;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateNestedManyWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentCreateNestedManyWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentCreateNestedManyWithoutClassroomInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutClassroomInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
                  Function()?
              connectOrCreate,
          Input$ClassroomStudentCreateManyClassroomInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()?
              connect}) =>
      Input$ClassroomStudentCreateNestedManyWithoutClassroomInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateNestedManyWithoutUserInput {
  Input$ClassroomStudentCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomStudentCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomStudentCreateWithoutUserInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ClassroomStudentCreateManyUserInputEnvelope? createMany;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutUserInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
                  Function()?
              connectOrCreate,
          Input$ClassroomStudentCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()?
              connect}) =>
      Input$ClassroomStudentCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateOrConnectWithoutClassroomInput {
  Input$ClassroomStudentCreateOrConnectWithoutClassroomInput(
      {required this.where, required this.create});

  @override
  factory Input$ClassroomStudentCreateOrConnectWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateOrConnectWithoutClassroomInputFromJson(
          json);

  final Input$ClassroomStudentWhereUniqueInput where;

  final Input$ClassroomStudentUncheckedCreateWithoutClassroomInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateOrConnectWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentCreateOrConnectWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomStudentCreateOrConnectWithoutClassroomInput copyWith(
          {Input$ClassroomStudentWhereUniqueInput? where,
          Input$ClassroomStudentUncheckedCreateWithoutClassroomInput?
              create}) =>
      Input$ClassroomStudentCreateOrConnectWithoutClassroomInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateOrConnectWithoutUserInput {
  Input$ClassroomStudentCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ClassroomStudentCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ClassroomStudentWhereUniqueInput where;

  final Input$ClassroomStudentUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomStudentCreateOrConnectWithoutUserInput copyWith(
          {Input$ClassroomStudentWhereUniqueInput? where,
          Input$ClassroomStudentUncheckedCreateWithoutUserInput? create}) =>
      Input$ClassroomStudentCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateWithoutClassroomInput {
  Input$ClassroomStudentCreateWithoutClassroomInput(
      {this.id,
      required this.user,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentCreateWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateWithoutClassroomInputFromJson(json);

  final String? id;

  final Input$UserCreateNestedOneWithoutClassroomStudentsInput user;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$user = user;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$user, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCreateWithoutClassroomInput copyWith(
          {String? Function()? id,
          Input$UserCreateNestedOneWithoutClassroomStudentsInput? user,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentCreateWithoutClassroomInput(
          id: id == null ? this.id : id(),
          user: user == null ? this.user : user,
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentCreateWithoutUserInput {
  Input$ClassroomStudentCreateWithoutUserInput(
      {this.id, this.classroom, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentCreateWithoutUserInputFromJson(json);

  final String? id;

  final Input$ClassroomCreateNestedOneWithoutStudentsInput? classroom;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$classroom = classroom;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$classroom, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$classroom = classroom;
    final lOther$classroom = other.classroom;
    if (l$classroom != lOther$classroom) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentCreateWithoutUserInput copyWith(
          {String? Function()? id,
          Input$ClassroomCreateNestedOneWithoutStudentsInput? Function()?
              classroom,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          classroom: classroom == null ? this.classroom : classroom(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentListRelationFilter {
  Input$ClassroomStudentListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ClassroomStudentListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentListRelationFilterFromJson(json);

  final Input$ClassroomStudentWhereInput? every;

  final Input$ClassroomStudentWhereInput? some;

  final Input$ClassroomStudentWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ClassroomStudentListRelationFilter copyWith(
          {Input$ClassroomStudentWhereInput? Function()? every,
          Input$ClassroomStudentWhereInput? Function()? some,
          Input$ClassroomStudentWhereInput? Function()? none}) =>
      Input$ClassroomStudentListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentMaxOrderByAggregateInput {
  Input$ClassroomStudentMaxOrderByAggregateInput(
      {this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? classroomId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? classroomId,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomStudentMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentMinOrderByAggregateInput {
  Input$ClassroomStudentMinOrderByAggregateInput(
      {this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? classroomId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? classroomId,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomStudentMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentOrderByRelationAggregateInput {
  Input$ClassroomStudentOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ClassroomStudentOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ClassroomStudentOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ClassroomStudentOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentOrderByWithAggregationInput {
  Input$ClassroomStudentOrderByWithAggregationInput(
      {this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$ClassroomStudentOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? classroomId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ClassroomStudentCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$ClassroomStudentMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ClassroomStudentMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$userId,
      l$classroomId,
      l$status,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$ClassroomStudentOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? classroomId,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ClassroomStudentCountOrderByAggregateInput? Function()? $_count,
          Input$ClassroomStudentMaxOrderByAggregateInput? Function()? $_max,
          Input$ClassroomStudentMinOrderByAggregateInput? Function()? $_min}) =>
      Input$ClassroomStudentOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentOrderByWithRelationInput {
  Input$ClassroomStudentOrderByWithRelationInput(
      {this.id,
      this.userId,
      this.user,
      this.classroom,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  final Input$ClassroomOrderByWithRelationInput? classroom;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? classroomId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$user = user;
    final l$classroom = classroom;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$user,
      l$classroom,
      l$classroomId,
      l$status,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$classroom = classroom;
    final lOther$classroom = other.classroom;
    if (l$classroom != lOther$classroom) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Input$ClassroomOrderByWithRelationInput? Function()? classroom,
          Enum$SortOrder? Function()? classroomId,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ClassroomStudentOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          classroom: classroom == null ? this.classroom : classroom(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentScalarWhereInput {
  Input$ClassroomStudentScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentScalarWhereInputFromJson(json);

  final List<Input$ClassroomStudentScalarWhereInput?>? AND;

  final List<Input$ClassroomStudentScalarWhereInput?>? OR;

  final List<Input$ClassroomStudentScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? userId;

  final Input$StringNullableFilter? classroomId;

  final Input$EnumClassroomStudentStatusFilter? status;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$userId,
      l$classroomId,
      l$status,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentScalarWhereInput copyWith(
          {List<Input$ClassroomStudentScalarWhereInput?>? Function()? AND,
          List<Input$ClassroomStudentScalarWhereInput?>? Function()? OR,
          List<Input$ClassroomStudentScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? userId,
          Input$StringNullableFilter? Function()? classroomId,
          Input$EnumClassroomStudentStatusFilter? Function()? status,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ClassroomStudentScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentScalarWhereWithAggregatesInput {
  Input$ClassroomStudentScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ClassroomStudentScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ClassroomStudentScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ClassroomStudentScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? userId;

  final Input$StringNullableWithAggregatesFilter? classroomId;

  final Input$EnumClassroomStudentStatusWithAggregatesFilter? status;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$userId,
      l$classroomId,
      l$status,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentScalarWhereWithAggregatesInput copyWith(
          {List<Input$ClassroomStudentScalarWhereWithAggregatesInput?>?
                  Function()?
              AND,
          List<Input$ClassroomStudentScalarWhereWithAggregatesInput?>?
                  Function()?
              OR,
          List<Input$ClassroomStudentScalarWhereWithAggregatesInput?>?
                  Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? userId,
          Input$StringNullableWithAggregatesFilter? Function()? classroomId,
          Input$EnumClassroomStudentStatusWithAggregatesFilter? Function()?
              status,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ClassroomStudentScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedCreateInput {
  Input$ClassroomStudentUncheckedCreateInput(
      {this.id,
      required this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedCreateInputFromJson(json);

  final String? id;

  final String userId;

  final String? classroomId;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? userId,
          String? Function()? classroomId,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedCreateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput {
  Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInputFromJson(
          json);

  final List<Input$ClassroomStudentCreateWithoutClassroomInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
      connectOrCreate;

  final Input$ClassroomStudentCreateManyClassroomInputEnvelope? createMany;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutClassroomInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
                  Function()?
              connectOrCreate,
          Input$ClassroomStudentCreateManyClassroomInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()?
              connect}) =>
      Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput {
  Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$ClassroomStudentCreateWithoutUserInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ClassroomStudentCreateManyUserInputEnvelope? createMany;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutUserInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
                  Function()?
              connectOrCreate,
          Input$ClassroomStudentCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()?
              connect}) =>
      Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedCreateWithoutClassroomInput {
  Input$ClassroomStudentUncheckedCreateWithoutClassroomInput(
      {this.id,
      required this.userId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedCreateWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedCreateWithoutClassroomInputFromJson(
          json);

  final String? id;

  final String userId;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedCreateWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedCreateWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedCreateWithoutClassroomInput copyWith(
          {String? Function()? id,
          String? userId,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedCreateWithoutClassroomInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedCreateWithoutUserInput {
  Input$ClassroomStudentUncheckedCreateWithoutUserInput(
      {this.id, this.classroomId, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String? classroomId;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? status;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? Function()? classroomId,
          Enum$ClassroomStudentStatus? Function()? status,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateInput {
  Input$ClassroomStudentUncheckedUpdateInput(
      {this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$NullableStringFieldUpdateOperationsInput? classroomId;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              classroomId,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateManyInput {
  Input$ClassroomStudentUncheckedUpdateManyInput(
      {this.id,
      this.userId,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$NullableStringFieldUpdateOperationsInput? classroomId;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$userId, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              classroomId,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput {
  Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInputFromJson(
          json);

  final List<Input$ClassroomStudentCreateWithoutClassroomInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
      connectOrCreate;

  final List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput?>?
      upsert;

  final Input$ClassroomStudentCreateManyClassroomInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomStudentWhereUniqueInput?>? $set;

  final List<Input$ClassroomStudentWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomStudentWhereUniqueInput?>? delete;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  final List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput?>?
      update;

  final List<Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput?>?
      updateMany;

  final List<Input$ClassroomStudentScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutClassroomInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput?>?
                  Function()?
              upsert,
          Input$ClassroomStudentCreateManyClassroomInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput?>?
                  Function()?
              update,
          List<Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput?>?
                  Function()?
              updateMany,
          List<Input$ClassroomStudentScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput {
  Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput(
      {this.id, this.classroomId, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? classroomId;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput
      copyWith(
              {Input$StringFieldUpdateOperationsInput? Function()? id,
              Input$NullableStringFieldUpdateOperationsInput? Function()?
                  classroomId,
              Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                      Function()?
                  status,
              Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
              Input$DateTimeFieldUpdateOperationsInput? Function()?
                  updatedAt}) =>
          Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput(
              id: id == null ? this.id : id(),
              classroomId:
                  classroomId == null ? this.classroomId : classroomId(),
              status: status == null ? this.status : status(),
              createdAt: createdAt == null ? this.createdAt : createdAt(),
              updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput {
  Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput(
      {this.id, this.userId, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput {
  Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomStudentCreateWithoutUserInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput?>?
      upsert;

  final Input$ClassroomStudentCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomStudentWhereUniqueInput?>? $set;

  final List<Input$ClassroomStudentWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomStudentWhereUniqueInput?>? delete;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  final List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput?>?
      update;

  final List<Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$ClassroomStudentScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutUserInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ClassroomStudentCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ClassroomStudentScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput {
  Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput(
      {this.id, this.userId, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateWithoutClassroomInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUncheckedUpdateWithoutUserInput {
  Input$ClassroomStudentUncheckedUpdateWithoutUserInput(
      {this.id, this.classroomId, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? classroomId;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$classroomId, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              classroomId,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateInput {
  Input$ClassroomStudentUpdateInput(
      {this.id,
      this.user,
      this.classroom,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$UserUpdateOneRequiredWithoutClassroomStudentsInput? user;

  final Input$ClassroomUpdateOneWithoutStudentsInput? classroom;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$user = user;
    final l$classroom = classroom;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$user, l$classroom, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$classroom = classroom;
    final lOther$classroom = other.classroom;
    if (l$classroom != lOther$classroom) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$UserUpdateOneRequiredWithoutClassroomStudentsInput? Function()?
              user,
          Input$ClassroomUpdateOneWithoutStudentsInput? Function()? classroom,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUpdateInput(
          id: id == null ? this.id : id(),
          user: user == null ? this.user : user(),
          classroom: classroom == null ? this.classroom : classroom(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateManyMutationInput {
  Input$ClassroomStudentUpdateManyMutationInput(
      {this.id, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateManyWithoutClassroomInput {
  Input$ClassroomStudentUpdateManyWithoutClassroomInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomStudentUpdateManyWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateManyWithoutClassroomInputFromJson(json);

  final List<Input$ClassroomStudentCreateWithoutClassroomInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
      connectOrCreate;

  final List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput?>?
      upsert;

  final Input$ClassroomStudentCreateManyClassroomInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomStudentWhereUniqueInput?>? $set;

  final List<Input$ClassroomStudentWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomStudentWhereUniqueInput?>? delete;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  final List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput?>?
      update;

  final List<Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput?>?
      updateMany;

  final List<Input$ClassroomStudentScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateManyWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateManyWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentUpdateManyWithoutClassroomInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutClassroomInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutClassroomInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput?>?
                  Function()?
              upsert,
          Input$ClassroomStudentCreateManyClassroomInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput?>?
                  Function()?
              update,
          List<Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput?>?
                  Function()?
              updateMany,
          List<Input$ClassroomStudentScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ClassroomStudentUpdateManyWithoutClassroomInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateManyWithoutUserInput {
  Input$ClassroomStudentUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomStudentUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomStudentCreateWithoutUserInput?>? create;

  final List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput?>?
      upsert;

  final Input$ClassroomStudentCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomStudentWhereUniqueInput?>? $set;

  final List<Input$ClassroomStudentWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomStudentWhereUniqueInput?>? delete;

  final List<Input$ClassroomStudentWhereUniqueInput?>? connect;

  final List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput?>?
      update;

  final List<Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$ClassroomStudentScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomStudentUpdateManyWithoutUserInput copyWith(
          {List<Input$ClassroomStudentCreateWithoutUserInput?>? Function()?
              create,
          List<Input$ClassroomStudentCreateOrConnectWithoutUserInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ClassroomStudentCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomStudentWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ClassroomStudentScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ClassroomStudentUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput {
  Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInputFromJson(
          json);

  final Input$ClassroomStudentScalarWhereInput where;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput copyWith(
          {Input$ClassroomStudentScalarWhereInput? where,
          Input$ClassroomStudentUncheckedUpdateManyWithoutStudentsInput?
              data}) =>
      Input$ClassroomStudentUpdateManyWithWhereWithoutClassroomInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput {
  Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ClassroomStudentScalarWhereInput where;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput
      data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ClassroomStudentScalarWhereInput? where,
          Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomStudentsInput?
              data}) =>
      Input$ClassroomStudentUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateWithoutClassroomInput {
  Input$ClassroomStudentUpdateWithoutClassroomInput(
      {this.id, this.user, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUpdateWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateWithoutClassroomInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$UserUpdateOneRequiredWithoutClassroomStudentsInput? user;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateWithoutClassroomInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$user = user;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$user, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUpdateWithoutClassroomInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$UserUpdateOneRequiredWithoutClassroomStudentsInput? Function()?
              user,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUpdateWithoutClassroomInput(
          id: id == null ? this.id : id(),
          user: user == null ? this.user : user(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateWithoutUserInput {
  Input$ClassroomStudentUpdateWithoutUserInput(
      {this.id, this.classroom, this.status, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomStudentUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$ClassroomUpdateOneWithoutStudentsInput? classroom;

  final Input$EnumClassroomStudentStatusFieldUpdateOperationsInput? status;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$classroom = classroom;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$classroom, l$status, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$classroom = classroom;
    final lOther$classroom = other.classroom;
    if (l$classroom != lOther$classroom) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$ClassroomUpdateOneWithoutStudentsInput? Function()? classroom,
          Input$EnumClassroomStudentStatusFieldUpdateOperationsInput?
                  Function()?
              status,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomStudentUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          classroom: classroom == null ? this.classroom : classroom(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput {
  Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInputFromJson(
          json);

  final Input$ClassroomStudentWhereUniqueInput where;

  final Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput copyWith(
          {Input$ClassroomStudentWhereUniqueInput? where,
          Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput? data}) =>
      Input$ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput {
  Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInputFromJson(
          json);

  final Input$ClassroomStudentWhereUniqueInput where;

  final Input$ClassroomStudentUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ClassroomStudentWhereUniqueInput? where,
          Input$ClassroomStudentUncheckedUpdateWithoutUserInput? data}) =>
      Input$ClassroomStudentUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput {
  Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInputFromJson(
          json);

  final Input$ClassroomStudentWhereUniqueInput where;

  final Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput update;

  final Input$ClassroomStudentUncheckedCreateWithoutClassroomInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput copyWith(
          {Input$ClassroomStudentWhereUniqueInput? where,
          Input$ClassroomStudentUncheckedUpdateWithoutClassroomInput? update,
          Input$ClassroomStudentUncheckedCreateWithoutClassroomInput?
              create}) =>
      Input$ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput {
  Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInputFromJson(
          json);

  final Input$ClassroomStudentWhereUniqueInput where;

  final Input$ClassroomStudentUncheckedUpdateWithoutUserInput update;

  final Input$ClassroomStudentUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ClassroomStudentWhereUniqueInput? where,
          Input$ClassroomStudentUncheckedUpdateWithoutUserInput? update,
          Input$ClassroomStudentUncheckedCreateWithoutUserInput? create}) =>
      Input$ClassroomStudentUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentWhereInput {
  Input$ClassroomStudentWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.userId,
      this.user,
      this.classroom,
      this.classroomId,
      this.status,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomStudentWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentWhereInputFromJson(json);

  final List<Input$ClassroomStudentWhereInput?>? AND;

  final List<Input$ClassroomStudentWhereInput?>? OR;

  final List<Input$ClassroomStudentWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$ClassroomWhereInput? classroom;

  final Input$StringNullableFilter? classroomId;

  final Input$EnumClassroomStudentStatusFilter? status;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$userId = userId;
    final l$user = user;
    final l$classroom = classroom;
    final l$classroomId = classroomId;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$userId,
      l$user,
      l$classroom,
      l$classroomId,
      l$status,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$classroom = classroom;
    final lOther$classroom = other.classroom;
    if (l$classroom != lOther$classroom) return false;
    final l$classroomId = classroomId;
    final lOther$classroomId = other.classroomId;
    if (l$classroomId != lOther$classroomId) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomStudentWhereInput copyWith(
          {List<Input$ClassroomStudentWhereInput?>? Function()? AND,
          List<Input$ClassroomStudentWhereInput?>? Function()? OR,
          List<Input$ClassroomStudentWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$ClassroomWhereInput? Function()? classroom,
          Input$StringNullableFilter? Function()? classroomId,
          Input$EnumClassroomStudentStatusFilter? Function()? status,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ClassroomStudentWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          classroom: classroom == null ? this.classroom : classroom(),
          classroomId: classroomId == null ? this.classroomId : classroomId(),
          status: status == null ? this.status : status(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomStudentWhereUniqueInput {
  Input$ClassroomStudentWhereUniqueInput({this.id});

  @override
  factory Input$ClassroomStudentWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomStudentWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomStudentWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomStudentWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ClassroomStudentWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ClassroomStudentWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomSumOrderByAggregateInput {
  Input$ClassroomSumOrderByAggregateInput({this.level});

  @override
  factory Input$ClassroomSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? level;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$level = level;
    return Object.hashAll([l$level]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    return true;
  }

  Input$ClassroomSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? level}) =>
      Input$ClassroomSumOrderByAggregateInput(
          level: level == null ? this.level : level());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedCreateInput {
  Input$ClassroomUncheckedCreateInput(
      {this.id,
      required this.name,
      this.schoolId,
      required this.userId,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String? schoolId;

  final String userId;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput?
      students;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? schoolId,
          String? userId,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput?
                  Function()?
              students,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId,
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput {
  Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInputFromJson(
          json);

  final List<Input$ClassroomCreateWithoutSchoolInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final Input$ClassroomCreateManySchoolInputEnvelope? createMany;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput copyWith(
          {List<Input$ClassroomCreateWithoutSchoolInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          Input$ClassroomCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect}) =>
      Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedCreateNestedManyWithoutUserInput {
  Input$ClassroomUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ClassroomUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomCreateWithoutUserInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ClassroomCreateManyUserInputEnvelope? createMany;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ClassroomUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ClassroomCreateWithoutUserInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ClassroomCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect}) =>
      Input$ClassroomUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedCreateWithoutSchoolInput {
  Input$ClassroomUncheckedCreateWithoutSchoolInput(
      {this.id,
      required this.name,
      required this.userId,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final String userId;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput?
      students;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$userId,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          String? userId,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput?
                  Function()?
              students,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomUncheckedCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          userId: userId == null ? this.userId : userId,
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedCreateWithoutStudentsInput {
  Input$ClassroomUncheckedCreateWithoutStudentsInput(
      {this.id,
      required this.name,
      this.schoolId,
      required this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedCreateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedCreateWithoutStudentsInputFromJson(json);

  final String? id;

  final String name;

  final String? schoolId;

  final String userId;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedCreateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedCreateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedCreateWithoutStudentsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? schoolId,
          String? userId,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomUncheckedCreateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId,
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedCreateWithoutUserInput {
  Input$ClassroomUncheckedCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.schoolId,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String? schoolId;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput?
      students;

  final int? level;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? schoolId,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput?
                  Function()?
              students,
          int? Function()? level,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ClassroomUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateInput {
  Input$ClassroomUncheckedUpdateInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput?
      students;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? schoolId,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput?
                  Function()?
              students,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateManyInput {
  Input$ClassroomUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? schoolId,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput {
  Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput(
      {this.id,
      this.name,
      this.schoolId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateManyWithoutClassroomsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateManyWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$schoolId, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? schoolId,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateManyWithoutSchoolInput {
  Input$ClassroomUncheckedUpdateManyWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomUncheckedUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateManyWithoutSchoolInputFromJson(json);

  final List<Input$ClassroomCreateWithoutSchoolInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final List<Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput?>? upsert;

  final Input$ClassroomCreateManySchoolInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomWhereUniqueInput?>? $set;

  final List<Input$ClassroomWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomWhereUniqueInput?>? delete;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  final List<Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput?>? update;

  final List<Input$ClassroomUpdateManyWithWhereWithoutSchoolInput?>? updateMany;

  final List<Input$ClassroomScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomUncheckedUpdateManyWithoutSchoolInput copyWith(
          {List<Input$ClassroomCreateWithoutSchoolInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          List<Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              upsert,
          Input$ClassroomCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              update,
          List<Input$ClassroomUpdateManyWithWhereWithoutSchoolInput?>?
                  Function()?
              updateMany,
          List<Input$ClassroomScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ClassroomUncheckedUpdateManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateManyWithoutUserInput {
  Input$ClassroomUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomCreateWithoutUserInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ClassroomUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ClassroomCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomWhereUniqueInput?>? $set;

  final List<Input$ClassroomWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomWhereUniqueInput?>? delete;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  final List<Input$ClassroomUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ClassroomUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ClassroomScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ClassroomCreateWithoutUserInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ClassroomUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ClassroomCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ClassroomUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ClassroomScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ClassroomUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateWithoutSchoolInput {
  Input$ClassroomUncheckedUpdateWithoutSchoolInput(
      {this.id,
      this.name,
      this.userId,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput?
      students;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$userId,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput?
                  Function()?
              students,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUncheckedUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateWithoutStudentsInput {
  Input$ClassroomUncheckedUpdateWithoutStudentsInput(
      {this.id,
      this.name,
      this.schoolId,
      this.userId,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedUpdateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateWithoutStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$userId,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedUpdateWithoutStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? schoolId,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUncheckedUpdateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUncheckedUpdateWithoutUserInput {
  Input$ClassroomUncheckedUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.schoolId,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput?
      students;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$schoolId,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? schoolId,
          Input$ClassroomStudentUncheckedUpdateManyWithoutClassroomInput?
                  Function()?
              students,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateInput {
  Input$ClassroomUpdateInput(
      {this.id,
      this.name,
      this.school,
      this.user,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$SchoolUpdateOneWithoutClassroomsInput? school;

  final Input$UserUpdateOneRequiredWithoutClassroomsInput? user;

  final Input$ClassroomStudentUpdateManyWithoutClassroomInput? students;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ClassroomUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$school = school;
    final l$user = user;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$school,
      l$user,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$SchoolUpdateOneWithoutClassroomsInput? Function()? school,
          Input$UserUpdateOneRequiredWithoutClassroomsInput? Function()? user,
          Input$ClassroomStudentUpdateManyWithoutClassroomInput? Function()?
              students,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          school: school == null ? this.school : school(),
          user: user == null ? this.user : user(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateManyMutationInput {
  Input$ClassroomUpdateManyMutationInput(
      {this.id, this.name, this.level, this.createdAt, this.updatedAt});

  @override
  factory Input$ClassroomUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateManyWithoutSchoolInput {
  Input$ClassroomUpdateManyWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateManyWithoutSchoolInputFromJson(json);

  final List<Input$ClassroomCreateWithoutSchoolInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final List<Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput?>? upsert;

  final Input$ClassroomCreateManySchoolInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomWhereUniqueInput?>? $set;

  final List<Input$ClassroomWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomWhereUniqueInput?>? delete;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  final List<Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput?>? update;

  final List<Input$ClassroomUpdateManyWithWhereWithoutSchoolInput?>? updateMany;

  final List<Input$ClassroomScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomUpdateManyWithoutSchoolInput copyWith(
          {List<Input$ClassroomCreateWithoutSchoolInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          List<Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              upsert,
          Input$ClassroomCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              update,
          List<Input$ClassroomUpdateManyWithWhereWithoutSchoolInput?>?
                  Function()?
              updateMany,
          List<Input$ClassroomScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ClassroomUpdateManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateManyWithoutUserInput {
  Input$ClassroomUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ClassroomUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ClassroomCreateWithoutUserInput?>? create;

  final List<Input$ClassroomCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ClassroomUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ClassroomCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ClassroomWhereUniqueInput?>? $set;

  final List<Input$ClassroomWhereUniqueInput?>? disconnect;

  final List<Input$ClassroomWhereUniqueInput?>? delete;

  final List<Input$ClassroomWhereUniqueInput?>? connect;

  final List<Input$ClassroomUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ClassroomUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ClassroomScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ClassroomUpdateManyWithoutUserInput copyWith(
          {List<Input$ClassroomCreateWithoutUserInput?>? Function()? create,
          List<Input$ClassroomCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ClassroomUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ClassroomCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ClassroomWhereUniqueInput?>? Function()? $set,
          List<Input$ClassroomWhereUniqueInput?>? Function()? disconnect,
          List<Input$ClassroomWhereUniqueInput?>? Function()? delete,
          List<Input$ClassroomWhereUniqueInput?>? Function()? connect,
          List<Input$ClassroomUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ClassroomUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ClassroomScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ClassroomUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateManyWithWhereWithoutSchoolInput {
  Input$ClassroomUpdateManyWithWhereWithoutSchoolInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomUpdateManyWithWhereWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateManyWithWhereWithoutSchoolInputFromJson(json);

  final Input$ClassroomScalarWhereInput where;

  final Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateManyWithWhereWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateManyWithWhereWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomUpdateManyWithWhereWithoutSchoolInput copyWith(
          {Input$ClassroomScalarWhereInput? where,
          Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput? data}) =>
      Input$ClassroomUpdateManyWithWhereWithoutSchoolInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateManyWithWhereWithoutUserInput {
  Input$ClassroomUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ClassroomScalarWhereInput where;

  final Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ClassroomScalarWhereInput? where,
          Input$ClassroomUncheckedUpdateManyWithoutClassroomsInput? data}) =>
      Input$ClassroomUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateOneWithoutStudentsInput {
  Input$ClassroomUpdateOneWithoutStudentsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.disconnect,
      this.delete,
      this.connect,
      this.update});

  @override
  factory Input$ClassroomUpdateOneWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateOneWithoutStudentsInputFromJson(json);

  final Input$ClassroomUncheckedCreateWithoutStudentsInput? create;

  final Input$ClassroomCreateOrConnectWithoutStudentsInput? connectOrCreate;

  final Input$ClassroomUpsertWithoutStudentsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final Input$ClassroomWhereUniqueInput? connect;

  final Input$ClassroomUncheckedUpdateWithoutStudentsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateOneWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      l$create,
      l$connectOrCreate,
      l$upsert,
      l$disconnect,
      l$delete,
      l$connect,
      l$update
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateOneWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != lOther$disconnect) return false;
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != lOther$delete) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ClassroomUpdateOneWithoutStudentsInput copyWith(
          {Input$ClassroomUncheckedCreateWithoutStudentsInput? Function()?
              create,
          Input$ClassroomCreateOrConnectWithoutStudentsInput? Function()?
              connectOrCreate,
          Input$ClassroomUpsertWithoutStudentsInput? Function()? upsert,
          bool? Function()? disconnect,
          bool? Function()? delete,
          Input$ClassroomWhereUniqueInput? Function()? connect,
          Input$ClassroomUncheckedUpdateWithoutStudentsInput? Function()?
              update}) =>
      Input$ClassroomUpdateOneWithoutStudentsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateWithoutSchoolInput {
  Input$ClassroomUpdateWithoutSchoolInput(
      {this.id,
      this.name,
      this.user,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$UserUpdateOneRequiredWithoutClassroomsInput? user;

  final Input$ClassroomStudentUpdateManyWithoutClassroomInput? students;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$user, l$students, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$UserUpdateOneRequiredWithoutClassroomsInput? Function()? user,
          Input$ClassroomStudentUpdateManyWithoutClassroomInput? Function()?
              students,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          user: user == null ? this.user : user(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateWithoutStudentsInput {
  Input$ClassroomUpdateWithoutStudentsInput(
      {this.id,
      this.name,
      this.school,
      this.user,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUpdateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateWithoutStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$SchoolUpdateOneWithoutClassroomsInput? school;

  final Input$UserUpdateOneRequiredWithoutClassroomsInput? user;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$school = school;
    final l$user = user;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$school, l$user, l$level, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUpdateWithoutStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$SchoolUpdateOneWithoutClassroomsInput? Function()? school,
          Input$UserUpdateOneRequiredWithoutClassroomsInput? Function()? user,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUpdateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          school: school == null ? this.school : school(),
          user: user == null ? this.user : user(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateWithoutUserInput {
  Input$ClassroomUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.school,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$SchoolUpdateOneWithoutClassroomsInput? school;

  final Input$ClassroomStudentUpdateManyWithoutClassroomInput? students;

  final Input$IntFieldUpdateOperationsInput? level;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$school = school;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$school,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$SchoolUpdateOneWithoutClassroomsInput? Function()? school,
          Input$ClassroomStudentUpdateManyWithoutClassroomInput? Function()?
              students,
          Input$IntFieldUpdateOperationsInput? Function()? level,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ClassroomUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          school: school == null ? this.school : school(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput {
  Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedUpdateWithoutSchoolInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedUpdateWithoutSchoolInput? data}) =>
      Input$ClassroomUpdateWithWhereUniqueWithoutSchoolInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpdateWithWhereUniqueWithoutUserInput {
  Input$ClassroomUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ClassroomUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ClassroomUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedUpdateWithoutUserInput? data}) =>
      Input$ClassroomUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpsertWithoutStudentsInput {
  Input$ClassroomUpsertWithoutStudentsInput(
      {required this.update, required this.create});

  @override
  factory Input$ClassroomUpsertWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpsertWithoutStudentsInputFromJson(json);

  final Input$ClassroomUncheckedUpdateWithoutStudentsInput update;

  final Input$ClassroomUncheckedCreateWithoutStudentsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpsertWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpsertWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomUpsertWithoutStudentsInput copyWith(
          {Input$ClassroomUncheckedUpdateWithoutStudentsInput? update,
          Input$ClassroomUncheckedCreateWithoutStudentsInput? create}) =>
      Input$ClassroomUpsertWithoutStudentsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput {
  Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedUpdateWithoutSchoolInput update;

  final Input$ClassroomUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedUpdateWithoutSchoolInput? update,
          Input$ClassroomUncheckedCreateWithoutSchoolInput? create}) =>
      Input$ClassroomUpsertWithWhereUniqueWithoutSchoolInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomUpsertWithWhereUniqueWithoutUserInput {
  Input$ClassroomUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ClassroomUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ClassroomUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ClassroomWhereUniqueInput where;

  final Input$ClassroomUncheckedUpdateWithoutUserInput update;

  final Input$ClassroomUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ClassroomUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ClassroomWhereUniqueInput? where,
          Input$ClassroomUncheckedUpdateWithoutUserInput? update,
          Input$ClassroomUncheckedCreateWithoutUserInput? create}) =>
      Input$ClassroomUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomWhereInput {
  Input$ClassroomWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.schoolId,
      this.school,
      this.userId,
      this.user,
      this.students,
      this.level,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ClassroomWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomWhereInputFromJson(json);

  final List<Input$ClassroomWhereInput?>? AND;

  final List<Input$ClassroomWhereInput?>? OR;

  final List<Input$ClassroomWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringNullableFilter? schoolId;

  final Input$SchoolWhereInput? school;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$ClassroomStudentListRelationFilter? students;

  final Input$IntFilter? level;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ClassroomWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$schoolId = schoolId;
    final l$school = school;
    final l$userId = userId;
    final l$user = user;
    final l$students = students;
    final l$level = level;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$schoolId,
      l$school,
      l$userId,
      l$user,
      l$students,
      l$level,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    final l$level = level;
    final lOther$level = other.level;
    if (l$level != lOther$level) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ClassroomWhereInput copyWith(
          {List<Input$ClassroomWhereInput?>? Function()? AND,
          List<Input$ClassroomWhereInput?>? Function()? OR,
          List<Input$ClassroomWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringNullableFilter? Function()? schoolId,
          Input$SchoolWhereInput? Function()? school,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$ClassroomStudentListRelationFilter? Function()? students,
          Input$IntFilter? Function()? level,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ClassroomWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          school: school == null ? this.school : school(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          students: students == null ? this.students : students(),
          level: level == null ? this.level : level(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ClassroomWhereUniqueInput {
  Input$ClassroomWhereUniqueInput({this.id});

  @override
  factory Input$ClassroomWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ClassroomWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$ClassroomWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ClassroomWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ClassroomWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ClassroomWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeFieldUpdateOperationsInput {
  Input$DateTimeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$DateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$DateTimeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$DateTimeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$DateTimeFieldUpdateOperationsInput copyWith(
          {String? Function()? $set}) =>
      Input$DateTimeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeFilter {
  Input$DateTimeFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$DateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$DateTimeFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeFilter? not;

  Map<String, dynamic> toJson() => _$Input$DateTimeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$DateTimeFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeFilter? Function()? not}) =>
      Input$DateTimeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeNullableFilter {
  Input$DateTimeNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$DateTimeNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$DateTimeNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$DateTimeNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$DateTimeNullableFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeNullableFilter? Function()? not}) =>
      Input$DateTimeNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeNullableWithAggregatesFilter {
  Input$DateTimeNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$DateTimeNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$DateTimeNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedDateTimeNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedDateTimeNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$DateTimeNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$DateTimeNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedDateTimeNullableFilter? Function()? $_min,
          Input$NestedDateTimeNullableFilter? Function()? $_max}) =>
      Input$DateTimeNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeWithAggregatesFilter {
  Input$DateTimeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$DateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$DateTimeWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedDateTimeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedDateTimeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$DateTimeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$DateTimeWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedDateTimeFilter? Function()? $_min,
          Input$NestedDateTimeFilter? Function()? $_max}) =>
      Input$DateTimeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumClassroomStudentStatusFieldUpdateOperationsInput {
  Input$EnumClassroomStudentStatusFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$EnumClassroomStudentStatusFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumClassroomStudentStatusFieldUpdateOperationsInputFromJson(
          json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? $set;

  Map<String, dynamic> toJson() =>
      _$Input$EnumClassroomStudentStatusFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$EnumClassroomStudentStatusFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$EnumClassroomStudentStatusFieldUpdateOperationsInput copyWith(
          {Enum$ClassroomStudentStatus? Function()? $set}) =>
      Input$EnumClassroomStudentStatusFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumClassroomStudentStatusFilter {
  Input$EnumClassroomStudentStatusFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumClassroomStudentStatusFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumClassroomStudentStatusFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? $in;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? notIn;

  final Input$NestedEnumClassroomStudentStatusFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$EnumClassroomStudentStatusFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumClassroomStudentStatusFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumClassroomStudentStatusFilter copyWith(
          {Enum$ClassroomStudentStatus? Function()? equals,
          List<Enum$ClassroomStudentStatus?>? Function()? $in,
          List<Enum$ClassroomStudentStatus?>? Function()? notIn,
          Input$NestedEnumClassroomStudentStatusFilter? Function()? not}) =>
      Input$EnumClassroomStudentStatusFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumClassroomStudentStatusWithAggregatesFilter {
  Input$EnumClassroomStudentStatusWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumClassroomStudentStatusWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumClassroomStudentStatusWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? $in;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? notIn;

  final Input$NestedEnumClassroomStudentStatusWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumClassroomStudentStatusFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumClassroomStudentStatusFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumClassroomStudentStatusWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumClassroomStudentStatusWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumClassroomStudentStatusWithAggregatesFilter copyWith(
          {Enum$ClassroomStudentStatus? Function()? equals,
          List<Enum$ClassroomStudentStatus?>? Function()? $in,
          List<Enum$ClassroomStudentStatus?>? Function()? notIn,
          Input$NestedEnumClassroomStudentStatusWithAggregatesFilter?
                  Function()?
              not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumClassroomStudentStatusFilter? Function()? $_min,
          Input$NestedEnumClassroomStudentStatusFilter? Function()? $_max}) =>
      Input$EnumClassroomStudentStatusWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumContentTypeFieldUpdateOperationsInput {
  Input$EnumContentTypeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$EnumContentTypeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumContentTypeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType? $set;

  Map<String, dynamic> toJson() =>
      _$Input$EnumContentTypeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumContentTypeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$EnumContentTypeFieldUpdateOperationsInput copyWith(
          {Enum$ContentType? Function()? $set}) =>
      Input$EnumContentTypeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumContentTypeFilter {
  Input$EnumContentTypeFilter({this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumContentTypeFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$EnumContentTypeFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? $in;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? notIn;

  final Input$NestedEnumContentTypeFilter? not;

  Map<String, dynamic> toJson() => _$Input$EnumContentTypeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumContentTypeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumContentTypeFilter copyWith(
          {Enum$ContentType? Function()? equals,
          List<Enum$ContentType?>? Function()? $in,
          List<Enum$ContentType?>? Function()? notIn,
          Input$NestedEnumContentTypeFilter? Function()? not}) =>
      Input$EnumContentTypeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumContentTypeWithAggregatesFilter {
  Input$EnumContentTypeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumContentTypeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumContentTypeWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? $in;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? notIn;

  final Input$NestedEnumContentTypeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumContentTypeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumContentTypeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumContentTypeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumContentTypeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumContentTypeWithAggregatesFilter copyWith(
          {Enum$ContentType? Function()? equals,
          List<Enum$ContentType?>? Function()? $in,
          List<Enum$ContentType?>? Function()? notIn,
          Input$NestedEnumContentTypeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumContentTypeFilter? Function()? $_min,
          Input$NestedEnumContentTypeFilter? Function()? $_max}) =>
      Input$EnumContentTypeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumIdentityFileTypeFieldUpdateOperationsInput {
  Input$EnumIdentityFileTypeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$EnumIdentityFileTypeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumIdentityFileTypeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType? $set;

  Map<String, dynamic> toJson() =>
      _$Input$EnumIdentityFileTypeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumIdentityFileTypeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$EnumIdentityFileTypeFieldUpdateOperationsInput copyWith(
          {Enum$IdentityFileType? Function()? $set}) =>
      Input$EnumIdentityFileTypeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumIdentityFileTypeFilter {
  Input$EnumIdentityFileTypeFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumIdentityFileTypeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumIdentityFileTypeFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? $in;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? notIn;

  final Input$NestedEnumIdentityFileTypeFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$EnumIdentityFileTypeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumIdentityFileTypeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumIdentityFileTypeFilter copyWith(
          {Enum$IdentityFileType? Function()? equals,
          List<Enum$IdentityFileType?>? Function()? $in,
          List<Enum$IdentityFileType?>? Function()? notIn,
          Input$NestedEnumIdentityFileTypeFilter? Function()? not}) =>
      Input$EnumIdentityFileTypeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumIdentityFileTypeWithAggregatesFilter {
  Input$EnumIdentityFileTypeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumIdentityFileTypeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumIdentityFileTypeWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? $in;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? notIn;

  final Input$NestedEnumIdentityFileTypeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumIdentityFileTypeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumIdentityFileTypeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumIdentityFileTypeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumIdentityFileTypeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumIdentityFileTypeWithAggregatesFilter copyWith(
          {Enum$IdentityFileType? Function()? equals,
          List<Enum$IdentityFileType?>? Function()? $in,
          List<Enum$IdentityFileType?>? Function()? notIn,
          Input$NestedEnumIdentityFileTypeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumIdentityFileTypeFilter? Function()? $_min,
          Input$NestedEnumIdentityFileTypeFilter? Function()? $_max}) =>
      Input$EnumIdentityFileTypeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumQuestionTypeFieldUpdateOperationsInput {
  Input$EnumQuestionTypeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$EnumQuestionTypeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumQuestionTypeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType? $set;

  Map<String, dynamic> toJson() =>
      _$Input$EnumQuestionTypeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumQuestionTypeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$EnumQuestionTypeFieldUpdateOperationsInput copyWith(
          {Enum$QuestionType? Function()? $set}) =>
      Input$EnumQuestionTypeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumQuestionTypeFilter {
  Input$EnumQuestionTypeFilter({this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumQuestionTypeFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$EnumQuestionTypeFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? $in;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? notIn;

  final Input$NestedEnumQuestionTypeFilter? not;

  Map<String, dynamic> toJson() => _$Input$EnumQuestionTypeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumQuestionTypeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumQuestionTypeFilter copyWith(
          {Enum$QuestionType? Function()? equals,
          List<Enum$QuestionType?>? Function()? $in,
          List<Enum$QuestionType?>? Function()? notIn,
          Input$NestedEnumQuestionTypeFilter? Function()? not}) =>
      Input$EnumQuestionTypeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumQuestionTypeWithAggregatesFilter {
  Input$EnumQuestionTypeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumQuestionTypeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumQuestionTypeWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? $in;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? notIn;

  final Input$NestedEnumQuestionTypeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumQuestionTypeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumQuestionTypeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumQuestionTypeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumQuestionTypeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumQuestionTypeWithAggregatesFilter copyWith(
          {Enum$QuestionType? Function()? equals,
          List<Enum$QuestionType?>? Function()? $in,
          List<Enum$QuestionType?>? Function()? notIn,
          Input$NestedEnumQuestionTypeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumQuestionTypeFilter? Function()? $_min,
          Input$NestedEnumQuestionTypeFilter? Function()? $_max}) =>
      Input$EnumQuestionTypeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumRolesFieldUpdateOperationsInput {
  Input$EnumRolesFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$EnumRolesFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumRolesFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles? $set;

  Map<String, dynamic> toJson() =>
      _$Input$EnumRolesFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumRolesFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$EnumRolesFieldUpdateOperationsInput copyWith(
          {Enum$Roles? Function()? $set}) =>
      Input$EnumRolesFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumRolesFilter {
  Input$EnumRolesFilter({this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumRolesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$EnumRolesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? $in;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? notIn;

  final Input$NestedEnumRolesFilter? not;

  Map<String, dynamic> toJson() => _$Input$EnumRolesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumRolesFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumRolesFilter copyWith(
          {Enum$Roles? Function()? equals,
          List<Enum$Roles?>? Function()? $in,
          List<Enum$Roles?>? Function()? notIn,
          Input$NestedEnumRolesFilter? Function()? not}) =>
      Input$EnumRolesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumRolesWithAggregatesFilter {
  Input$EnumRolesWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumRolesWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumRolesWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? $in;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? notIn;

  final Input$NestedEnumRolesWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumRolesFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumRolesFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumRolesWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumRolesWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumRolesWithAggregatesFilter copyWith(
          {Enum$Roles? Function()? equals,
          List<Enum$Roles?>? Function()? $in,
          List<Enum$Roles?>? Function()? notIn,
          Input$NestedEnumRolesWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumRolesFilter? Function()? $_min,
          Input$NestedEnumRolesFilter? Function()? $_max}) =>
      Input$EnumRolesWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumSchoolStaffRolesNullableListFilter {
  Input$EnumSchoolStaffRolesNullableListFilter(
      {this.equals, this.has, this.hasEvery, this.hasSome, this.isEmpty});

  @override
  factory Input$EnumSchoolStaffRolesNullableListFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumSchoolStaffRolesNullableListFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? equals;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final Enum$SchoolStaffRoles? has;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? hasEvery;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? hasSome;

  final bool? isEmpty;

  Map<String, dynamic> toJson() =>
      _$Input$EnumSchoolStaffRolesNullableListFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$has = has;
    final l$hasEvery = hasEvery;
    final l$hasSome = hasSome;
    final l$isEmpty = isEmpty;
    return Object.hashAll([
      l$equals == null ? null : Object.hashAll(l$equals.map((v) => v)),
      l$has,
      l$hasEvery == null ? null : Object.hashAll(l$hasEvery.map((v) => v)),
      l$hasSome == null ? null : Object.hashAll(l$hasSome.map((v) => v)),
      l$isEmpty
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumSchoolStaffRolesNullableListFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != null && lOther$equals != null) {
      if (l$equals.length != lOther$equals.length) return false;
      for (int i = 0; i < l$equals.length; i++) {
        final l$equals$entry = l$equals[i];
        final lOther$equals$entry = lOther$equals[i];
        if (l$equals$entry != lOther$equals$entry) return false;
      }
    } else if (l$equals != lOther$equals) {
      return false;
    }

    final l$has = has;
    final lOther$has = other.has;
    if (l$has != lOther$has) return false;
    final l$hasEvery = hasEvery;
    final lOther$hasEvery = other.hasEvery;
    if (l$hasEvery != null && lOther$hasEvery != null) {
      if (l$hasEvery.length != lOther$hasEvery.length) return false;
      for (int i = 0; i < l$hasEvery.length; i++) {
        final l$hasEvery$entry = l$hasEvery[i];
        final lOther$hasEvery$entry = lOther$hasEvery[i];
        if (l$hasEvery$entry != lOther$hasEvery$entry) return false;
      }
    } else if (l$hasEvery != lOther$hasEvery) {
      return false;
    }

    final l$hasSome = hasSome;
    final lOther$hasSome = other.hasSome;
    if (l$hasSome != null && lOther$hasSome != null) {
      if (l$hasSome.length != lOther$hasSome.length) return false;
      for (int i = 0; i < l$hasSome.length; i++) {
        final l$hasSome$entry = l$hasSome[i];
        final lOther$hasSome$entry = lOther$hasSome[i];
        if (l$hasSome$entry != lOther$hasSome$entry) return false;
      }
    } else if (l$hasSome != lOther$hasSome) {
      return false;
    }

    final l$isEmpty = isEmpty;
    final lOther$isEmpty = other.isEmpty;
    if (l$isEmpty != lOther$isEmpty) return false;
    return true;
  }

  Input$EnumSchoolStaffRolesNullableListFilter copyWith(
          {List<Enum$SchoolStaffRoles?>? Function()? equals,
          Enum$SchoolStaffRoles? Function()? has,
          List<Enum$SchoolStaffRoles?>? Function()? hasEvery,
          List<Enum$SchoolStaffRoles?>? Function()? hasSome,
          bool? Function()? isEmpty}) =>
      Input$EnumSchoolStaffRolesNullableListFilter(
          equals: equals == null ? this.equals : equals(),
          has: has == null ? this.has : has(),
          hasEvery: hasEvery == null ? this.hasEvery : hasEvery(),
          hasSome: hasSome == null ? this.hasSome : hasSome(),
          isEmpty: isEmpty == null ? this.isEmpty : isEmpty());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumVerifyTypeNullableFilter {
  Input$EnumVerifyTypeNullableFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumVerifyTypeNullableFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumVerifyTypeNullableFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? $in;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? notIn;

  final Input$NestedEnumVerifyTypeNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$EnumVerifyTypeNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumVerifyTypeNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumVerifyTypeNullableFilter copyWith(
          {Enum$VerifyType? Function()? equals,
          List<Enum$VerifyType?>? Function()? $in,
          List<Enum$VerifyType?>? Function()? notIn,
          Input$NestedEnumVerifyTypeNullableFilter? Function()? not}) =>
      Input$EnumVerifyTypeNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumVerifyTypeNullableWithAggregatesFilter {
  Input$EnumVerifyTypeNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumVerifyTypeNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumVerifyTypeNullableWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? $in;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? notIn;

  final Input$NestedEnumVerifyTypeNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumVerifyTypeNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumVerifyTypeNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumVerifyTypeNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumVerifyTypeNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumVerifyTypeNullableWithAggregatesFilter copyWith(
          {Enum$VerifyType? Function()? equals,
          List<Enum$VerifyType?>? Function()? $in,
          List<Enum$VerifyType?>? Function()? notIn,
          Input$NestedEnumVerifyTypeNullableWithAggregatesFilter? Function()?
              not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedEnumVerifyTypeNullableFilter? Function()? $_min,
          Input$NestedEnumVerifyTypeNullableFilter? Function()? $_max}) =>
      Input$EnumVerifyTypeNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerAvgOrderByAggregateInput {
  Input$ExamAnswerAvgOrderByAggregateInput({this.grade});

  @override
  factory Input$ExamAnswerAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$grade = grade;
    return Object.hashAll([l$grade]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    return true;
  }

  Input$ExamAnswerAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? grade}) =>
      Input$ExamAnswerAvgOrderByAggregateInput(
          grade: grade == null ? this.grade : grade());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCountOrderByAggregateInput {
  Input$ExamAnswerCountOrderByAggregateInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? finishCalculation;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examSessionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? grade,
          Enum$SortOrder? Function()? finishCalculation,
          Enum$SortOrder? Function()? examSessionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamAnswerCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateInput {
  Input$ExamAnswerCreateInput(
      {this.id,
      required this.exam,
      this.grade,
      this.finishCalculation,
      this.examSession,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateInputFromJson(json);

  final String? id;

  final Input$ExamCreateNestedOneWithoutExamAnswersInput exam;

  final double? grade;

  final bool? finishCalculation;

  final Input$ExamSessionCreateNestedOneWithoutExamAnswersInput? examSession;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamAnswerCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$exam = exam;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSession = examSession;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$exam,
      l$grade,
      l$finishCalculation,
      l$examSession,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSession = examSession;
    final lOther$examSession = other.examSession;
    if (l$examSession != lOther$examSession) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCreateInput copyWith(
          {String? Function()? id,
          Input$ExamCreateNestedOneWithoutExamAnswersInput? exam,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          Input$ExamSessionCreateNestedOneWithoutExamAnswersInput? Function()?
              examSession,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerCreateInput(
          id: id == null ? this.id : id(),
          exam: exam == null ? this.exam : exam,
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSession: examSession == null ? this.examSession : examSession(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateManyExamInput {
  Input$ExamAnswerCreateManyExamInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCreateManyExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateManyExamInputFromJson(json);

  final String? id;

  final double? grade;

  final bool? finishCalculation;

  final String? examSessionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateManyExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateManyExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCreateManyExamInput copyWith(
          {String? Function()? id,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? examSessionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerCreateManyExamInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateManyExamInputEnvelope {
  Input$ExamAnswerCreateManyExamInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ExamAnswerCreateManyExamInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateManyExamInputEnvelopeFromJson(json);

  final Input$ExamAnswerCreateManyExamInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateManyExamInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateManyExamInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ExamAnswerCreateManyExamInputEnvelope copyWith(
          {Input$ExamAnswerCreateManyExamInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ExamAnswerCreateManyExamInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateManyExamSessionInput {
  Input$ExamAnswerCreateManyExamSessionInput(
      {this.id,
      required this.examId,
      this.grade,
      this.finishCalculation,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCreateManyExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateManyExamSessionInputFromJson(json);

  final String? id;

  final String examId;

  final double? grade;

  final bool? finishCalculation;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateManyExamSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateManyExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCreateManyExamSessionInput copyWith(
          {String? Function()? id,
          String? examId,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerCreateManyExamSessionInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId,
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateManyExamSessionInputEnvelope {
  Input$ExamAnswerCreateManyExamSessionInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ExamAnswerCreateManyExamSessionInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateManyExamSessionInputEnvelopeFromJson(json);

  final Input$ExamAnswerCreateManyExamSessionInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateManyExamSessionInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateManyExamSessionInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ExamAnswerCreateManyExamSessionInputEnvelope copyWith(
          {Input$ExamAnswerCreateManyExamSessionInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ExamAnswerCreateManyExamSessionInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateManyInput {
  Input$ExamAnswerCreateManyInput(
      {this.id,
      required this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateManyInputFromJson(json);

  final String? id;

  final String examId;

  final double? grade;

  final bool? finishCalculation;

  final String? examSessionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCreateManyInput copyWith(
          {String? Function()? id,
          String? examId,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? examSessionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerCreateManyInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId,
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateNestedManyWithoutExamInput {
  Input$ExamAnswerCreateNestedManyWithoutExamInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamAnswerCreateNestedManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateNestedManyWithoutExamInputFromJson(json);

  final List<Input$ExamAnswerCreateWithoutExamInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? connectOrCreate;

  final Input$ExamAnswerCreateManyExamInputEnvelope? createMany;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateNestedManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateNestedManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerCreateNestedManyWithoutExamInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          Input$ExamAnswerCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamAnswerCreateNestedManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateNestedManyWithoutExamSessionInput {
  Input$ExamAnswerCreateNestedManyWithoutExamSessionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamAnswerCreateNestedManyWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateNestedManyWithoutExamSessionInputFromJson(json);

  final List<Input$ExamAnswerCreateWithoutExamSessionInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
      connectOrCreate;

  final Input$ExamAnswerCreateManyExamSessionInputEnvelope? createMany;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateNestedManyWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateNestedManyWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerCreateNestedManyWithoutExamSessionInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamSessionInput?>? Function()?
              create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
                  Function()?
              connectOrCreate,
          Input$ExamAnswerCreateManyExamSessionInputEnvelope? Function()?
              createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamAnswerCreateNestedManyWithoutExamSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateOrConnectWithoutExamInput {
  Input$ExamAnswerCreateOrConnectWithoutExamInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamAnswerCreateOrConnectWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateOrConnectWithoutExamInputFromJson(json);

  final Input$ExamAnswerWhereUniqueInput where;

  final Input$ExamAnswerUncheckedCreateWithoutExamInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateOrConnectWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateOrConnectWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamAnswerCreateOrConnectWithoutExamInput copyWith(
          {Input$ExamAnswerWhereUniqueInput? where,
          Input$ExamAnswerUncheckedCreateWithoutExamInput? create}) =>
      Input$ExamAnswerCreateOrConnectWithoutExamInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateOrConnectWithoutExamSessionInput {
  Input$ExamAnswerCreateOrConnectWithoutExamSessionInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamAnswerCreateOrConnectWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateOrConnectWithoutExamSessionInputFromJson(json);

  final Input$ExamAnswerWhereUniqueInput where;

  final Input$ExamAnswerUncheckedCreateWithoutExamSessionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateOrConnectWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateOrConnectWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamAnswerCreateOrConnectWithoutExamSessionInput copyWith(
          {Input$ExamAnswerWhereUniqueInput? where,
          Input$ExamAnswerUncheckedCreateWithoutExamSessionInput? create}) =>
      Input$ExamAnswerCreateOrConnectWithoutExamSessionInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateWithoutExamInput {
  Input$ExamAnswerCreateWithoutExamInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.examSession,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCreateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateWithoutExamInputFromJson(json);

  final String? id;

  final double? grade;

  final bool? finishCalculation;

  final Input$ExamSessionCreateNestedOneWithoutExamAnswersInput? examSession;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSession = examSession;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$grade,
      l$finishCalculation,
      l$examSession,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSession = examSession;
    final lOther$examSession = other.examSession;
    if (l$examSession != lOther$examSession) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCreateWithoutExamInput copyWith(
          {String? Function()? id,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          Input$ExamSessionCreateNestedOneWithoutExamAnswersInput? Function()?
              examSession,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerCreateWithoutExamInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSession: examSession == null ? this.examSession : examSession(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerCreateWithoutExamSessionInput {
  Input$ExamAnswerCreateWithoutExamSessionInput(
      {this.id,
      required this.exam,
      this.grade,
      this.finishCalculation,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerCreateWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerCreateWithoutExamSessionInputFromJson(json);

  final String? id;

  final Input$ExamCreateNestedOneWithoutExamAnswersInput exam;

  final double? grade;

  final bool? finishCalculation;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerCreateWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$exam = exam;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$exam, l$grade, l$finishCalculation, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerCreateWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerCreateWithoutExamSessionInput copyWith(
          {String? Function()? id,
          Input$ExamCreateNestedOneWithoutExamAnswersInput? exam,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerCreateWithoutExamSessionInput(
          id: id == null ? this.id : id(),
          exam: exam == null ? this.exam : exam,
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerListRelationFilter {
  Input$ExamAnswerListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ExamAnswerListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerListRelationFilterFromJson(json);

  final Input$ExamAnswerWhereInput? every;

  final Input$ExamAnswerWhereInput? some;

  final Input$ExamAnswerWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ExamAnswerListRelationFilter copyWith(
          {Input$ExamAnswerWhereInput? Function()? every,
          Input$ExamAnswerWhereInput? Function()? some,
          Input$ExamAnswerWhereInput? Function()? none}) =>
      Input$ExamAnswerListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerMaxOrderByAggregateInput {
  Input$ExamAnswerMaxOrderByAggregateInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? finishCalculation;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examSessionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? grade,
          Enum$SortOrder? Function()? finishCalculation,
          Enum$SortOrder? Function()? examSessionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamAnswerMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerMinOrderByAggregateInput {
  Input$ExamAnswerMinOrderByAggregateInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? finishCalculation;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examSessionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? grade,
          Enum$SortOrder? Function()? finishCalculation,
          Enum$SortOrder? Function()? examSessionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamAnswerMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerOrderByRelationAggregateInput {
  Input$ExamAnswerOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ExamAnswerOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ExamAnswerOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ExamAnswerOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerOrderByWithAggregationInput {
  Input$ExamAnswerOrderByWithAggregationInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ExamAnswerOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? finishCalculation;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examSessionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ExamAnswerCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ExamAnswerAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ExamAnswerMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ExamAnswerMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ExamAnswerSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ExamAnswerOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? grade,
          Enum$SortOrder? Function()? finishCalculation,
          Enum$SortOrder? Function()? examSessionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ExamAnswerCountOrderByAggregateInput? Function()? $_count,
          Input$ExamAnswerAvgOrderByAggregateInput? Function()? $_avg,
          Input$ExamAnswerMaxOrderByAggregateInput? Function()? $_max,
          Input$ExamAnswerMinOrderByAggregateInput? Function()? $_min,
          Input$ExamAnswerSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ExamAnswerOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerOrderByWithRelationInput {
  Input$ExamAnswerOrderByWithRelationInput(
      {this.id,
      this.examId,
      this.exam,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.examSession,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  final Input$ExamOrderByWithRelationInput? exam;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? finishCalculation;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examSessionId;

  final Input$ExamSessionOrderByWithRelationInput? examSession;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$exam = exam;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$examSession = examSession;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$exam,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$examSession,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$examSession = examSession;
    final lOther$examSession = other.examSession;
    if (l$examSession != lOther$examSession) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? examId,
          Input$ExamOrderByWithRelationInput? Function()? exam,
          Enum$SortOrder? Function()? grade,
          Enum$SortOrder? Function()? finishCalculation,
          Enum$SortOrder? Function()? examSessionId,
          Input$ExamSessionOrderByWithRelationInput? Function()? examSession,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamAnswerOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          exam: exam == null ? this.exam : exam(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          examSession: examSession == null ? this.examSession : examSession(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerScalarWhereInput {
  Input$ExamAnswerScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerScalarWhereInputFromJson(json);

  final List<Input$ExamAnswerScalarWhereInput?>? AND;

  final List<Input$ExamAnswerScalarWhereInput?>? OR;

  final List<Input$ExamAnswerScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? examId;

  final Input$FloatFilter? grade;

  final Input$BoolFilter? finishCalculation;

  final Input$StringNullableFilter? examSessionId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerScalarWhereInput copyWith(
          {List<Input$ExamAnswerScalarWhereInput?>? Function()? AND,
          List<Input$ExamAnswerScalarWhereInput?>? Function()? OR,
          List<Input$ExamAnswerScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? examId,
          Input$FloatFilter? Function()? grade,
          Input$BoolFilter? Function()? finishCalculation,
          Input$StringNullableFilter? Function()? examSessionId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ExamAnswerScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerScalarWhereWithAggregatesInput {
  Input$ExamAnswerScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ExamAnswerScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ExamAnswerScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ExamAnswerScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? examId;

  final Input$FloatWithAggregatesFilter? grade;

  final Input$BoolWithAggregatesFilter? finishCalculation;

  final Input$StringNullableWithAggregatesFilter? examSessionId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerScalarWhereWithAggregatesInput copyWith(
          {List<Input$ExamAnswerScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ExamAnswerScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ExamAnswerScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? examId,
          Input$FloatWithAggregatesFilter? Function()? grade,
          Input$BoolWithAggregatesFilter? Function()? finishCalculation,
          Input$StringNullableWithAggregatesFilter? Function()? examSessionId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ExamAnswerScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerSumOrderByAggregateInput {
  Input$ExamAnswerSumOrderByAggregateInput({this.grade});

  @override
  factory Input$ExamAnswerSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? grade;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$grade = grade;
    return Object.hashAll([l$grade]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    return true;
  }

  Input$ExamAnswerSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? grade}) =>
      Input$ExamAnswerSumOrderByAggregateInput(
          grade: grade == null ? this.grade : grade());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedCreateInput {
  Input$ExamAnswerUncheckedCreateInput(
      {this.id,
      required this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedCreateInputFromJson(json);

  final String? id;

  final String examId;

  final double? grade;

  final bool? finishCalculation;

  final String? examSessionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? examId,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? examSessionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedCreateInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId,
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput {
  Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInputFromJson(json);

  final List<Input$ExamAnswerCreateWithoutExamInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? connectOrCreate;

  final Input$ExamAnswerCreateManyExamInputEnvelope? createMany;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          Input$ExamAnswerCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput {
  Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInputFromJson(
          json);

  final List<Input$ExamAnswerCreateWithoutExamSessionInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
      connectOrCreate;

  final Input$ExamAnswerCreateManyExamSessionInputEnvelope? createMany;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamSessionInput?>? Function()?
              create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
                  Function()?
              connectOrCreate,
          Input$ExamAnswerCreateManyExamSessionInputEnvelope? Function()?
              createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedCreateWithoutExamInput {
  Input$ExamAnswerUncheckedCreateWithoutExamInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedCreateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedCreateWithoutExamInputFromJson(json);

  final String? id;

  final double? grade;

  final bool? finishCalculation;

  final String? examSessionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedCreateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedCreateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedCreateWithoutExamInput copyWith(
          {String? Function()? id,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? examSessionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedCreateWithoutExamInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedCreateWithoutExamSessionInput {
  Input$ExamAnswerUncheckedCreateWithoutExamSessionInput(
      {this.id,
      required this.examId,
      this.grade,
      this.finishCalculation,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedCreateWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedCreateWithoutExamSessionInputFromJson(json);

  final String? id;

  final String examId;

  final double? grade;

  final bool? finishCalculation;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedCreateWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedCreateWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedCreateWithoutExamSessionInput copyWith(
          {String? Function()? id,
          String? examId,
          double? Function()? grade,
          bool? Function()? finishCalculation,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedCreateWithoutExamSessionInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId,
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateInput {
  Input$ExamAnswerUncheckedUpdateInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? examId;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$NullableStringFieldUpdateOperationsInput? examSessionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? examId,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              examSessionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateManyInput {
  Input$ExamAnswerUncheckedUpdateManyInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? examId;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$NullableStringFieldUpdateOperationsInput? examSessionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? examId,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              examSessionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput {
  Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$NullableStringFieldUpdateOperationsInput? examSessionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              examSessionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateManyWithoutExamInput {
  Input$ExamAnswerUncheckedUpdateManyWithoutExamInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamAnswerUncheckedUpdateManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateManyWithoutExamInputFromJson(json);

  final List<Input$ExamAnswerCreateWithoutExamInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? connectOrCreate;

  final List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput?>? upsert;

  final Input$ExamAnswerCreateManyExamInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamAnswerWhereUniqueInput?>? $set;

  final List<Input$ExamAnswerWhereUniqueInput?>? disconnect;

  final List<Input$ExamAnswerWhereUniqueInput?>? delete;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  final List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput?>? update;

  final List<Input$ExamAnswerUpdateManyWithWhereWithoutExamInput?>? updateMany;

  final List<Input$ExamAnswerScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedUpdateManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerUncheckedUpdateManyWithoutExamInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput?>?
                  Function()?
              upsert,
          Input$ExamAnswerCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? $set,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? delete,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect,
          List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput?>?
                  Function()?
              update,
          List<Input$ExamAnswerUpdateManyWithWhereWithoutExamInput?>?
                  Function()?
              updateMany,
          List<Input$ExamAnswerScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamAnswerUncheckedUpdateManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput {
  Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInputFromJson(
          json);

  final List<Input$ExamAnswerCreateWithoutExamSessionInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
      connectOrCreate;

  final List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput?>?
      upsert;

  final Input$ExamAnswerCreateManyExamSessionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamAnswerWhereUniqueInput?>? $set;

  final List<Input$ExamAnswerWhereUniqueInput?>? disconnect;

  final List<Input$ExamAnswerWhereUniqueInput?>? delete;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  final List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput?>?
      update;

  final List<Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput?>?
      updateMany;

  final List<Input$ExamAnswerScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamSessionInput?>? Function()?
              create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput?>?
                  Function()?
              upsert,
          Input$ExamAnswerCreateManyExamSessionInputEnvelope? Function()?
              createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? $set,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? delete,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect,
          List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput?>?
                  Function()?
              update,
          List<Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput?>?
                  Function()?
              updateMany,
          List<Input$ExamAnswerScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateWithoutExamInput {
  Input$ExamAnswerUncheckedUpdateWithoutExamInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedUpdateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateWithoutExamInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$NullableStringFieldUpdateOperationsInput? examSessionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedUpdateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedUpdateWithoutExamInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              examSessionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedUpdateWithoutExamInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput {
  Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput(
      {this.id,
      this.examId,
      this.grade,
      this.finishCalculation,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUncheckedUpdateWithoutExamSessionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? examId;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUncheckedUpdateWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$examId,
      l$grade,
      l$finishCalculation,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? examId,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateInput {
  Input$ExamAnswerUpdateInput(
      {this.id,
      this.exam,
      this.grade,
      this.finishCalculation,
      this.examSession,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$ExamUpdateOneRequiredWithoutExamAnswersInput? exam;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$ExamSessionUpdateOneWithoutExamAnswersInput? examSession;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamAnswerUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$exam = exam;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSession = examSession;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$exam,
      l$grade,
      l$finishCalculation,
      l$examSession,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSession = examSession;
    final lOther$examSession = other.examSession;
    if (l$examSession != lOther$examSession) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$ExamUpdateOneRequiredWithoutExamAnswersInput? Function()? exam,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$ExamSessionUpdateOneWithoutExamAnswersInput? Function()?
              examSession,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUpdateInput(
          id: id == null ? this.id : id(),
          exam: exam == null ? this.exam : exam(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSession: examSession == null ? this.examSession : examSession(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateManyMutationInput {
  Input$ExamAnswerUpdateManyMutationInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$grade, l$finishCalculation, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateManyWithoutExamInput {
  Input$ExamAnswerUpdateManyWithoutExamInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamAnswerUpdateManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateManyWithoutExamInputFromJson(json);

  final List<Input$ExamAnswerCreateWithoutExamInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? connectOrCreate;

  final List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput?>? upsert;

  final Input$ExamAnswerCreateManyExamInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamAnswerWhereUniqueInput?>? $set;

  final List<Input$ExamAnswerWhereUniqueInput?>? disconnect;

  final List<Input$ExamAnswerWhereUniqueInput?>? delete;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  final List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput?>? update;

  final List<Input$ExamAnswerUpdateManyWithWhereWithoutExamInput?>? updateMany;

  final List<Input$ExamAnswerScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerUpdateManyWithoutExamInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput?>?
                  Function()?
              upsert,
          Input$ExamAnswerCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? $set,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? delete,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect,
          List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput?>?
                  Function()?
              update,
          List<Input$ExamAnswerUpdateManyWithWhereWithoutExamInput?>?
                  Function()?
              updateMany,
          List<Input$ExamAnswerScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamAnswerUpdateManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateManyWithoutExamSessionInput {
  Input$ExamAnswerUpdateManyWithoutExamSessionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamAnswerUpdateManyWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateManyWithoutExamSessionInputFromJson(json);

  final List<Input$ExamAnswerCreateWithoutExamSessionInput?>? create;

  final List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
      connectOrCreate;

  final List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput?>?
      upsert;

  final Input$ExamAnswerCreateManyExamSessionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamAnswerWhereUniqueInput?>? $set;

  final List<Input$ExamAnswerWhereUniqueInput?>? disconnect;

  final List<Input$ExamAnswerWhereUniqueInput?>? delete;

  final List<Input$ExamAnswerWhereUniqueInput?>? connect;

  final List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput?>?
      update;

  final List<Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput?>?
      updateMany;

  final List<Input$ExamAnswerScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateManyWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateManyWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamAnswerUpdateManyWithoutExamSessionInput copyWith(
          {List<Input$ExamAnswerCreateWithoutExamSessionInput?>? Function()?
              create,
          List<Input$ExamAnswerCreateOrConnectWithoutExamSessionInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput?>?
                  Function()?
              upsert,
          Input$ExamAnswerCreateManyExamSessionInputEnvelope? Function()?
              createMany,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? $set,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? delete,
          List<Input$ExamAnswerWhereUniqueInput?>? Function()? connect,
          List<Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput?>?
                  Function()?
              update,
          List<Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput?>?
                  Function()?
              updateMany,
          List<Input$ExamAnswerScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamAnswerUpdateManyWithoutExamSessionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateManyWithWhereWithoutExamInput {
  Input$ExamAnswerUpdateManyWithWhereWithoutExamInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamAnswerUpdateManyWithWhereWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateManyWithWhereWithoutExamInputFromJson(json);

  final Input$ExamAnswerScalarWhereInput where;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateManyWithWhereWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateManyWithWhereWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamAnswerUpdateManyWithWhereWithoutExamInput copyWith(
          {Input$ExamAnswerScalarWhereInput? where,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput? data}) =>
      Input$ExamAnswerUpdateManyWithWhereWithoutExamInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput {
  Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInputFromJson(
          json);

  final Input$ExamAnswerScalarWhereInput where;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput copyWith(
          {Input$ExamAnswerScalarWhereInput? where,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamAnswersInput? data}) =>
      Input$ExamAnswerUpdateManyWithWhereWithoutExamSessionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateWithoutExamInput {
  Input$ExamAnswerUpdateWithoutExamInput(
      {this.id,
      this.grade,
      this.finishCalculation,
      this.examSession,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUpdateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateWithoutExamInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$ExamSessionUpdateOneWithoutExamAnswersInput? examSession;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSession = examSession;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$grade,
      l$finishCalculation,
      l$examSession,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSession = examSession;
    final lOther$examSession = other.examSession;
    if (l$examSession != lOther$examSession) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUpdateWithoutExamInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$ExamSessionUpdateOneWithoutExamAnswersInput? Function()?
              examSession,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUpdateWithoutExamInput(
          id: id == null ? this.id : id(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSession: examSession == null ? this.examSession : examSession(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateWithoutExamSessionInput {
  Input$ExamAnswerUpdateWithoutExamSessionInput(
      {this.id,
      this.exam,
      this.grade,
      this.finishCalculation,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerUpdateWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateWithoutExamSessionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$ExamUpdateOneRequiredWithoutExamAnswersInput? exam;

  final Input$FloatFieldUpdateOperationsInput? grade;

  final Input$BoolFieldUpdateOperationsInput? finishCalculation;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateWithoutExamSessionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$exam = exam;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$exam, l$grade, l$finishCalculation, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerUpdateWithoutExamSessionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$ExamUpdateOneRequiredWithoutExamAnswersInput? Function()? exam,
          Input$FloatFieldUpdateOperationsInput? Function()? grade,
          Input$BoolFieldUpdateOperationsInput? Function()? finishCalculation,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamAnswerUpdateWithoutExamSessionInput(
          id: id == null ? this.id : id(),
          exam: exam == null ? this.exam : exam(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput {
  Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInputFromJson(json);

  final Input$ExamAnswerWhereUniqueInput where;

  final Input$ExamAnswerUncheckedUpdateWithoutExamInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput copyWith(
          {Input$ExamAnswerWhereUniqueInput? where,
          Input$ExamAnswerUncheckedUpdateWithoutExamInput? data}) =>
      Input$ExamAnswerUpdateWithWhereUniqueWithoutExamInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput {
  Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInputFromJson(
          json);

  final Input$ExamAnswerWhereUniqueInput where;

  final Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput copyWith(
          {Input$ExamAnswerWhereUniqueInput? where,
          Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput? data}) =>
      Input$ExamAnswerUpdateWithWhereUniqueWithoutExamSessionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput {
  Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInputFromJson(json);

  final Input$ExamAnswerWhereUniqueInput where;

  final Input$ExamAnswerUncheckedUpdateWithoutExamInput update;

  final Input$ExamAnswerUncheckedCreateWithoutExamInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput copyWith(
          {Input$ExamAnswerWhereUniqueInput? where,
          Input$ExamAnswerUncheckedUpdateWithoutExamInput? update,
          Input$ExamAnswerUncheckedCreateWithoutExamInput? create}) =>
      Input$ExamAnswerUpsertWithWhereUniqueWithoutExamInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput {
  Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInputFromJson(
          json);

  final Input$ExamAnswerWhereUniqueInput where;

  final Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput update;

  final Input$ExamAnswerUncheckedCreateWithoutExamSessionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput copyWith(
          {Input$ExamAnswerWhereUniqueInput? where,
          Input$ExamAnswerUncheckedUpdateWithoutExamSessionInput? update,
          Input$ExamAnswerUncheckedCreateWithoutExamSessionInput? create}) =>
      Input$ExamAnswerUpsertWithWhereUniqueWithoutExamSessionInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerWhereInput {
  Input$ExamAnswerWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.examId,
      this.exam,
      this.grade,
      this.finishCalculation,
      this.examSessionId,
      this.examSession,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamAnswerWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamAnswerWhereInputFromJson(json);

  final List<Input$ExamAnswerWhereInput?>? AND;

  final List<Input$ExamAnswerWhereInput?>? OR;

  final List<Input$ExamAnswerWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? examId;

  final Input$ExamWhereInput? exam;

  final Input$FloatFilter? grade;

  final Input$BoolFilter? finishCalculation;

  final Input$StringNullableFilter? examSessionId;

  final Input$ExamSessionWhereInput? examSession;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamAnswerWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$examId = examId;
    final l$exam = exam;
    final l$grade = grade;
    final l$finishCalculation = finishCalculation;
    final l$examSessionId = examSessionId;
    final l$examSession = examSession;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$examId,
      l$exam,
      l$grade,
      l$finishCalculation,
      l$examSessionId,
      l$examSession,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$grade = grade;
    final lOther$grade = other.grade;
    if (l$grade != lOther$grade) return false;
    final l$finishCalculation = finishCalculation;
    final lOther$finishCalculation = other.finishCalculation;
    if (l$finishCalculation != lOther$finishCalculation) return false;
    final l$examSessionId = examSessionId;
    final lOther$examSessionId = other.examSessionId;
    if (l$examSessionId != lOther$examSessionId) return false;
    final l$examSession = examSession;
    final lOther$examSession = other.examSession;
    if (l$examSession != lOther$examSession) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamAnswerWhereInput copyWith(
          {List<Input$ExamAnswerWhereInput?>? Function()? AND,
          List<Input$ExamAnswerWhereInput?>? Function()? OR,
          List<Input$ExamAnswerWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? examId,
          Input$ExamWhereInput? Function()? exam,
          Input$FloatFilter? Function()? grade,
          Input$BoolFilter? Function()? finishCalculation,
          Input$StringNullableFilter? Function()? examSessionId,
          Input$ExamSessionWhereInput? Function()? examSession,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ExamAnswerWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          exam: exam == null ? this.exam : exam(),
          grade: grade == null ? this.grade : grade(),
          finishCalculation: finishCalculation == null
              ? this.finishCalculation
              : finishCalculation(),
          examSessionId:
              examSessionId == null ? this.examSessionId : examSessionId(),
          examSession: examSession == null ? this.examSession : examSession(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamAnswerWhereUniqueInput {
  Input$ExamAnswerWhereUniqueInput({this.id});

  @override
  factory Input$ExamAnswerWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamAnswerWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$ExamAnswerWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamAnswerWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ExamAnswerWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ExamAnswerWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCountOrderByAggregateInput {
  Input$ExamCountOrderByAggregateInput(
      {this.id, this.name, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateInput {
  Input$ExamCreateInput(
      {this.id,
      required this.name,
      required this.user,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamCreateInputFromJson(json);

  final String? id;

  final String name;

  final Input$UserCreateNestedOneWithoutExaminationsInput user;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutExamInput? examquestions;

  final Input$ExamAnswerCreateNestedManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$user,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Input$UserCreateNestedOneWithoutExaminationsInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutExamInput? Function()?
              examquestions,
          Input$ExamAnswerCreateNestedManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateManyInput {
  Input$ExamCreateManyInput(
      {this.id,
      required this.name,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateManyUserInput {
  Input$ExamCreateManyUserInput(
      {this.id, required this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamCreateManyUserInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamCreateManyUserInputFromJson(json);

  final String? id;

  final String name;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamCreateManyUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamCreateManyUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateManyUserInputEnvelope {
  Input$ExamCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ExamCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateManyUserInputEnvelopeFromJson(json);

  final Input$ExamCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ExamCreateManyUserInputEnvelope copyWith(
          {Input$ExamCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ExamCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateNestedManyWithoutUserInput {
  Input$ExamCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ExamCreateWithoutUserInput?>? create;

  final List<Input$ExamCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ExamCreateManyUserInputEnvelope? createMany;

  final List<Input$ExamWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ExamCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ExamCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateNestedOneWithoutExamAnswersInput {
  Input$ExamCreateNestedOneWithoutExamAnswersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ExamCreateNestedOneWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateNestedOneWithoutExamAnswersInputFromJson(json);

  final Input$ExamUncheckedCreateWithoutExamAnswersInput? create;

  final Input$ExamCreateOrConnectWithoutExamAnswersInput? connectOrCreate;

  final Input$ExamWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateNestedOneWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateNestedOneWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ExamCreateNestedOneWithoutExamAnswersInput copyWith(
          {Input$ExamUncheckedCreateWithoutExamAnswersInput? Function()? create,
          Input$ExamCreateOrConnectWithoutExamAnswersInput? Function()?
              connectOrCreate,
          Input$ExamWhereUniqueInput? Function()? connect}) =>
      Input$ExamCreateNestedOneWithoutExamAnswersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateNestedOneWithoutExamquestionsInput {
  Input$ExamCreateNestedOneWithoutExamquestionsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ExamCreateNestedOneWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateNestedOneWithoutExamquestionsInputFromJson(json);

  final Input$ExamUncheckedCreateWithoutExamquestionsInput? create;

  final Input$ExamCreateOrConnectWithoutExamquestionsInput? connectOrCreate;

  final Input$ExamWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateNestedOneWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateNestedOneWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ExamCreateNestedOneWithoutExamquestionsInput copyWith(
          {Input$ExamUncheckedCreateWithoutExamquestionsInput? Function()?
              create,
          Input$ExamCreateOrConnectWithoutExamquestionsInput? Function()?
              connectOrCreate,
          Input$ExamWhereUniqueInput? Function()? connect}) =>
      Input$ExamCreateNestedOneWithoutExamquestionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateOrConnectWithoutExamAnswersInput {
  Input$ExamCreateOrConnectWithoutExamAnswersInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamCreateOrConnectWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateOrConnectWithoutExamAnswersInputFromJson(json);

  final Input$ExamWhereUniqueInput where;

  final Input$ExamUncheckedCreateWithoutExamAnswersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateOrConnectWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateOrConnectWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamCreateOrConnectWithoutExamAnswersInput copyWith(
          {Input$ExamWhereUniqueInput? where,
          Input$ExamUncheckedCreateWithoutExamAnswersInput? create}) =>
      Input$ExamCreateOrConnectWithoutExamAnswersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateOrConnectWithoutExamquestionsInput {
  Input$ExamCreateOrConnectWithoutExamquestionsInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamCreateOrConnectWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateOrConnectWithoutExamquestionsInputFromJson(json);

  final Input$ExamWhereUniqueInput where;

  final Input$ExamUncheckedCreateWithoutExamquestionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateOrConnectWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateOrConnectWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamCreateOrConnectWithoutExamquestionsInput copyWith(
          {Input$ExamWhereUniqueInput? where,
          Input$ExamUncheckedCreateWithoutExamquestionsInput? create}) =>
      Input$ExamCreateOrConnectWithoutExamquestionsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateOrConnectWithoutUserInput {
  Input$ExamCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ExamWhereUniqueInput where;

  final Input$ExamUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamCreateOrConnectWithoutUserInput copyWith(
          {Input$ExamWhereUniqueInput? where,
          Input$ExamUncheckedCreateWithoutUserInput? create}) =>
      Input$ExamCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateWithoutExamAnswersInput {
  Input$ExamCreateWithoutExamAnswersInput(
      {this.id,
      required this.name,
      required this.user,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$ExamCreateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateWithoutExamAnswersInputFromJson(json);

  final String? id;

  final String name;

  final Input$UserCreateNestedOneWithoutExaminationsInput user;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutExamInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll(
        [l$id, l$name, l$user, l$createdAt, l$updatedAt, l$examquestions]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$ExamCreateWithoutExamAnswersInput copyWith(
          {String? Function()? id,
          String? name,
          Input$UserCreateNestedOneWithoutExaminationsInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutExamInput? Function()?
              examquestions}) =>
      Input$ExamCreateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateWithoutExamquestionsInput {
  Input$ExamCreateWithoutExamquestionsInput(
      {this.id,
      required this.name,
      required this.user,
      this.createdAt,
      this.updatedAt,
      this.examAnswers});

  @override
  factory Input$ExamCreateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateWithoutExamquestionsInputFromJson(json);

  final String? id;

  final String name;

  final Input$UserCreateNestedOneWithoutExaminationsInput user;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamAnswerCreateNestedManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$user, l$createdAt, l$updatedAt, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamCreateWithoutExamquestionsInput copyWith(
          {String? Function()? id,
          String? name,
          Input$UserCreateNestedOneWithoutExaminationsInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamAnswerCreateNestedManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamCreateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamCreateWithoutUserInput {
  Input$ExamCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutExamInput? examquestions;

  final Input$ExamAnswerCreateNestedManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutExamInput? Function()?
              examquestions,
          Input$ExamAnswerCreateNestedManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamListRelationFilter {
  Input$ExamListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ExamListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamListRelationFilterFromJson(json);

  final Input$ExamWhereInput? every;

  final Input$ExamWhereInput? some;

  final Input$ExamWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$ExamListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ExamListRelationFilter copyWith(
          {Input$ExamWhereInput? Function()? every,
          Input$ExamWhereInput? Function()? some,
          Input$ExamWhereInput? Function()? none}) =>
      Input$ExamListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamMaxOrderByAggregateInput {
  Input$ExamMaxOrderByAggregateInput(
      {this.id, this.name, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamMinOrderByAggregateInput {
  Input$ExamMinOrderByAggregateInput(
      {this.id, this.name, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamOrderByRelationAggregateInput {
  Input$ExamOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ExamOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ExamOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ExamOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ExamOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamOrderByWithAggregationInput {
  Input$ExamOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$ExamOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ExamCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$ExamMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ExamMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$ExamOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$name,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$ExamOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ExamCountOrderByAggregateInput? Function()? $_count,
          Input$ExamMaxOrderByAggregateInput? Function()? $_max,
          Input$ExamMinOrderByAggregateInput? Function()? $_min}) =>
      Input$ExamOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamOrderByWithRelationInput {
  Input$ExamOrderByWithRelationInput(
      {this.id,
      this.name,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ExamQuestionOrderByRelationAggregateInput? examquestions;

  final Input$ExamAnswerOrderByRelationAggregateInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ExamQuestionOrderByRelationAggregateInput? Function()?
              examquestions,
          Input$ExamAnswerOrderByRelationAggregateInput? Function()?
              examAnswers}) =>
      Input$ExamOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCountOrderByAggregateInput {
  Input$ExamQuestionCountOrderByAggregateInput(
      {this.id, this.questionId, this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? questionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? questionId,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamQuestionCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateInput {
  Input$ExamQuestionCreateInput(
      {this.id,
      required this.question,
      required this.exam,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateInputFromJson(json);

  final String? id;

  final Input$QuestionCreateNestedOneWithoutExamquestionsInput question;

  final Input$ExamCreateNestedOneWithoutExamquestionsInput exam;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamQuestionCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$question = question;
    final l$exam = exam;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$question, l$exam, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$question = question;
    final lOther$question = other.question;
    if (l$question != lOther$question) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCreateInput copyWith(
          {String? Function()? id,
          Input$QuestionCreateNestedOneWithoutExamquestionsInput? question,
          Input$ExamCreateNestedOneWithoutExamquestionsInput? exam,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionCreateInput(
          id: id == null ? this.id : id(),
          question: question == null ? this.question : question,
          exam: exam == null ? this.exam : exam,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateManyExamInput {
  Input$ExamQuestionCreateManyExamInput(
      {this.id, required this.questionId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionCreateManyExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateManyExamInputFromJson(json);

  final String? id;

  final String questionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateManyExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$questionId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateManyExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCreateManyExamInput copyWith(
          {String? Function()? id,
          String? questionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionCreateManyExamInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateManyExamInputEnvelope {
  Input$ExamQuestionCreateManyExamInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ExamQuestionCreateManyExamInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateManyExamInputEnvelopeFromJson(json);

  final Input$ExamQuestionCreateManyExamInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateManyExamInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateManyExamInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ExamQuestionCreateManyExamInputEnvelope copyWith(
          {Input$ExamQuestionCreateManyExamInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ExamQuestionCreateManyExamInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateManyInput {
  Input$ExamQuestionCreateManyInput(
      {this.id,
      required this.questionId,
      required this.examId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateManyInputFromJson(json);

  final String? id;

  final String questionId;

  final String examId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCreateManyInput copyWith(
          {String? Function()? id,
          String? questionId,
          String? examId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionCreateManyInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId,
          examId: examId == null ? this.examId : examId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateManyQuestionInput {
  Input$ExamQuestionCreateManyQuestionInput(
      {this.id, required this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionCreateManyQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateManyQuestionInputFromJson(json);

  final String? id;

  final String examId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateManyQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateManyQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCreateManyQuestionInput copyWith(
          {String? Function()? id,
          String? examId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionCreateManyQuestionInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateManyQuestionInputEnvelope {
  Input$ExamQuestionCreateManyQuestionInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ExamQuestionCreateManyQuestionInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateManyQuestionInputEnvelopeFromJson(json);

  final Input$ExamQuestionCreateManyQuestionInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateManyQuestionInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateManyQuestionInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ExamQuestionCreateManyQuestionInputEnvelope copyWith(
          {Input$ExamQuestionCreateManyQuestionInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ExamQuestionCreateManyQuestionInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateNestedManyWithoutExamInput {
  Input$ExamQuestionCreateNestedManyWithoutExamInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamQuestionCreateNestedManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateNestedManyWithoutExamInputFromJson(json);

  final List<Input$ExamQuestionCreateWithoutExamInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>?
      connectOrCreate;

  final Input$ExamQuestionCreateManyExamInputEnvelope? createMany;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateNestedManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateNestedManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionCreateNestedManyWithoutExamInput copyWith(
          {List<Input$ExamQuestionCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          Input$ExamQuestionCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamQuestionCreateNestedManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateNestedManyWithoutQuestionInput {
  Input$ExamQuestionCreateNestedManyWithoutQuestionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamQuestionCreateNestedManyWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateNestedManyWithoutQuestionInputFromJson(json);

  final List<Input$ExamQuestionCreateWithoutQuestionInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
      connectOrCreate;

  final Input$ExamQuestionCreateManyQuestionInputEnvelope? createMany;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateNestedManyWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateNestedManyWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionCreateNestedManyWithoutQuestionInput copyWith(
          {List<Input$ExamQuestionCreateWithoutQuestionInput?>? Function()?
              create,
          List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
                  Function()?
              connectOrCreate,
          Input$ExamQuestionCreateManyQuestionInputEnvelope? Function()?
              createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamQuestionCreateNestedManyWithoutQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateOrConnectWithoutExamInput {
  Input$ExamQuestionCreateOrConnectWithoutExamInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamQuestionCreateOrConnectWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateOrConnectWithoutExamInputFromJson(json);

  final Input$ExamQuestionWhereUniqueInput where;

  final Input$ExamQuestionUncheckedCreateWithoutExamInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateOrConnectWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateOrConnectWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamQuestionCreateOrConnectWithoutExamInput copyWith(
          {Input$ExamQuestionWhereUniqueInput? where,
          Input$ExamQuestionUncheckedCreateWithoutExamInput? create}) =>
      Input$ExamQuestionCreateOrConnectWithoutExamInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateOrConnectWithoutQuestionInput {
  Input$ExamQuestionCreateOrConnectWithoutQuestionInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamQuestionCreateOrConnectWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateOrConnectWithoutQuestionInputFromJson(json);

  final Input$ExamQuestionWhereUniqueInput where;

  final Input$ExamQuestionUncheckedCreateWithoutQuestionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateOrConnectWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateOrConnectWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamQuestionCreateOrConnectWithoutQuestionInput copyWith(
          {Input$ExamQuestionWhereUniqueInput? where,
          Input$ExamQuestionUncheckedCreateWithoutQuestionInput? create}) =>
      Input$ExamQuestionCreateOrConnectWithoutQuestionInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateWithoutExamInput {
  Input$ExamQuestionCreateWithoutExamInput(
      {this.id, required this.question, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionCreateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateWithoutExamInputFromJson(json);

  final String? id;

  final Input$QuestionCreateNestedOneWithoutExamquestionsInput question;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$question = question;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$question, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$question = question;
    final lOther$question = other.question;
    if (l$question != lOther$question) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCreateWithoutExamInput copyWith(
          {String? Function()? id,
          Input$QuestionCreateNestedOneWithoutExamquestionsInput? question,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionCreateWithoutExamInput(
          id: id == null ? this.id : id(),
          question: question == null ? this.question : question,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionCreateWithoutQuestionInput {
  Input$ExamQuestionCreateWithoutQuestionInput(
      {this.id, required this.exam, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionCreateWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionCreateWithoutQuestionInputFromJson(json);

  final String? id;

  final Input$ExamCreateNestedOneWithoutExamquestionsInput exam;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionCreateWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$exam = exam;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$exam, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionCreateWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionCreateWithoutQuestionInput copyWith(
          {String? Function()? id,
          Input$ExamCreateNestedOneWithoutExamquestionsInput? exam,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionCreateWithoutQuestionInput(
          id: id == null ? this.id : id(),
          exam: exam == null ? this.exam : exam,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionListRelationFilter {
  Input$ExamQuestionListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ExamQuestionListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionListRelationFilterFromJson(json);

  final Input$ExamQuestionWhereInput? every;

  final Input$ExamQuestionWhereInput? some;

  final Input$ExamQuestionWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ExamQuestionListRelationFilter copyWith(
          {Input$ExamQuestionWhereInput? Function()? every,
          Input$ExamQuestionWhereInput? Function()? some,
          Input$ExamQuestionWhereInput? Function()? none}) =>
      Input$ExamQuestionListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionMaxOrderByAggregateInput {
  Input$ExamQuestionMaxOrderByAggregateInput(
      {this.id, this.questionId, this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? questionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? questionId,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamQuestionMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionMinOrderByAggregateInput {
  Input$ExamQuestionMinOrderByAggregateInput(
      {this.id, this.questionId, this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? questionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? questionId,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamQuestionMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionOrderByRelationAggregateInput {
  Input$ExamQuestionOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ExamQuestionOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ExamQuestionOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ExamQuestionOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionOrderByWithAggregationInput {
  Input$ExamQuestionOrderByWithAggregationInput(
      {this.id,
      this.questionId,
      this.examId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$ExamQuestionOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? questionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ExamQuestionCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$ExamQuestionMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ExamQuestionMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$questionId,
      l$examId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$ExamQuestionOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? questionId,
          Enum$SortOrder? Function()? examId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ExamQuestionCountOrderByAggregateInput? Function()? $_count,
          Input$ExamQuestionMaxOrderByAggregateInput? Function()? $_max,
          Input$ExamQuestionMinOrderByAggregateInput? Function()? $_min}) =>
      Input$ExamQuestionOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionOrderByWithRelationInput {
  Input$ExamQuestionOrderByWithRelationInput(
      {this.id,
      this.questionId,
      this.question,
      this.examId,
      this.exam,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? questionId;

  final Input$QuestionOrderByWithRelationInput? question;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? examId;

  final Input$ExamOrderByWithRelationInput? exam;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$question = question;
    final l$examId = examId;
    final l$exam = exam;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$questionId,
      l$question,
      l$examId,
      l$exam,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$question = question;
    final lOther$question = other.question;
    if (l$question != lOther$question) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? questionId,
          Input$QuestionOrderByWithRelationInput? Function()? question,
          Enum$SortOrder? Function()? examId,
          Input$ExamOrderByWithRelationInput? Function()? exam,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ExamQuestionOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          question: question == null ? this.question : question(),
          examId: examId == null ? this.examId : examId(),
          exam: exam == null ? this.exam : exam(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionScalarWhereInput {
  Input$ExamQuestionScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.questionId,
      this.examId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionScalarWhereInputFromJson(json);

  final List<Input$ExamQuestionScalarWhereInput?>? AND;

  final List<Input$ExamQuestionScalarWhereInput?>? OR;

  final List<Input$ExamQuestionScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? questionId;

  final Input$StringFilter? examId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$questionId,
      l$examId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionScalarWhereInput copyWith(
          {List<Input$ExamQuestionScalarWhereInput?>? Function()? AND,
          List<Input$ExamQuestionScalarWhereInput?>? Function()? OR,
          List<Input$ExamQuestionScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? questionId,
          Input$StringFilter? Function()? examId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ExamQuestionScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionScalarWhereWithAggregatesInput {
  Input$ExamQuestionScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.questionId,
      this.examId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ExamQuestionScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ExamQuestionScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ExamQuestionScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? questionId;

  final Input$StringWithAggregatesFilter? examId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$questionId,
      l$examId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionScalarWhereWithAggregatesInput copyWith(
          {List<Input$ExamQuestionScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ExamQuestionScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$ExamQuestionScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? questionId,
          Input$StringWithAggregatesFilter? Function()? examId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ExamQuestionScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedCreateInput {
  Input$ExamQuestionUncheckedCreateInput(
      {this.id,
      required this.questionId,
      required this.examId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedCreateInputFromJson(json);

  final String? id;

  final String questionId;

  final String examId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? questionId,
          String? examId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedCreateInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId,
          examId: examId == null ? this.examId : examId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput {
  Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInputFromJson(
          json);

  final List<Input$ExamQuestionCreateWithoutExamInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>?
      connectOrCreate;

  final Input$ExamQuestionCreateManyExamInputEnvelope? createMany;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput copyWith(
          {List<Input$ExamQuestionCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          Input$ExamQuestionCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput {
  Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInputFromJson(
          json);

  final List<Input$ExamQuestionCreateWithoutQuestionInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
      connectOrCreate;

  final Input$ExamQuestionCreateManyQuestionInputEnvelope? createMany;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput copyWith(
          {List<Input$ExamQuestionCreateWithoutQuestionInput?>? Function()?
              create,
          List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
                  Function()?
              connectOrCreate,
          Input$ExamQuestionCreateManyQuestionInputEnvelope? Function()?
              createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedCreateWithoutExamInput {
  Input$ExamQuestionUncheckedCreateWithoutExamInput(
      {this.id, required this.questionId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedCreateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedCreateWithoutExamInputFromJson(json);

  final String? id;

  final String questionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedCreateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$questionId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedCreateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedCreateWithoutExamInput copyWith(
          {String? Function()? id,
          String? questionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedCreateWithoutExamInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedCreateWithoutQuestionInput {
  Input$ExamQuestionUncheckedCreateWithoutQuestionInput(
      {this.id, required this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedCreateWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedCreateWithoutQuestionInputFromJson(json);

  final String? id;

  final String examId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedCreateWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedCreateWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedCreateWithoutQuestionInput copyWith(
          {String? Function()? id,
          String? examId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedCreateWithoutQuestionInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateInput {
  Input$ExamQuestionUncheckedUpdateInput(
      {this.id, this.questionId, this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? questionId;

  final Input$StringFieldUpdateOperationsInput? examId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? questionId,
          Input$StringFieldUpdateOperationsInput? Function()? examId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateManyInput {
  Input$ExamQuestionUncheckedUpdateManyInput(
      {this.id, this.questionId, this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? questionId;

  final Input$StringFieldUpdateOperationsInput? examId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$questionId, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? questionId,
          Input$StringFieldUpdateOperationsInput? Function()? examId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateManyWithoutExamInput {
  Input$ExamQuestionUncheckedUpdateManyWithoutExamInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamQuestionUncheckedUpdateManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateManyWithoutExamInputFromJson(json);

  final List<Input$ExamQuestionCreateWithoutExamInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>?
      connectOrCreate;

  final List<Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput?>? upsert;

  final Input$ExamQuestionCreateManyExamInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamQuestionWhereUniqueInput?>? $set;

  final List<Input$ExamQuestionWhereUniqueInput?>? disconnect;

  final List<Input$ExamQuestionWhereUniqueInput?>? delete;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  final List<Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput?>? update;

  final List<Input$ExamQuestionUpdateManyWithWhereWithoutExamInput?>?
      updateMany;

  final List<Input$ExamQuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedUpdateManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionUncheckedUpdateManyWithoutExamInput copyWith(
          {List<Input$ExamQuestionCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          List<Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput?>?
                  Function()?
              upsert,
          Input$ExamQuestionCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? $set,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? delete,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect,
          List<Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput?>?
                  Function()?
              update,
          List<Input$ExamQuestionUpdateManyWithWhereWithoutExamInput?>?
                  Function()?
              updateMany,
          List<Input$ExamQuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamQuestionUncheckedUpdateManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput {
  Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput(
      {this.id, this.questionId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? questionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$questionId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? questionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput {
  Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInputFromJson(json);

  final List<Input$ExamQuestionCreateWithoutQuestionInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
      connectOrCreate;

  final List<Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput?>?
      upsert;

  final Input$ExamQuestionCreateManyQuestionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamQuestionWhereUniqueInput?>? $set;

  final List<Input$ExamQuestionWhereUniqueInput?>? disconnect;

  final List<Input$ExamQuestionWhereUniqueInput?>? delete;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  final List<Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput?>?
      update;

  final List<Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput?>?
      updateMany;

  final List<Input$ExamQuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput copyWith(
          {List<Input$ExamQuestionCreateWithoutQuestionInput?>? Function()?
              create,
          List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput?>?
                  Function()?
              upsert,
          Input$ExamQuestionCreateManyQuestionInputEnvelope? Function()?
              createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? $set,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? delete,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect,
          List<Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput?>?
                  Function()?
              update,
          List<Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput?>?
                  Function()?
              updateMany,
          List<Input$ExamQuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateWithoutExamInput {
  Input$ExamQuestionUncheckedUpdateWithoutExamInput(
      {this.id, this.questionId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedUpdateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateWithoutExamInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? questionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$questionId = questionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$questionId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedUpdateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedUpdateWithoutExamInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? questionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedUpdateWithoutExamInput(
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUncheckedUpdateWithoutQuestionInput {
  Input$ExamQuestionUncheckedUpdateWithoutQuestionInput(
      {this.id, this.examId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUncheckedUpdateWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUncheckedUpdateWithoutQuestionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? examId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUncheckedUpdateWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$examId = examId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$examId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUncheckedUpdateWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUncheckedUpdateWithoutQuestionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? examId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUncheckedUpdateWithoutQuestionInput(
          id: id == null ? this.id : id(),
          examId: examId == null ? this.examId : examId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateInput {
  Input$ExamQuestionUpdateInput(
      {this.id, this.question, this.exam, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$QuestionUpdateOneRequiredWithoutExamquestionsInput? question;

  final Input$ExamUpdateOneRequiredWithoutExamquestionsInput? exam;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamQuestionUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$question = question;
    final l$exam = exam;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$question, l$exam, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$question = question;
    final lOther$question = other.question;
    if (l$question != lOther$question) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$QuestionUpdateOneRequiredWithoutExamquestionsInput? Function()?
              question,
          Input$ExamUpdateOneRequiredWithoutExamquestionsInput? Function()?
              exam,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUpdateInput(
          id: id == null ? this.id : id(),
          question: question == null ? this.question : question(),
          exam: exam == null ? this.exam : exam(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateManyMutationInput {
  Input$ExamQuestionUpdateManyMutationInput(
      {this.id, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateManyWithoutExamInput {
  Input$ExamQuestionUpdateManyWithoutExamInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamQuestionUpdateManyWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateManyWithoutExamInputFromJson(json);

  final List<Input$ExamQuestionCreateWithoutExamInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>?
      connectOrCreate;

  final List<Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput?>? upsert;

  final Input$ExamQuestionCreateManyExamInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamQuestionWhereUniqueInput?>? $set;

  final List<Input$ExamQuestionWhereUniqueInput?>? disconnect;

  final List<Input$ExamQuestionWhereUniqueInput?>? delete;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  final List<Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput?>? update;

  final List<Input$ExamQuestionUpdateManyWithWhereWithoutExamInput?>?
      updateMany;

  final List<Input$ExamQuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateManyWithoutExamInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateManyWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionUpdateManyWithoutExamInput copyWith(
          {List<Input$ExamQuestionCreateWithoutExamInput?>? Function()? create,
          List<Input$ExamQuestionCreateOrConnectWithoutExamInput?>? Function()?
              connectOrCreate,
          List<Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput?>?
                  Function()?
              upsert,
          Input$ExamQuestionCreateManyExamInputEnvelope? Function()? createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? $set,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? delete,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect,
          List<Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput?>?
                  Function()?
              update,
          List<Input$ExamQuestionUpdateManyWithWhereWithoutExamInput?>?
                  Function()?
              updateMany,
          List<Input$ExamQuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamQuestionUpdateManyWithoutExamInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateManyWithoutQuestionInput {
  Input$ExamQuestionUpdateManyWithoutQuestionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamQuestionUpdateManyWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateManyWithoutQuestionInputFromJson(json);

  final List<Input$ExamQuestionCreateWithoutQuestionInput?>? create;

  final List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
      connectOrCreate;

  final List<Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput?>?
      upsert;

  final Input$ExamQuestionCreateManyQuestionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamQuestionWhereUniqueInput?>? $set;

  final List<Input$ExamQuestionWhereUniqueInput?>? disconnect;

  final List<Input$ExamQuestionWhereUniqueInput?>? delete;

  final List<Input$ExamQuestionWhereUniqueInput?>? connect;

  final List<Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput?>?
      update;

  final List<Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput?>?
      updateMany;

  final List<Input$ExamQuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateManyWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateManyWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamQuestionUpdateManyWithoutQuestionInput copyWith(
          {List<Input$ExamQuestionCreateWithoutQuestionInput?>? Function()?
              create,
          List<Input$ExamQuestionCreateOrConnectWithoutQuestionInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput?>?
                  Function()?
              upsert,
          Input$ExamQuestionCreateManyQuestionInputEnvelope? Function()?
              createMany,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? $set,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? delete,
          List<Input$ExamQuestionWhereUniqueInput?>? Function()? connect,
          List<Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput?>?
                  Function()?
              update,
          List<Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput?>?
                  Function()?
              updateMany,
          List<Input$ExamQuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamQuestionUpdateManyWithoutQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateManyWithWhereWithoutExamInput {
  Input$ExamQuestionUpdateManyWithWhereWithoutExamInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamQuestionUpdateManyWithWhereWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateManyWithWhereWithoutExamInputFromJson(json);

  final Input$ExamQuestionScalarWhereInput where;

  final Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateManyWithWhereWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateManyWithWhereWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamQuestionUpdateManyWithWhereWithoutExamInput copyWith(
          {Input$ExamQuestionScalarWhereInput? where,
          Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput?
              data}) =>
      Input$ExamQuestionUpdateManyWithWhereWithoutExamInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput {
  Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInputFromJson(json);

  final Input$ExamQuestionScalarWhereInput where;

  final Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput copyWith(
          {Input$ExamQuestionScalarWhereInput? where,
          Input$ExamQuestionUncheckedUpdateManyWithoutExamquestionsInput?
              data}) =>
      Input$ExamQuestionUpdateManyWithWhereWithoutQuestionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateWithoutExamInput {
  Input$ExamQuestionUpdateWithoutExamInput(
      {this.id, this.question, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUpdateWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateWithoutExamInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$QuestionUpdateOneRequiredWithoutExamquestionsInput? question;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateWithoutExamInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$question = question;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$question, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$question = question;
    final lOther$question = other.question;
    if (l$question != lOther$question) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUpdateWithoutExamInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$QuestionUpdateOneRequiredWithoutExamquestionsInput? Function()?
              question,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUpdateWithoutExamInput(
          id: id == null ? this.id : id(),
          question: question == null ? this.question : question(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateWithoutQuestionInput {
  Input$ExamQuestionUpdateWithoutQuestionInput(
      {this.id, this.exam, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamQuestionUpdateWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateWithoutQuestionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$ExamUpdateOneRequiredWithoutExamquestionsInput? exam;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$exam = exam;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$exam, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionUpdateWithoutQuestionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$ExamUpdateOneRequiredWithoutExamquestionsInput? Function()?
              exam,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamQuestionUpdateWithoutQuestionInput(
          id: id == null ? this.id : id(),
          exam: exam == null ? this.exam : exam(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput {
  Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInputFromJson(json);

  final Input$ExamQuestionWhereUniqueInput where;

  final Input$ExamQuestionUncheckedUpdateWithoutExamInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput copyWith(
          {Input$ExamQuestionWhereUniqueInput? where,
          Input$ExamQuestionUncheckedUpdateWithoutExamInput? data}) =>
      Input$ExamQuestionUpdateWithWhereUniqueWithoutExamInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput {
  Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInputFromJson(
          json);

  final Input$ExamQuestionWhereUniqueInput where;

  final Input$ExamQuestionUncheckedUpdateWithoutQuestionInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput copyWith(
          {Input$ExamQuestionWhereUniqueInput? where,
          Input$ExamQuestionUncheckedUpdateWithoutQuestionInput? data}) =>
      Input$ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput {
  Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInputFromJson(json);

  final Input$ExamQuestionWhereUniqueInput where;

  final Input$ExamQuestionUncheckedUpdateWithoutExamInput update;

  final Input$ExamQuestionUncheckedCreateWithoutExamInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput copyWith(
          {Input$ExamQuestionWhereUniqueInput? where,
          Input$ExamQuestionUncheckedUpdateWithoutExamInput? update,
          Input$ExamQuestionUncheckedCreateWithoutExamInput? create}) =>
      Input$ExamQuestionUpsertWithWhereUniqueWithoutExamInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput {
  Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInputFromJson(
          json);

  final Input$ExamQuestionWhereUniqueInput where;

  final Input$ExamQuestionUncheckedUpdateWithoutQuestionInput update;

  final Input$ExamQuestionUncheckedCreateWithoutQuestionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput copyWith(
          {Input$ExamQuestionWhereUniqueInput? where,
          Input$ExamQuestionUncheckedUpdateWithoutQuestionInput? update,
          Input$ExamQuestionUncheckedCreateWithoutQuestionInput? create}) =>
      Input$ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionWhereInput {
  Input$ExamQuestionWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.questionId,
      this.question,
      this.examId,
      this.exam,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamQuestionWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamQuestionWhereInputFromJson(json);

  final List<Input$ExamQuestionWhereInput?>? AND;

  final List<Input$ExamQuestionWhereInput?>? OR;

  final List<Input$ExamQuestionWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? questionId;

  final Input$QuestionWhereInput? question;

  final Input$StringFilter? examId;

  final Input$ExamWhereInput? exam;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamQuestionWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$questionId = questionId;
    final l$question = question;
    final l$examId = examId;
    final l$exam = exam;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$questionId,
      l$question,
      l$examId,
      l$exam,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$questionId = questionId;
    final lOther$questionId = other.questionId;
    if (l$questionId != lOther$questionId) return false;
    final l$question = question;
    final lOther$question = other.question;
    if (l$question != lOther$question) return false;
    final l$examId = examId;
    final lOther$examId = other.examId;
    if (l$examId != lOther$examId) return false;
    final l$exam = exam;
    final lOther$exam = other.exam;
    if (l$exam != lOther$exam) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamQuestionWhereInput copyWith(
          {List<Input$ExamQuestionWhereInput?>? Function()? AND,
          List<Input$ExamQuestionWhereInput?>? Function()? OR,
          List<Input$ExamQuestionWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? questionId,
          Input$QuestionWhereInput? Function()? question,
          Input$StringFilter? Function()? examId,
          Input$ExamWhereInput? Function()? exam,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ExamQuestionWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          questionId: questionId == null ? this.questionId : questionId(),
          question: question == null ? this.question : question(),
          examId: examId == null ? this.examId : examId(),
          exam: exam == null ? this.exam : exam(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamQuestionWhereUniqueInput {
  Input$ExamQuestionWhereUniqueInput({this.id});

  @override
  factory Input$ExamQuestionWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamQuestionWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$ExamQuestionWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamQuestionWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ExamQuestionWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ExamQuestionWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamRelationFilter {
  Input$ExamRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ExamRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ExamWhereInput? $is;

  final Input$ExamWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$ExamRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ExamRelationFilter copyWith(
          {Input$ExamWhereInput? Function()? $is,
          Input$ExamWhereInput? Function()? isNot}) =>
      Input$ExamRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamScalarWhereInput {
  Input$ExamScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamScalarWhereInputFromJson(json);

  final List<Input$ExamScalarWhereInput?>? AND;

  final List<Input$ExamScalarWhereInput?>? OR;

  final List<Input$ExamScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? userId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ExamScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamScalarWhereInput copyWith(
          {List<Input$ExamScalarWhereInput?>? Function()? AND,
          List<Input$ExamScalarWhereInput?>? Function()? OR,
          List<Input$ExamScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? userId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ExamScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamScalarWhereWithAggregatesInput {
  Input$ExamScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ExamScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ExamScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ExamScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ExamScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? userId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamScalarWhereWithAggregatesInput copyWith(
          {List<Input$ExamScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$ExamScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ExamScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? userId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ExamScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionAvgOrderByAggregateInput {
  Input$ExamSessionAvgOrderByAggregateInput({this.maxPlayer});

  @override
  factory Input$ExamSessionAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$maxPlayer = maxPlayer;
    return Object.hashAll([l$maxPlayer]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    return true;
  }

  Input$ExamSessionAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? maxPlayer}) =>
      Input$ExamSessionAvgOrderByAggregateInput(
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCountOrderByAggregateInput {
  Input$ExamSessionCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? openAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? closeAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? openAt,
          Enum$SortOrder? Function()? closeAt,
          Enum$SortOrder? Function()? maxPlayer,
          Enum$SortOrder? Function()? userId}) =>
      Input$ExamSessionCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateInput {
  Input$ExamSessionCreateInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      required this.user,
      this.examAnswers});

  @override
  factory Input$ExamSessionCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final Input$UserCreateNestedOneWithoutExamsessionsInput user;

  final Input$ExamAnswerCreateNestedManyWithoutExamSessionInput? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamSessionCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$user = user;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$user,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          Input$UserCreateNestedOneWithoutExamsessionsInput? user,
          Input$ExamAnswerCreateNestedManyWithoutExamSessionInput? Function()?
              examAnswers}) =>
      Input$ExamSessionCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          user: user == null ? this.user : user,
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateManyInput {
  Input$ExamSessionCreateManyInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      required this.userId});

  @override
  factory Input$ExamSessionCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final String userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          String? userId}) =>
      Input$ExamSessionCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateManyUserInput {
  Input$ExamSessionCreateManyUserInput(
      {this.id, required this.name, this.openAt, this.closeAt, this.maxPlayer});

  @override
  factory Input$ExamSessionCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateManyUserInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    return Object.hashAll([l$id, l$name, l$openAt, l$closeAt, l$maxPlayer]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    return true;
  }

  Input$ExamSessionCreateManyUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer}) =>
      Input$ExamSessionCreateManyUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateManyUserInputEnvelope {
  Input$ExamSessionCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ExamSessionCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateManyUserInputEnvelopeFromJson(json);

  final Input$ExamSessionCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ExamSessionCreateManyUserInputEnvelope copyWith(
          {Input$ExamSessionCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ExamSessionCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateNestedManyWithoutUserInput {
  Input$ExamSessionCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamSessionCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ExamSessionCreateWithoutUserInput?>? create;

  final List<Input$ExamSessionCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ExamSessionCreateManyUserInputEnvelope? createMany;

  final List<Input$ExamSessionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamSessionCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ExamSessionCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamSessionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ExamSessionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamSessionCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateNestedOneWithoutExamAnswersInput {
  Input$ExamSessionCreateNestedOneWithoutExamAnswersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ExamSessionCreateNestedOneWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateNestedOneWithoutExamAnswersInputFromJson(json);

  final Input$ExamSessionUncheckedCreateWithoutExamAnswersInput? create;

  final Input$ExamSessionCreateOrConnectWithoutExamAnswersInput?
      connectOrCreate;

  final Input$ExamSessionWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateNestedOneWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateNestedOneWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ExamSessionCreateNestedOneWithoutExamAnswersInput copyWith(
          {Input$ExamSessionUncheckedCreateWithoutExamAnswersInput? Function()?
              create,
          Input$ExamSessionCreateOrConnectWithoutExamAnswersInput? Function()?
              connectOrCreate,
          Input$ExamSessionWhereUniqueInput? Function()? connect}) =>
      Input$ExamSessionCreateNestedOneWithoutExamAnswersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateOrConnectWithoutExamAnswersInput {
  Input$ExamSessionCreateOrConnectWithoutExamAnswersInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamSessionCreateOrConnectWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateOrConnectWithoutExamAnswersInputFromJson(json);

  final Input$ExamSessionWhereUniqueInput where;

  final Input$ExamSessionUncheckedCreateWithoutExamAnswersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateOrConnectWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateOrConnectWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamSessionCreateOrConnectWithoutExamAnswersInput copyWith(
          {Input$ExamSessionWhereUniqueInput? where,
          Input$ExamSessionUncheckedCreateWithoutExamAnswersInput? create}) =>
      Input$ExamSessionCreateOrConnectWithoutExamAnswersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateOrConnectWithoutUserInput {
  Input$ExamSessionCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ExamSessionCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ExamSessionWhereUniqueInput where;

  final Input$ExamSessionUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamSessionCreateOrConnectWithoutUserInput copyWith(
          {Input$ExamSessionWhereUniqueInput? where,
          Input$ExamSessionUncheckedCreateWithoutUserInput? create}) =>
      Input$ExamSessionCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateWithoutExamAnswersInput {
  Input$ExamSessionCreateWithoutExamAnswersInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      required this.user});

  @override
  factory Input$ExamSessionCreateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateWithoutExamAnswersInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final Input$UserCreateNestedOneWithoutExamsessionsInput user;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$user = user;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$user]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    return true;
  }

  Input$ExamSessionCreateWithoutExamAnswersInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          Input$UserCreateNestedOneWithoutExamsessionsInput? user}) =>
      Input$ExamSessionCreateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          user: user == null ? this.user : user);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionCreateWithoutUserInput {
  Input$ExamSessionCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.examAnswers});

  @override
  factory Input$ExamSessionCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final Input$ExamAnswerCreateNestedManyWithoutExamSessionInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          Input$ExamAnswerCreateNestedManyWithoutExamSessionInput? Function()?
              examAnswers}) =>
      Input$ExamSessionCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionListRelationFilter {
  Input$ExamSessionListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ExamSessionListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionListRelationFilterFromJson(json);

  final Input$ExamSessionWhereInput? every;

  final Input$ExamSessionWhereInput? some;

  final Input$ExamSessionWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ExamSessionListRelationFilter copyWith(
          {Input$ExamSessionWhereInput? Function()? every,
          Input$ExamSessionWhereInput? Function()? some,
          Input$ExamSessionWhereInput? Function()? none}) =>
      Input$ExamSessionListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionMaxOrderByAggregateInput {
  Input$ExamSessionMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? openAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? closeAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? openAt,
          Enum$SortOrder? Function()? closeAt,
          Enum$SortOrder? Function()? maxPlayer,
          Enum$SortOrder? Function()? userId}) =>
      Input$ExamSessionMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionMinOrderByAggregateInput {
  Input$ExamSessionMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? openAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? closeAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? openAt,
          Enum$SortOrder? Function()? closeAt,
          Enum$SortOrder? Function()? maxPlayer,
          Enum$SortOrder? Function()? userId}) =>
      Input$ExamSessionMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionOrderByRelationAggregateInput {
  Input$ExamSessionOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ExamSessionOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ExamSessionOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ExamSessionOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionOrderByWithAggregationInput {
  Input$ExamSessionOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ExamSessionOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? openAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? closeAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(name: '_count')
  final Input$ExamSessionCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ExamSessionAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ExamSessionMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ExamSessionMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ExamSessionSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ExamSessionOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? openAt,
          Enum$SortOrder? Function()? closeAt,
          Enum$SortOrder? Function()? maxPlayer,
          Enum$SortOrder? Function()? userId,
          Input$ExamSessionCountOrderByAggregateInput? Function()? $_count,
          Input$ExamSessionAvgOrderByAggregateInput? Function()? $_avg,
          Input$ExamSessionMaxOrderByAggregateInput? Function()? $_max,
          Input$ExamSessionMinOrderByAggregateInput? Function()? $_min,
          Input$ExamSessionSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ExamSessionOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionOrderByWithRelationInput {
  Input$ExamSessionOrderByWithRelationInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId,
      this.user,
      this.examAnswers});

  @override
  factory Input$ExamSessionOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? openAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? closeAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  final Input$ExamAnswerOrderByRelationAggregateInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    final l$user = user;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId,
      l$user,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? openAt,
          Enum$SortOrder? Function()? closeAt,
          Enum$SortOrder? Function()? maxPlayer,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Input$ExamAnswerOrderByRelationAggregateInput? Function()?
              examAnswers}) =>
      Input$ExamSessionOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionRelationFilter {
  Input$ExamSessionRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ExamSessionRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamSessionRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ExamSessionWhereInput? $is;

  final Input$ExamSessionWhereInput? isNot;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ExamSessionRelationFilter copyWith(
          {Input$ExamSessionWhereInput? Function()? $is,
          Input$ExamSessionWhereInput? Function()? isNot}) =>
      Input$ExamSessionRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionScalarWhereInput {
  Input$ExamSessionScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionScalarWhereInputFromJson(json);

  final List<Input$ExamSessionScalarWhereInput?>? AND;

  final List<Input$ExamSessionScalarWhereInput?>? OR;

  final List<Input$ExamSessionScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$DateTimeNullableFilter? openAt;

  final Input$DateTimeNullableFilter? closeAt;

  final Input$IntNullableFilter? maxPlayer;

  final Input$StringFilter? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionScalarWhereInput copyWith(
          {List<Input$ExamSessionScalarWhereInput?>? Function()? AND,
          List<Input$ExamSessionScalarWhereInput?>? Function()? OR,
          List<Input$ExamSessionScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$DateTimeNullableFilter? Function()? openAt,
          Input$DateTimeNullableFilter? Function()? closeAt,
          Input$IntNullableFilter? Function()? maxPlayer,
          Input$StringFilter? Function()? userId}) =>
      Input$ExamSessionScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionScalarWhereWithAggregatesInput {
  Input$ExamSessionScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ExamSessionScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ExamSessionScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ExamSessionScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$DateTimeNullableWithAggregatesFilter? openAt;

  final Input$DateTimeNullableWithAggregatesFilter? closeAt;

  final Input$IntNullableWithAggregatesFilter? maxPlayer;

  final Input$StringWithAggregatesFilter? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionScalarWhereWithAggregatesInput copyWith(
          {List<Input$ExamSessionScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ExamSessionScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$ExamSessionScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$DateTimeNullableWithAggregatesFilter? Function()? openAt,
          Input$DateTimeNullableWithAggregatesFilter? Function()? closeAt,
          Input$IntNullableWithAggregatesFilter? Function()? maxPlayer,
          Input$StringWithAggregatesFilter? Function()? userId}) =>
      Input$ExamSessionScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionSumOrderByAggregateInput {
  Input$ExamSessionSumOrderByAggregateInput({this.maxPlayer});

  @override
  factory Input$ExamSessionSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? maxPlayer;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$maxPlayer = maxPlayer;
    return Object.hashAll([l$maxPlayer]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    return true;
  }

  Input$ExamSessionSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? maxPlayer}) =>
      Input$ExamSessionSumOrderByAggregateInput(
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedCreateInput {
  Input$ExamSessionUncheckedCreateInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      required this.userId,
      this.examAnswers});

  @override
  factory Input$ExamSessionUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final String userId;

  final Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput?
      examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          String? userId,
          Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput?
                  Function()?
              examAnswers}) =>
      Input$ExamSessionUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId,
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput {
  Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$ExamSessionCreateWithoutUserInput?>? create;

  final List<Input$ExamSessionCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ExamSessionCreateManyUserInputEnvelope? createMany;

  final List<Input$ExamSessionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ExamSessionCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamSessionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ExamSessionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedCreateWithoutExamAnswersInput {
  Input$ExamSessionUncheckedCreateWithoutExamAnswersInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      required this.userId});

  @override
  factory Input$ExamSessionUncheckedCreateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedCreateWithoutExamAnswersInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final String userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedCreateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedCreateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionUncheckedCreateWithoutExamAnswersInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          String? userId}) =>
      Input$ExamSessionUncheckedCreateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedCreateWithoutUserInput {
  Input$ExamSessionUncheckedCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.examAnswers});

  @override
  factory Input$ExamSessionUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String? openAt;

  final String? closeAt;

  final int? maxPlayer;

  final Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput?
      examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? openAt,
          String? Function()? closeAt,
          int? Function()? maxPlayer,
          Input$ExamAnswerUncheckedCreateNestedManyWithoutExamSessionInput?
                  Function()?
              examAnswers}) =>
      Input$ExamSessionUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedUpdateInput {
  Input$ExamSessionUncheckedUpdateInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId,
      this.examAnswers});

  @override
  factory Input$ExamSessionUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput?
                  Function()?
              examAnswers}) =>
      Input$ExamSessionUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedUpdateManyInput {
  Input$ExamSessionUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$StringFieldUpdateOperationsInput? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$StringFieldUpdateOperationsInput? Function()? userId}) =>
      Input$ExamSessionUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput {
  Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput(
      {this.id, this.name, this.openAt, this.closeAt, this.maxPlayer});

  @override
  factory Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    return Object.hashAll([l$id, l$name, l$openAt, l$closeAt, l$maxPlayer]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    return true;
  }

  Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()?
              maxPlayer}) =>
      Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedUpdateManyWithoutUserInput {
  Input$ExamSessionUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamSessionUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ExamSessionCreateWithoutUserInput?>? create;

  final List<Input$ExamSessionCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ExamSessionCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamSessionWhereUniqueInput?>? $set;

  final List<Input$ExamSessionWhereUniqueInput?>? disconnect;

  final List<Input$ExamSessionWhereUniqueInput?>? delete;

  final List<Input$ExamSessionWhereUniqueInput?>? connect;

  final List<Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ExamSessionUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ExamSessionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamSessionUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ExamSessionCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamSessionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ExamSessionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? $set,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? delete,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? connect,
          List<Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ExamSessionUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ExamSessionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamSessionUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput {
  Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId});

  @override
  factory Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedUpdateWithoutExamAnswersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$StringFieldUpdateOperationsInput? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedUpdateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$StringFieldUpdateOperationsInput? Function()? userId}) =>
      Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUncheckedUpdateWithoutUserInput {
  Input$ExamSessionUncheckedUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.examAnswers});

  @override
  factory Input$ExamSessionUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamSessionInput?
                  Function()?
              examAnswers}) =>
      Input$ExamSessionUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateInput {
  Input$ExamSessionUpdateInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.user,
      this.examAnswers});

  @override
  factory Input$ExamSessionUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$UserUpdateOneRequiredWithoutExamsessionsInput? user;

  final Input$ExamAnswerUpdateManyWithoutExamSessionInput? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamSessionUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$user = user;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$user,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$UserUpdateOneRequiredWithoutExamsessionsInput? Function()? user,
          Input$ExamAnswerUpdateManyWithoutExamSessionInput? Function()?
              examAnswers}) =>
      Input$ExamSessionUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          user: user == null ? this.user : user(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateManyMutationInput {
  Input$ExamSessionUpdateManyMutationInput(
      {this.id, this.name, this.openAt, this.closeAt, this.maxPlayer});

  @override
  factory Input$ExamSessionUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    return Object.hashAll([l$id, l$name, l$openAt, l$closeAt, l$maxPlayer]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    return true;
  }

  Input$ExamSessionUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()?
              maxPlayer}) =>
      Input$ExamSessionUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateManyWithoutUserInput {
  Input$ExamSessionUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamSessionUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ExamSessionCreateWithoutUserInput?>? create;

  final List<Input$ExamSessionCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ExamSessionCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamSessionWhereUniqueInput?>? $set;

  final List<Input$ExamSessionWhereUniqueInput?>? disconnect;

  final List<Input$ExamSessionWhereUniqueInput?>? delete;

  final List<Input$ExamSessionWhereUniqueInput?>? connect;

  final List<Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ExamSessionUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ExamSessionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamSessionUpdateManyWithoutUserInput copyWith(
          {List<Input$ExamSessionCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamSessionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ExamSessionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? $set,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? delete,
          List<Input$ExamSessionWhereUniqueInput?>? Function()? connect,
          List<Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ExamSessionUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ExamSessionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamSessionUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateManyWithWhereWithoutUserInput {
  Input$ExamSessionUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamSessionUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ExamSessionScalarWhereInput where;

  final Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamSessionUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ExamSessionScalarWhereInput? where,
          Input$ExamSessionUncheckedUpdateManyWithoutExamsessionsInput?
              data}) =>
      Input$ExamSessionUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateOneWithoutExamAnswersInput {
  Input$ExamSessionUpdateOneWithoutExamAnswersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.disconnect,
      this.delete,
      this.connect,
      this.update});

  @override
  factory Input$ExamSessionUpdateOneWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateOneWithoutExamAnswersInputFromJson(json);

  final Input$ExamSessionUncheckedCreateWithoutExamAnswersInput? create;

  final Input$ExamSessionCreateOrConnectWithoutExamAnswersInput?
      connectOrCreate;

  final Input$ExamSessionUpsertWithoutExamAnswersInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final Input$ExamSessionWhereUniqueInput? connect;

  final Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateOneWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      l$create,
      l$connectOrCreate,
      l$upsert,
      l$disconnect,
      l$delete,
      l$connect,
      l$update
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateOneWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != lOther$disconnect) return false;
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != lOther$delete) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ExamSessionUpdateOneWithoutExamAnswersInput copyWith(
          {Input$ExamSessionUncheckedCreateWithoutExamAnswersInput? Function()?
              create,
          Input$ExamSessionCreateOrConnectWithoutExamAnswersInput? Function()?
              connectOrCreate,
          Input$ExamSessionUpsertWithoutExamAnswersInput? Function()? upsert,
          bool? Function()? disconnect,
          bool? Function()? delete,
          Input$ExamSessionWhereUniqueInput? Function()? connect,
          Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput? Function()?
              update}) =>
      Input$ExamSessionUpdateOneWithoutExamAnswersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateWithoutExamAnswersInput {
  Input$ExamSessionUpdateWithoutExamAnswersInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.user});

  @override
  factory Input$ExamSessionUpdateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateWithoutExamAnswersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$UserUpdateOneRequiredWithoutExamsessionsInput? user;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$user = user;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$user]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    return true;
  }

  Input$ExamSessionUpdateWithoutExamAnswersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$UserUpdateOneRequiredWithoutExamsessionsInput? Function()?
              user}) =>
      Input$ExamSessionUpdateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          user: user == null ? this.user : user());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateWithoutUserInput {
  Input$ExamSessionUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.examAnswers});

  @override
  factory Input$ExamSessionUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableDateTimeFieldUpdateOperationsInput? openAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? closeAt;

  final Input$NullableIntFieldUpdateOperationsInput? maxPlayer;

  final Input$ExamAnswerUpdateManyWithoutExamSessionInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$openAt, l$closeAt, l$maxPlayer, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? openAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()? closeAt,
          Input$NullableIntFieldUpdateOperationsInput? Function()? maxPlayer,
          Input$ExamAnswerUpdateManyWithoutExamSessionInput? Function()?
              examAnswers}) =>
      Input$ExamSessionUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput {
  Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ExamSessionWhereUniqueInput where;

  final Input$ExamSessionUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ExamSessionWhereUniqueInput? where,
          Input$ExamSessionUncheckedUpdateWithoutUserInput? data}) =>
      Input$ExamSessionUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpsertWithoutExamAnswersInput {
  Input$ExamSessionUpsertWithoutExamAnswersInput(
      {required this.update, required this.create});

  @override
  factory Input$ExamSessionUpsertWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpsertWithoutExamAnswersInputFromJson(json);

  final Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput update;

  final Input$ExamSessionUncheckedCreateWithoutExamAnswersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpsertWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpsertWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamSessionUpsertWithoutExamAnswersInput copyWith(
          {Input$ExamSessionUncheckedUpdateWithoutExamAnswersInput? update,
          Input$ExamSessionUncheckedCreateWithoutExamAnswersInput? create}) =>
      Input$ExamSessionUpsertWithoutExamAnswersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput {
  Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ExamSessionWhereUniqueInput where;

  final Input$ExamSessionUncheckedUpdateWithoutUserInput update;

  final Input$ExamSessionUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ExamSessionWhereUniqueInput? where,
          Input$ExamSessionUncheckedUpdateWithoutUserInput? update,
          Input$ExamSessionUncheckedCreateWithoutUserInput? create}) =>
      Input$ExamSessionUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionWhereInput {
  Input$ExamSessionWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.openAt,
      this.closeAt,
      this.maxPlayer,
      this.userId,
      this.user,
      this.examAnswers});

  @override
  factory Input$ExamSessionWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamSessionWhereInputFromJson(json);

  final List<Input$ExamSessionWhereInput?>? AND;

  final List<Input$ExamSessionWhereInput?>? OR;

  final List<Input$ExamSessionWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$DateTimeNullableFilter? openAt;

  final Input$DateTimeNullableFilter? closeAt;

  final Input$IntNullableFilter? maxPlayer;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$ExamAnswerListRelationFilter? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamSessionWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$openAt = openAt;
    final l$closeAt = closeAt;
    final l$maxPlayer = maxPlayer;
    final l$userId = userId;
    final l$user = user;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$openAt,
      l$closeAt,
      l$maxPlayer,
      l$userId,
      l$user,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$openAt = openAt;
    final lOther$openAt = other.openAt;
    if (l$openAt != lOther$openAt) return false;
    final l$closeAt = closeAt;
    final lOther$closeAt = other.closeAt;
    if (l$closeAt != lOther$closeAt) return false;
    final l$maxPlayer = maxPlayer;
    final lOther$maxPlayer = other.maxPlayer;
    if (l$maxPlayer != lOther$maxPlayer) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamSessionWhereInput copyWith(
          {List<Input$ExamSessionWhereInput?>? Function()? AND,
          List<Input$ExamSessionWhereInput?>? Function()? OR,
          List<Input$ExamSessionWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$DateTimeNullableFilter? Function()? openAt,
          Input$DateTimeNullableFilter? Function()? closeAt,
          Input$IntNullableFilter? Function()? maxPlayer,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$ExamAnswerListRelationFilter? Function()? examAnswers}) =>
      Input$ExamSessionWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          openAt: openAt == null ? this.openAt : openAt(),
          closeAt: closeAt == null ? this.closeAt : closeAt(),
          maxPlayer: maxPlayer == null ? this.maxPlayer : maxPlayer(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamSessionWhereUniqueInput {
  Input$ExamSessionWhereUniqueInput({this.id});

  @override
  factory Input$ExamSessionWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamSessionWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$ExamSessionWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamSessionWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ExamSessionWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ExamSessionWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedCreateInput {
  Input$ExamUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.userId,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput?
      examquestions;

  final Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput?
                  Function()?
              examquestions,
          Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedCreateNestedManyWithoutUserInput {
  Input$ExamUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ExamUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ExamCreateWithoutUserInput?>? create;

  final List<Input$ExamCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ExamCreateManyUserInputEnvelope? createMany;

  final List<Input$ExamWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ExamUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ExamCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ExamCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamWhereUniqueInput?>? Function()? connect}) =>
      Input$ExamUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedCreateWithoutExamAnswersInput {
  Input$ExamUncheckedCreateWithoutExamAnswersInput(
      {this.id,
      required this.name,
      required this.userId,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$ExamUncheckedCreateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedCreateWithoutExamAnswersInputFromJson(json);

  final String? id;

  final String name;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedCreateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll(
        [l$id, l$name, l$userId, l$createdAt, l$updatedAt, l$examquestions]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedCreateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$ExamUncheckedCreateWithoutExamAnswersInput copyWith(
          {String? Function()? id,
          String? name,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput?
                  Function()?
              examquestions}) =>
      Input$ExamUncheckedCreateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedCreateWithoutExamquestionsInput {
  Input$ExamUncheckedCreateWithoutExamquestionsInput(
      {this.id,
      required this.name,
      required this.userId,
      this.createdAt,
      this.updatedAt,
      this.examAnswers});

  @override
  factory Input$ExamUncheckedCreateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedCreateWithoutExamquestionsInputFromJson(json);

  final String? id;

  final String name;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedCreateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$userId, l$createdAt, l$updatedAt, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedCreateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUncheckedCreateWithoutExamquestionsInput copyWith(
          {String? Function()? id,
          String? name,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUncheckedCreateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedCreateWithoutUserInput {
  Input$ExamUncheckedCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput?
      examquestions;

  final Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutExamInput?
                  Function()?
              examquestions,
          Input$ExamAnswerUncheckedCreateNestedManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateInput {
  Input$ExamUncheckedUpdateInput(
      {this.id,
      this.name,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutExamInput? examquestions;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutExamInput? Function()?
              examquestions,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateManyInput {
  Input$ExamUncheckedUpdateManyInput(
      {this.id, this.name, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateManyWithoutExaminationsInput {
  Input$ExamUncheckedUpdateManyWithoutExaminationsInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamUncheckedUpdateManyWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateManyWithoutExaminationsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedUpdateManyWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateManyWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamUncheckedUpdateManyWithoutExaminationsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamUncheckedUpdateManyWithoutExaminationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateManyWithoutUserInput {
  Input$ExamUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ExamCreateWithoutUserInput?>? create;

  final List<Input$ExamCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ExamUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ExamCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamWhereUniqueInput?>? $set;

  final List<Input$ExamWhereUniqueInput?>? disconnect;

  final List<Input$ExamWhereUniqueInput?>? delete;

  final List<Input$ExamWhereUniqueInput?>? connect;

  final List<Input$ExamUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ExamUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ExamScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ExamCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ExamUpsertWithWhereUniqueWithoutUserInput?>? Function()?
              upsert,
          Input$ExamCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamWhereUniqueInput?>? Function()? $set,
          List<Input$ExamWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamWhereUniqueInput?>? Function()? delete,
          List<Input$ExamWhereUniqueInput?>? Function()? connect,
          List<Input$ExamUpdateWithWhereUniqueWithoutUserInput?>? Function()?
              update,
          List<Input$ExamUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ExamScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateWithoutExamAnswersInput {
  Input$ExamUncheckedUpdateWithoutExamAnswersInput(
      {this.id,
      this.name,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$ExamUncheckedUpdateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateWithoutExamAnswersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutExamInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedUpdateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll(
        [l$id, l$name, l$userId, l$createdAt, l$updatedAt, l$examquestions]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$ExamUncheckedUpdateWithoutExamAnswersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutExamInput? Function()?
              examquestions}) =>
      Input$ExamUncheckedUpdateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateWithoutExamquestionsInput {
  Input$ExamUncheckedUpdateWithoutExamquestionsInput(
      {this.id,
      this.name,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.examAnswers});

  @override
  factory Input$ExamUncheckedUpdateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateWithoutExamquestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedUpdateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$userId, l$createdAt, l$updatedAt, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUncheckedUpdateWithoutExamquestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUncheckedUpdateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUncheckedUpdateWithoutUserInput {
  Input$ExamUncheckedUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutExamInput? examquestions;

  final Input$ExamAnswerUncheckedUpdateManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutExamInput? Function()?
              examquestions,
          Input$ExamAnswerUncheckedUpdateManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateInput {
  Input$ExamUpdateInput(
      {this.id,
      this.name,
      this.user,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$UserUpdateOneRequiredWithoutExaminationsInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutExamInput? examquestions;

  final Input$ExamAnswerUpdateManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$user,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$UserUpdateOneRequiredWithoutExaminationsInput? Function()? user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutExamInput? Function()?
              examquestions,
          Input$ExamAnswerUpdateManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateManyMutationInput {
  Input$ExamUpdateManyMutationInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ExamUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ExamUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ExamUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateManyWithoutUserInput {
  Input$ExamUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ExamUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ExamCreateWithoutUserInput?>? create;

  final List<Input$ExamCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ExamUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ExamCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ExamWhereUniqueInput?>? $set;

  final List<Input$ExamWhereUniqueInput?>? disconnect;

  final List<Input$ExamWhereUniqueInput?>? delete;

  final List<Input$ExamWhereUniqueInput?>? connect;

  final List<Input$ExamUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ExamUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ExamScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ExamUpdateManyWithoutUserInput copyWith(
          {List<Input$ExamCreateWithoutUserInput?>? Function()? create,
          List<Input$ExamCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ExamUpsertWithWhereUniqueWithoutUserInput?>? Function()?
              upsert,
          Input$ExamCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ExamWhereUniqueInput?>? Function()? $set,
          List<Input$ExamWhereUniqueInput?>? Function()? disconnect,
          List<Input$ExamWhereUniqueInput?>? Function()? delete,
          List<Input$ExamWhereUniqueInput?>? Function()? connect,
          List<Input$ExamUpdateWithWhereUniqueWithoutUserInput?>? Function()?
              update,
          List<Input$ExamUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ExamScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ExamUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateManyWithWhereWithoutUserInput {
  Input$ExamUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ExamScalarWhereInput where;

  final Input$ExamUncheckedUpdateManyWithoutExaminationsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ExamScalarWhereInput? where,
          Input$ExamUncheckedUpdateManyWithoutExaminationsInput? data}) =>
      Input$ExamUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateOneRequiredWithoutExamAnswersInput {
  Input$ExamUpdateOneRequiredWithoutExamAnswersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ExamUpdateOneRequiredWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateOneRequiredWithoutExamAnswersInputFromJson(json);

  final Input$ExamUncheckedCreateWithoutExamAnswersInput? create;

  final Input$ExamCreateOrConnectWithoutExamAnswersInput? connectOrCreate;

  final Input$ExamUpsertWithoutExamAnswersInput? upsert;

  final Input$ExamWhereUniqueInput? connect;

  final Input$ExamUncheckedUpdateWithoutExamAnswersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateOneRequiredWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateOneRequiredWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ExamUpdateOneRequiredWithoutExamAnswersInput copyWith(
          {Input$ExamUncheckedCreateWithoutExamAnswersInput? Function()? create,
          Input$ExamCreateOrConnectWithoutExamAnswersInput? Function()?
              connectOrCreate,
          Input$ExamUpsertWithoutExamAnswersInput? Function()? upsert,
          Input$ExamWhereUniqueInput? Function()? connect,
          Input$ExamUncheckedUpdateWithoutExamAnswersInput? Function()?
              update}) =>
      Input$ExamUpdateOneRequiredWithoutExamAnswersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateOneRequiredWithoutExamquestionsInput {
  Input$ExamUpdateOneRequiredWithoutExamquestionsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ExamUpdateOneRequiredWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateOneRequiredWithoutExamquestionsInputFromJson(json);

  final Input$ExamUncheckedCreateWithoutExamquestionsInput? create;

  final Input$ExamCreateOrConnectWithoutExamquestionsInput? connectOrCreate;

  final Input$ExamUpsertWithoutExamquestionsInput? upsert;

  final Input$ExamWhereUniqueInput? connect;

  final Input$ExamUncheckedUpdateWithoutExamquestionsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateOneRequiredWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateOneRequiredWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ExamUpdateOneRequiredWithoutExamquestionsInput copyWith(
          {Input$ExamUncheckedCreateWithoutExamquestionsInput? Function()?
              create,
          Input$ExamCreateOrConnectWithoutExamquestionsInput? Function()?
              connectOrCreate,
          Input$ExamUpsertWithoutExamquestionsInput? Function()? upsert,
          Input$ExamWhereUniqueInput? Function()? connect,
          Input$ExamUncheckedUpdateWithoutExamquestionsInput? Function()?
              update}) =>
      Input$ExamUpdateOneRequiredWithoutExamquestionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateWithoutExamAnswersInput {
  Input$ExamUpdateWithoutExamAnswersInput(
      {this.id,
      this.name,
      this.user,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$ExamUpdateWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateWithoutExamAnswersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$UserUpdateOneRequiredWithoutExaminationsInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutExamInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll(
        [l$id, l$name, l$user, l$createdAt, l$updatedAt, l$examquestions]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$ExamUpdateWithoutExamAnswersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$UserUpdateOneRequiredWithoutExaminationsInput? Function()? user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutExamInput? Function()?
              examquestions}) =>
      Input$ExamUpdateWithoutExamAnswersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateWithoutExamquestionsInput {
  Input$ExamUpdateWithoutExamquestionsInput(
      {this.id,
      this.name,
      this.user,
      this.createdAt,
      this.updatedAt,
      this.examAnswers});

  @override
  factory Input$ExamUpdateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateWithoutExamquestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$UserUpdateOneRequiredWithoutExaminationsInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamAnswerUpdateManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examAnswers = examAnswers;
    return Object.hashAll(
        [l$id, l$name, l$user, l$createdAt, l$updatedAt, l$examAnswers]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUpdateWithoutExamquestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$UserUpdateOneRequiredWithoutExaminationsInput? Function()? user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamAnswerUpdateManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUpdateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateWithoutUserInput {
  Input$ExamUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutExamInput? examquestions;

  final Input$ExamAnswerUpdateManyWithoutExamInput? examAnswers;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$id,
      l$name,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutExamInput? Function()?
              examquestions,
          Input$ExamAnswerUpdateManyWithoutExamInput? Function()?
              examAnswers}) =>
      Input$ExamUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpdateWithWhereUniqueWithoutUserInput {
  Input$ExamUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ExamUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ExamWhereUniqueInput where;

  final Input$ExamUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ExamUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ExamWhereUniqueInput? where,
          Input$ExamUncheckedUpdateWithoutUserInput? data}) =>
      Input$ExamUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpsertWithoutExamAnswersInput {
  Input$ExamUpsertWithoutExamAnswersInput(
      {required this.update, required this.create});

  @override
  factory Input$ExamUpsertWithoutExamAnswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpsertWithoutExamAnswersInputFromJson(json);

  final Input$ExamUncheckedUpdateWithoutExamAnswersInput update;

  final Input$ExamUncheckedCreateWithoutExamAnswersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpsertWithoutExamAnswersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpsertWithoutExamAnswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamUpsertWithoutExamAnswersInput copyWith(
          {Input$ExamUncheckedUpdateWithoutExamAnswersInput? update,
          Input$ExamUncheckedCreateWithoutExamAnswersInput? create}) =>
      Input$ExamUpsertWithoutExamAnswersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpsertWithoutExamquestionsInput {
  Input$ExamUpsertWithoutExamquestionsInput(
      {required this.update, required this.create});

  @override
  factory Input$ExamUpsertWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpsertWithoutExamquestionsInputFromJson(json);

  final Input$ExamUncheckedUpdateWithoutExamquestionsInput update;

  final Input$ExamUncheckedCreateWithoutExamquestionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpsertWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpsertWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamUpsertWithoutExamquestionsInput copyWith(
          {Input$ExamUncheckedUpdateWithoutExamquestionsInput? update,
          Input$ExamUncheckedCreateWithoutExamquestionsInput? create}) =>
      Input$ExamUpsertWithoutExamquestionsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamUpsertWithWhereUniqueWithoutUserInput {
  Input$ExamUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ExamUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ExamUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ExamWhereUniqueInput where;

  final Input$ExamUncheckedUpdateWithoutUserInput update;

  final Input$ExamUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ExamUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ExamUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ExamWhereUniqueInput? where,
          Input$ExamUncheckedUpdateWithoutUserInput? update,
          Input$ExamUncheckedCreateWithoutUserInput? create}) =>
      Input$ExamUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ExamWhereInput {
  Input$ExamWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt,
      this.examquestions,
      this.examAnswers});

  @override
  factory Input$ExamWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamWhereInputFromJson(json);

  final List<Input$ExamWhereInput?>? AND;

  final List<Input$ExamWhereInput?>? OR;

  final List<Input$ExamWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ExamQuestionListRelationFilter? examquestions;

  final Input$ExamAnswerListRelationFilter? examAnswers;

  Map<String, dynamic> toJson() => _$Input$ExamWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    final l$examAnswers = examAnswers;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt,
      l$examquestions,
      l$examAnswers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    final l$examAnswers = examAnswers;
    final lOther$examAnswers = other.examAnswers;
    if (l$examAnswers != lOther$examAnswers) return false;
    return true;
  }

  Input$ExamWhereInput copyWith(
          {List<Input$ExamWhereInput?>? Function()? AND,
          List<Input$ExamWhereInput?>? Function()? OR,
          List<Input$ExamWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ExamQuestionListRelationFilter? Function()? examquestions,
          Input$ExamAnswerListRelationFilter? Function()? examAnswers}) =>
      Input$ExamWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions(),
          examAnswers: examAnswers == null ? this.examAnswers : examAnswers());
}

@JsonSerializable(explicitToJson: true)
class Input$ExamWhereUniqueInput {
  Input$ExamWhereUniqueInput({this.id});

  @override
  factory Input$ExamWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ExamWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() => _$Input$ExamWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ExamWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ExamWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ExamWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$FloatFieldUpdateOperationsInput {
  Input$FloatFieldUpdateOperationsInput(
      {this.$set, this.increment, this.decrement, this.multiply, this.divide});

  @override
  factory Input$FloatFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$FloatFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final double? $set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  Map<String, dynamic> toJson() =>
      _$Input$FloatFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll(
        [l$$set, l$increment, l$decrement, l$multiply, l$divide]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$FloatFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (l$increment != lOther$increment) return false;
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (l$decrement != lOther$decrement) return false;
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (l$multiply != lOther$multiply) return false;
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (l$divide != lOther$divide) return false;
    return true;
  }

  Input$FloatFieldUpdateOperationsInput copyWith(
          {double? Function()? $set,
          double? Function()? increment,
          double? Function()? decrement,
          double? Function()? multiply,
          double? Function()? divide}) =>
      Input$FloatFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set(),
          increment: increment == null ? this.increment : increment(),
          decrement: decrement == null ? this.decrement : decrement(),
          multiply: multiply == null ? this.multiply : multiply(),
          divide: divide == null ? this.divide : divide());
}

@JsonSerializable(explicitToJson: true)
class Input$FloatFilter {
  Input$FloatFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$FloatFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$FloatFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatFilter? not;

  Map<String, dynamic> toJson() => _$Input$FloatFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$FloatFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$FloatFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatFilter? Function()? not}) =>
      Input$FloatFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$FloatWithAggregatesFilter {
  Input$FloatWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$FloatWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$FloatWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedFloatFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedFloatFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedFloatFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$FloatWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$FloatWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$FloatWithAggregatesFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedFloatFilter? Function()? $_sum,
          Input$NestedFloatFilter? Function()? $_min,
          Input$NestedFloatFilter? Function()? $_max}) =>
      Input$FloatWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCountOrderByAggregateInput {
  Input$IdentityFileCountOrderByAggregateInput(
      {this.id, this.name, this.url, this.type, this.number, this.userId});

  @override
  factory Input$IdentityFileCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? number;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? number,
          Enum$SortOrder? Function()? userId}) =>
      Input$IdentityFileCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateInput {
  Input$IdentityFileCreateInput(
      {this.id,
      required this.name,
      required this.url,
      required this.type,
      required this.number,
      required this.user});

  @override
  factory Input$IdentityFileCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateInputFromJson(json);

  final String? id;

  final String name;

  final String url;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType type;

  final String number;

  final Input$UserCreateNestedOneWithoutIdentityFilesInput user;

  Map<String, dynamic> toJson() => _$Input$IdentityFileCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$user = user;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$user]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    return true;
  }

  Input$IdentityFileCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? url,
          Enum$IdentityFileType? type,
          String? number,
          Input$UserCreateNestedOneWithoutIdentityFilesInput? user}) =>
      Input$IdentityFileCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          url: url == null ? this.url : url,
          type: type == null ? this.type : type,
          number: number == null ? this.number : number,
          user: user == null ? this.user : user);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateManyInput {
  Input$IdentityFileCreateManyInput(
      {this.id,
      required this.name,
      required this.url,
      required this.type,
      required this.number,
      required this.userId});

  @override
  factory Input$IdentityFileCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String url;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType type;

  final String number;

  final String userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? url,
          Enum$IdentityFileType? type,
          String? number,
          String? userId}) =>
      Input$IdentityFileCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          url: url == null ? this.url : url,
          type: type == null ? this.type : type,
          number: number == null ? this.number : number,
          userId: userId == null ? this.userId : userId);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateManyUserInput {
  Input$IdentityFileCreateManyUserInput(
      {this.id,
      required this.name,
      required this.url,
      required this.type,
      required this.number});

  @override
  factory Input$IdentityFileCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateManyUserInputFromJson(json);

  final String? id;

  final String name;

  final String url;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType type;

  final String number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileCreateManyUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? url,
          Enum$IdentityFileType? type,
          String? number}) =>
      Input$IdentityFileCreateManyUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          url: url == null ? this.url : url,
          type: type == null ? this.type : type,
          number: number == null ? this.number : number);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateManyUserInputEnvelope {
  Input$IdentityFileCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$IdentityFileCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateManyUserInputEnvelopeFromJson(json);

  final Input$IdentityFileCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$IdentityFileCreateManyUserInputEnvelope copyWith(
          {Input$IdentityFileCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$IdentityFileCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateNestedManyWithoutUserInput {
  Input$IdentityFileCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$IdentityFileCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$IdentityFileCreateWithoutUserInput?>? create;

  final List<Input$IdentityFileCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$IdentityFileCreateManyUserInputEnvelope? createMany;

  final List<Input$IdentityFileWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$IdentityFileCreateNestedManyWithoutUserInput copyWith(
          {List<Input$IdentityFileCreateWithoutUserInput?>? Function()? create,
          List<Input$IdentityFileCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$IdentityFileCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? connect}) =>
      Input$IdentityFileCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateOrConnectWithoutUserInput {
  Input$IdentityFileCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$IdentityFileCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateOrConnectWithoutUserInputFromJson(json);

  final Input$IdentityFileWhereUniqueInput where;

  final Input$IdentityFileUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$IdentityFileCreateOrConnectWithoutUserInput copyWith(
          {Input$IdentityFileWhereUniqueInput? where,
          Input$IdentityFileUncheckedCreateWithoutUserInput? create}) =>
      Input$IdentityFileCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileCreateWithoutUserInput {
  Input$IdentityFileCreateWithoutUserInput(
      {this.id,
      required this.name,
      required this.url,
      required this.type,
      required this.number});

  @override
  factory Input$IdentityFileCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String url;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType type;

  final String number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? url,
          Enum$IdentityFileType? type,
          String? number}) =>
      Input$IdentityFileCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          url: url == null ? this.url : url,
          type: type == null ? this.type : type,
          number: number == null ? this.number : number);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileListRelationFilter {
  Input$IdentityFileListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$IdentityFileListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileListRelationFilterFromJson(json);

  final Input$IdentityFileWhereInput? every;

  final Input$IdentityFileWhereInput? some;

  final Input$IdentityFileWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$IdentityFileListRelationFilter copyWith(
          {Input$IdentityFileWhereInput? Function()? every,
          Input$IdentityFileWhereInput? Function()? some,
          Input$IdentityFileWhereInput? Function()? none}) =>
      Input$IdentityFileListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileMaxOrderByAggregateInput {
  Input$IdentityFileMaxOrderByAggregateInput(
      {this.id, this.name, this.url, this.type, this.number, this.userId});

  @override
  factory Input$IdentityFileMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? number;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? number,
          Enum$SortOrder? Function()? userId}) =>
      Input$IdentityFileMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileMinOrderByAggregateInput {
  Input$IdentityFileMinOrderByAggregateInput(
      {this.id, this.name, this.url, this.type, this.number, this.userId});

  @override
  factory Input$IdentityFileMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? number;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? number,
          Enum$SortOrder? Function()? userId}) =>
      Input$IdentityFileMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileOrderByRelationAggregateInput {
  Input$IdentityFileOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$IdentityFileOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$IdentityFileOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$IdentityFileOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileOrderByWithAggregationInput {
  Input$IdentityFileOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.url,
      this.type,
      this.number,
      this.userId,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$IdentityFileOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? number;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(name: '_count')
  final Input$IdentityFileCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$IdentityFileMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$IdentityFileMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$name,
      l$url,
      l$type,
      l$number,
      l$userId,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$IdentityFileOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? number,
          Enum$SortOrder? Function()? userId,
          Input$IdentityFileCountOrderByAggregateInput? Function()? $_count,
          Input$IdentityFileMaxOrderByAggregateInput? Function()? $_max,
          Input$IdentityFileMinOrderByAggregateInput? Function()? $_min}) =>
      Input$IdentityFileOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileOrderByWithRelationInput {
  Input$IdentityFileOrderByWithRelationInput(
      {this.id,
      this.name,
      this.url,
      this.type,
      this.number,
      this.userId,
      this.user});

  @override
  factory Input$IdentityFileOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? number;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    final l$user = user;
    return Object.hashAll(
        [l$id, l$name, l$url, l$type, l$number, l$userId, l$user]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    return true;
  }

  Input$IdentityFileOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? number,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user}) =>
      Input$IdentityFileOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileScalarWhereInput {
  Input$IdentityFileScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.url,
      this.type,
      this.number,
      this.userId});

  @override
  factory Input$IdentityFileScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileScalarWhereInputFromJson(json);

  final List<Input$IdentityFileScalarWhereInput?>? AND;

  final List<Input$IdentityFileScalarWhereInput?>? OR;

  final List<Input$IdentityFileScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? url;

  final Input$EnumIdentityFileTypeFilter? type;

  final Input$StringFilter? number;

  final Input$StringFilter? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$url,
      l$type,
      l$number,
      l$userId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileScalarWhereInput copyWith(
          {List<Input$IdentityFileScalarWhereInput?>? Function()? AND,
          List<Input$IdentityFileScalarWhereInput?>? Function()? OR,
          List<Input$IdentityFileScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? url,
          Input$EnumIdentityFileTypeFilter? Function()? type,
          Input$StringFilter? Function()? number,
          Input$StringFilter? Function()? userId}) =>
      Input$IdentityFileScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileScalarWhereWithAggregatesInput {
  Input$IdentityFileScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.url,
      this.type,
      this.number,
      this.userId});

  @override
  factory Input$IdentityFileScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$IdentityFileScalarWhereWithAggregatesInput?>? AND;

  final List<Input$IdentityFileScalarWhereWithAggregatesInput?>? OR;

  final List<Input$IdentityFileScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? url;

  final Input$EnumIdentityFileTypeWithAggregatesFilter? type;

  final Input$StringWithAggregatesFilter? number;

  final Input$StringWithAggregatesFilter? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$url,
      l$type,
      l$number,
      l$userId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileScalarWhereWithAggregatesInput copyWith(
          {List<Input$IdentityFileScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$IdentityFileScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$IdentityFileScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? url,
          Input$EnumIdentityFileTypeWithAggregatesFilter? Function()? type,
          Input$StringWithAggregatesFilter? Function()? number,
          Input$StringWithAggregatesFilter? Function()? userId}) =>
      Input$IdentityFileScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedCreateInput {
  Input$IdentityFileUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.url,
      required this.type,
      required this.number,
      required this.userId});

  @override
  factory Input$IdentityFileUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String url;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType type;

  final String number;

  final String userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? url,
          Enum$IdentityFileType? type,
          String? number,
          String? userId}) =>
      Input$IdentityFileUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          url: url == null ? this.url : url,
          type: type == null ? this.type : type,
          number: number == null ? this.number : number,
          userId: userId == null ? this.userId : userId);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput {
  Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$IdentityFileCreateWithoutUserInput?>? create;

  final List<Input$IdentityFileCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$IdentityFileCreateManyUserInputEnvelope? createMany;

  final List<Input$IdentityFileWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$IdentityFileCreateWithoutUserInput?>? Function()? create,
          List<Input$IdentityFileCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$IdentityFileCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? connect}) =>
      Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedCreateWithoutUserInput {
  Input$IdentityFileUncheckedCreateWithoutUserInput(
      {this.id,
      required this.name,
      required this.url,
      required this.type,
      required this.number});

  @override
  factory Input$IdentityFileUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  final String url;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType type;

  final String number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          String? url,
          Enum$IdentityFileType? type,
          String? number}) =>
      Input$IdentityFileUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          url: url == null ? this.url : url,
          type: type == null ? this.type : type,
          number: number == null ? this.number : number);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedUpdateInput {
  Input$IdentityFileUncheckedUpdateInput(
      {this.id, this.name, this.url, this.type, this.number, this.userId});

  @override
  factory Input$IdentityFileUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  final Input$StringFieldUpdateOperationsInput? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number,
          Input$StringFieldUpdateOperationsInput? Function()? userId}) =>
      Input$IdentityFileUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedUpdateManyInput {
  Input$IdentityFileUncheckedUpdateManyInput(
      {this.id, this.name, this.url, this.type, this.number, this.userId});

  @override
  factory Input$IdentityFileUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  final Input$StringFieldUpdateOperationsInput? userId;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$IdentityFileUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number,
          Input$StringFieldUpdateOperationsInput? Function()? userId}) =>
      Input$IdentityFileUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput {
  Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput(
      {this.id, this.name, this.url, this.type, this.number});

  @override
  factory Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number}) =>
      Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedUpdateManyWithoutUserInput {
  Input$IdentityFileUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$IdentityFileUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$IdentityFileCreateWithoutUserInput?>? create;

  final List<Input$IdentityFileCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$IdentityFileCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$IdentityFileWhereUniqueInput?>? $set;

  final List<Input$IdentityFileWhereUniqueInput?>? disconnect;

  final List<Input$IdentityFileWhereUniqueInput?>? delete;

  final List<Input$IdentityFileWhereUniqueInput?>? connect;

  final List<Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$IdentityFileUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$IdentityFileScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$IdentityFileUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$IdentityFileCreateWithoutUserInput?>? Function()? create,
          List<Input$IdentityFileCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$IdentityFileCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? $set,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? disconnect,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? delete,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? connect,
          List<Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$IdentityFileUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$IdentityFileScalarWhereInput?>? Function()? deleteMany}) =>
      Input$IdentityFileUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUncheckedUpdateWithoutUserInput {
  Input$IdentityFileUncheckedUpdateWithoutUserInput(
      {this.id, this.name, this.url, this.type, this.number});

  @override
  factory Input$IdentityFileUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number}) =>
      Input$IdentityFileUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpdateInput {
  Input$IdentityFileUpdateInput(
      {this.id, this.name, this.url, this.type, this.number, this.user});

  @override
  factory Input$IdentityFileUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$IdentityFileUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  final Input$UserUpdateOneRequiredWithoutIdentityFilesInput? user;

  Map<String, dynamic> toJson() => _$Input$IdentityFileUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$user = user;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number, l$user]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    return true;
  }

  Input$IdentityFileUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number,
          Input$UserUpdateOneRequiredWithoutIdentityFilesInput? Function()?
              user}) =>
      Input$IdentityFileUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          user: user == null ? this.user : user());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpdateManyMutationInput {
  Input$IdentityFileUpdateManyMutationInput(
      {this.id, this.name, this.url, this.type, this.number});

  @override
  factory Input$IdentityFileUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number}) =>
      Input$IdentityFileUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpdateManyWithoutUserInput {
  Input$IdentityFileUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$IdentityFileUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUpdateManyWithoutUserInputFromJson(json);

  final List<Input$IdentityFileCreateWithoutUserInput?>? create;

  final List<Input$IdentityFileCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$IdentityFileCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$IdentityFileWhereUniqueInput?>? $set;

  final List<Input$IdentityFileWhereUniqueInput?>? disconnect;

  final List<Input$IdentityFileWhereUniqueInput?>? delete;

  final List<Input$IdentityFileWhereUniqueInput?>? connect;

  final List<Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$IdentityFileUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$IdentityFileScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$IdentityFileUpdateManyWithoutUserInput copyWith(
          {List<Input$IdentityFileCreateWithoutUserInput?>? Function()? create,
          List<Input$IdentityFileCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$IdentityFileCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? $set,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? disconnect,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? delete,
          List<Input$IdentityFileWhereUniqueInput?>? Function()? connect,
          List<Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$IdentityFileUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$IdentityFileScalarWhereInput?>? Function()? deleteMany}) =>
      Input$IdentityFileUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpdateManyWithWhereWithoutUserInput {
  Input$IdentityFileUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$IdentityFileUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$IdentityFileScalarWhereInput where;

  final Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput data;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$IdentityFileUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$IdentityFileScalarWhereInput? where,
          Input$IdentityFileUncheckedUpdateManyWithoutIdentityFilesInput?
              data}) =>
      Input$IdentityFileUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpdateWithoutUserInput {
  Input$IdentityFileUpdateWithoutUserInput(
      {this.id, this.name, this.url, this.type, this.number});

  @override
  factory Input$IdentityFileUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$EnumIdentityFileTypeFieldUpdateOperationsInput? type;

  final Input$StringFieldUpdateOperationsInput? number;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    return Object.hashAll([l$id, l$name, l$url, l$type, l$number]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    return true;
  }

  Input$IdentityFileUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$EnumIdentityFileTypeFieldUpdateOperationsInput? Function()?
              type,
          Input$StringFieldUpdateOperationsInput? Function()? number}) =>
      Input$IdentityFileUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput {
  Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$IdentityFileWhereUniqueInput where;

  final Input$IdentityFileUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$IdentityFileWhereUniqueInput? where,
          Input$IdentityFileUncheckedUpdateWithoutUserInput? data}) =>
      Input$IdentityFileUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput {
  Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$IdentityFileWhereUniqueInput where;

  final Input$IdentityFileUncheckedUpdateWithoutUserInput update;

  final Input$IdentityFileUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$IdentityFileWhereUniqueInput? where,
          Input$IdentityFileUncheckedUpdateWithoutUserInput? update,
          Input$IdentityFileUncheckedCreateWithoutUserInput? create}) =>
      Input$IdentityFileUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileWhereInput {
  Input$IdentityFileWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.url,
      this.type,
      this.number,
      this.userId,
      this.user});

  @override
  factory Input$IdentityFileWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$IdentityFileWhereInputFromJson(json);

  final List<Input$IdentityFileWhereInput?>? AND;

  final List<Input$IdentityFileWhereInput?>? OR;

  final List<Input$IdentityFileWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? url;

  final Input$EnumIdentityFileTypeFilter? type;

  final Input$StringFilter? number;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  Map<String, dynamic> toJson() => _$Input$IdentityFileWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$type = type;
    final l$number = number;
    final l$userId = userId;
    final l$user = user;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$url,
      l$type,
      l$number,
      l$userId,
      l$user
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    return true;
  }

  Input$IdentityFileWhereInput copyWith(
          {List<Input$IdentityFileWhereInput?>? Function()? AND,
          List<Input$IdentityFileWhereInput?>? Function()? OR,
          List<Input$IdentityFileWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? url,
          Input$EnumIdentityFileTypeFilter? Function()? type,
          Input$StringFilter? Function()? number,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user}) =>
      Input$IdentityFileWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          type: type == null ? this.type : type(),
          number: number == null ? this.number : number(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user());
}

@JsonSerializable(explicitToJson: true)
class Input$IdentityFileWhereUniqueInput {
  Input$IdentityFileWhereUniqueInput({this.id});

  @override
  factory Input$IdentityFileWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IdentityFileWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$IdentityFileWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IdentityFileWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$IdentityFileWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$IdentityFileWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$IntFieldUpdateOperationsInput {
  Input$IntFieldUpdateOperationsInput(
      {this.$set, this.increment, this.decrement, this.multiply, this.divide});

  @override
  factory Input$IntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IntFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final int? $set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  Map<String, dynamic> toJson() =>
      _$Input$IntFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll(
        [l$$set, l$increment, l$decrement, l$multiply, l$divide]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (l$increment != lOther$increment) return false;
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (l$decrement != lOther$decrement) return false;
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (l$multiply != lOther$multiply) return false;
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (l$divide != lOther$divide) return false;
    return true;
  }

  Input$IntFieldUpdateOperationsInput copyWith(
          {int? Function()? $set,
          int? Function()? increment,
          int? Function()? decrement,
          int? Function()? multiply,
          int? Function()? divide}) =>
      Input$IntFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set(),
          increment: increment == null ? this.increment : increment(),
          decrement: decrement == null ? this.decrement : decrement(),
          multiply: multiply == null ? this.multiply : multiply(),
          divide: divide == null ? this.divide : divide());
}

@JsonSerializable(explicitToJson: true)
class Input$IntFilter {
  Input$IntFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$IntFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntFilter? not;

  Map<String, dynamic> toJson() => _$Input$IntFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$IntFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntFilter? Function()? not}) =>
      Input$IntFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$IntNullableFilter {
  Input$IntNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$IntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$IntNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntNullableFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$IntNullableFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableFilter? Function()? not}) =>
      Input$IntNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$IntNullableListFilter {
  Input$IntNullableListFilter(
      {this.equals, this.has, this.hasEvery, this.hasSome, this.isEmpty});

  @override
  factory Input$IntNullableListFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntNullableListFilterFromJson(json);

  final List<int?>? equals;

  final int? has;

  final List<int?>? hasEvery;

  final List<int?>? hasSome;

  final bool? isEmpty;

  Map<String, dynamic> toJson() => _$Input$IntNullableListFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$has = has;
    final l$hasEvery = hasEvery;
    final l$hasSome = hasSome;
    final l$isEmpty = isEmpty;
    return Object.hashAll([
      l$equals == null ? null : Object.hashAll(l$equals.map((v) => v)),
      l$has,
      l$hasEvery == null ? null : Object.hashAll(l$hasEvery.map((v) => v)),
      l$hasSome == null ? null : Object.hashAll(l$hasSome.map((v) => v)),
      l$isEmpty
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntNullableListFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != null && lOther$equals != null) {
      if (l$equals.length != lOther$equals.length) return false;
      for (int i = 0; i < l$equals.length; i++) {
        final l$equals$entry = l$equals[i];
        final lOther$equals$entry = lOther$equals[i];
        if (l$equals$entry != lOther$equals$entry) return false;
      }
    } else if (l$equals != lOther$equals) {
      return false;
    }

    final l$has = has;
    final lOther$has = other.has;
    if (l$has != lOther$has) return false;
    final l$hasEvery = hasEvery;
    final lOther$hasEvery = other.hasEvery;
    if (l$hasEvery != null && lOther$hasEvery != null) {
      if (l$hasEvery.length != lOther$hasEvery.length) return false;
      for (int i = 0; i < l$hasEvery.length; i++) {
        final l$hasEvery$entry = l$hasEvery[i];
        final lOther$hasEvery$entry = lOther$hasEvery[i];
        if (l$hasEvery$entry != lOther$hasEvery$entry) return false;
      }
    } else if (l$hasEvery != lOther$hasEvery) {
      return false;
    }

    final l$hasSome = hasSome;
    final lOther$hasSome = other.hasSome;
    if (l$hasSome != null && lOther$hasSome != null) {
      if (l$hasSome.length != lOther$hasSome.length) return false;
      for (int i = 0; i < l$hasSome.length; i++) {
        final l$hasSome$entry = l$hasSome[i];
        final lOther$hasSome$entry = lOther$hasSome[i];
        if (l$hasSome$entry != lOther$hasSome$entry) return false;
      }
    } else if (l$hasSome != lOther$hasSome) {
      return false;
    }

    final l$isEmpty = isEmpty;
    final lOther$isEmpty = other.isEmpty;
    if (l$isEmpty != lOther$isEmpty) return false;
    return true;
  }

  Input$IntNullableListFilter copyWith(
          {List<int?>? Function()? equals,
          int? Function()? has,
          List<int?>? Function()? hasEvery,
          List<int?>? Function()? hasSome,
          bool? Function()? isEmpty}) =>
      Input$IntNullableListFilter(
          equals: equals == null ? this.equals : equals(),
          has: has == null ? this.has : has(),
          hasEvery: hasEvery == null ? this.hasEvery : hasEvery(),
          hasSome: hasSome == null ? this.hasSome : hasSome(),
          isEmpty: isEmpty == null ? this.isEmpty : isEmpty());
}

@JsonSerializable(explicitToJson: true)
class Input$IntNullableWithAggregatesFilter {
  Input$IntNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$IntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatNullableFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntNullableFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$IntNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$IntNullableWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedFloatNullableFilter? Function()? $_avg,
          Input$NestedIntNullableFilter? Function()? $_sum,
          Input$NestedIntNullableFilter? Function()? $_min,
          Input$NestedIntNullableFilter? Function()? $_max}) =>
      Input$IntNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$IntWithAggregatesFilter {
  Input$IntWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$IntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntFilter? $_max;

  Map<String, dynamic> toJson() => _$Input$IntWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$IntWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedIntFilter? Function()? $_sum,
          Input$NestedIntFilter? Function()? $_min,
          Input$NestedIntFilter? Function()? $_max}) =>
      Input$IntWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedBoolFilter {
  Input$NestedBoolFilter({this.equals, this.not});

  @override
  factory Input$NestedBoolFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedBoolFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedBoolFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([l$equals, l$not]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedBoolFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedBoolFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolFilter? Function()? not}) =>
      Input$NestedBoolFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedBoolWithAggregatesFilter {
  Input$NestedBoolWithAggregatesFilter(
      {this.equals, this.not, this.$_count, this.$_min, this.$_max});

  @override
  factory Input$NestedBoolWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedBoolWithAggregatesFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedBoolFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedBoolFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedBoolWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([l$equals, l$not, l$$_count, l$$_min, l$$_max]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedBoolWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedBoolWithAggregatesFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedBoolFilter? Function()? $_min,
          Input$NestedBoolFilter? Function()? $_max}) =>
      Input$NestedBoolWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedDateTimeFilter {
  Input$NestedDateTimeFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedDateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedDateTimeFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedDateTimeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedDateTimeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedDateTimeFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeFilter? Function()? not}) =>
      Input$NestedDateTimeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedDateTimeNullableFilter {
  Input$NestedDateTimeNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedDateTimeNullableFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedDateTimeNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedDateTimeNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedDateTimeNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedDateTimeNullableFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeNullableFilter? Function()? not}) =>
      Input$NestedDateTimeNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedDateTimeNullableWithAggregatesFilter {
  Input$NestedDateTimeNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedDateTimeNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedDateTimeNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedDateTimeNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedDateTimeNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedDateTimeNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedDateTimeNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedDateTimeNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedDateTimeNullableFilter? Function()? $_min,
          Input$NestedDateTimeNullableFilter? Function()? $_max}) =>
      Input$NestedDateTimeNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedDateTimeWithAggregatesFilter {
  Input$NestedDateTimeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedDateTimeWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedDateTimeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedDateTimeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedDateTimeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedDateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedDateTimeWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedDateTimeFilter? Function()? $_min,
          Input$NestedDateTimeFilter? Function()? $_max}) =>
      Input$NestedDateTimeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumClassroomStudentStatusFilter {
  Input$NestedEnumClassroomStudentStatusFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumClassroomStudentStatusFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumClassroomStudentStatusFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? $in;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? notIn;

  final Input$NestedEnumClassroomStudentStatusFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumClassroomStudentStatusFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumClassroomStudentStatusFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumClassroomStudentStatusFilter copyWith(
          {Enum$ClassroomStudentStatus? Function()? equals,
          List<Enum$ClassroomStudentStatus?>? Function()? $in,
          List<Enum$ClassroomStudentStatus?>? Function()? notIn,
          Input$NestedEnumClassroomStudentStatusFilter? Function()? not}) =>
      Input$NestedEnumClassroomStudentStatusFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumClassroomStudentStatusWithAggregatesFilter {
  Input$NestedEnumClassroomStudentStatusWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumClassroomStudentStatusWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumClassroomStudentStatusWithAggregatesFilterFromJson(
          json);

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final Enum$ClassroomStudentStatus? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? $in;

  @JsonKey(unknownEnumValue: Enum$ClassroomStudentStatus.$unknown)
  final List<Enum$ClassroomStudentStatus?>? notIn;

  final Input$NestedEnumClassroomStudentStatusWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumClassroomStudentStatusFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumClassroomStudentStatusFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumClassroomStudentStatusWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$NestedEnumClassroomStudentStatusWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumClassroomStudentStatusWithAggregatesFilter copyWith(
          {Enum$ClassroomStudentStatus? Function()? equals,
          List<Enum$ClassroomStudentStatus?>? Function()? $in,
          List<Enum$ClassroomStudentStatus?>? Function()? notIn,
          Input$NestedEnumClassroomStudentStatusWithAggregatesFilter?
                  Function()?
              not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumClassroomStudentStatusFilter? Function()? $_min,
          Input$NestedEnumClassroomStudentStatusFilter? Function()? $_max}) =>
      Input$NestedEnumClassroomStudentStatusWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumContentTypeFilter {
  Input$NestedEnumContentTypeFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumContentTypeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumContentTypeFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? $in;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? notIn;

  final Input$NestedEnumContentTypeFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumContentTypeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumContentTypeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumContentTypeFilter copyWith(
          {Enum$ContentType? Function()? equals,
          List<Enum$ContentType?>? Function()? $in,
          List<Enum$ContentType?>? Function()? notIn,
          Input$NestedEnumContentTypeFilter? Function()? not}) =>
      Input$NestedEnumContentTypeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumContentTypeWithAggregatesFilter {
  Input$NestedEnumContentTypeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumContentTypeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumContentTypeWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? $in;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final List<Enum$ContentType?>? notIn;

  final Input$NestedEnumContentTypeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumContentTypeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumContentTypeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumContentTypeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumContentTypeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumContentTypeWithAggregatesFilter copyWith(
          {Enum$ContentType? Function()? equals,
          List<Enum$ContentType?>? Function()? $in,
          List<Enum$ContentType?>? Function()? notIn,
          Input$NestedEnumContentTypeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumContentTypeFilter? Function()? $_min,
          Input$NestedEnumContentTypeFilter? Function()? $_max}) =>
      Input$NestedEnumContentTypeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumIdentityFileTypeFilter {
  Input$NestedEnumIdentityFileTypeFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumIdentityFileTypeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumIdentityFileTypeFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? $in;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? notIn;

  final Input$NestedEnumIdentityFileTypeFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumIdentityFileTypeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumIdentityFileTypeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumIdentityFileTypeFilter copyWith(
          {Enum$IdentityFileType? Function()? equals,
          List<Enum$IdentityFileType?>? Function()? $in,
          List<Enum$IdentityFileType?>? Function()? notIn,
          Input$NestedEnumIdentityFileTypeFilter? Function()? not}) =>
      Input$NestedEnumIdentityFileTypeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumIdentityFileTypeWithAggregatesFilter {
  Input$NestedEnumIdentityFileTypeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumIdentityFileTypeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumIdentityFileTypeWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final Enum$IdentityFileType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? $in;

  @JsonKey(unknownEnumValue: Enum$IdentityFileType.$unknown)
  final List<Enum$IdentityFileType?>? notIn;

  final Input$NestedEnumIdentityFileTypeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumIdentityFileTypeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumIdentityFileTypeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumIdentityFileTypeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumIdentityFileTypeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumIdentityFileTypeWithAggregatesFilter copyWith(
          {Enum$IdentityFileType? Function()? equals,
          List<Enum$IdentityFileType?>? Function()? $in,
          List<Enum$IdentityFileType?>? Function()? notIn,
          Input$NestedEnumIdentityFileTypeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumIdentityFileTypeFilter? Function()? $_min,
          Input$NestedEnumIdentityFileTypeFilter? Function()? $_max}) =>
      Input$NestedEnumIdentityFileTypeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumQuestionTypeFilter {
  Input$NestedEnumQuestionTypeFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumQuestionTypeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumQuestionTypeFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? $in;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? notIn;

  final Input$NestedEnumQuestionTypeFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumQuestionTypeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumQuestionTypeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumQuestionTypeFilter copyWith(
          {Enum$QuestionType? Function()? equals,
          List<Enum$QuestionType?>? Function()? $in,
          List<Enum$QuestionType?>? Function()? notIn,
          Input$NestedEnumQuestionTypeFilter? Function()? not}) =>
      Input$NestedEnumQuestionTypeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumQuestionTypeWithAggregatesFilter {
  Input$NestedEnumQuestionTypeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumQuestionTypeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumQuestionTypeWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? $in;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final List<Enum$QuestionType?>? notIn;

  final Input$NestedEnumQuestionTypeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumQuestionTypeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumQuestionTypeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumQuestionTypeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumQuestionTypeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumQuestionTypeWithAggregatesFilter copyWith(
          {Enum$QuestionType? Function()? equals,
          List<Enum$QuestionType?>? Function()? $in,
          List<Enum$QuestionType?>? Function()? notIn,
          Input$NestedEnumQuestionTypeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumQuestionTypeFilter? Function()? $_min,
          Input$NestedEnumQuestionTypeFilter? Function()? $_max}) =>
      Input$NestedEnumQuestionTypeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumRolesFilter {
  Input$NestedEnumRolesFilter({this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumRolesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedEnumRolesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? $in;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? notIn;

  final Input$NestedEnumRolesFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedEnumRolesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumRolesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumRolesFilter copyWith(
          {Enum$Roles? Function()? equals,
          List<Enum$Roles?>? Function()? $in,
          List<Enum$Roles?>? Function()? notIn,
          Input$NestedEnumRolesFilter? Function()? not}) =>
      Input$NestedEnumRolesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumRolesWithAggregatesFilter {
  Input$NestedEnumRolesWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumRolesWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumRolesWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? $in;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final List<Enum$Roles?>? notIn;

  final Input$NestedEnumRolesWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumRolesFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumRolesFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumRolesWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumRolesWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumRolesWithAggregatesFilter copyWith(
          {Enum$Roles? Function()? equals,
          List<Enum$Roles?>? Function()? $in,
          List<Enum$Roles?>? Function()? notIn,
          Input$NestedEnumRolesWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumRolesFilter? Function()? $_min,
          Input$NestedEnumRolesFilter? Function()? $_max}) =>
      Input$NestedEnumRolesWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumVerifyTypeNullableFilter {
  Input$NestedEnumVerifyTypeNullableFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumVerifyTypeNullableFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumVerifyTypeNullableFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? $in;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? notIn;

  final Input$NestedEnumVerifyTypeNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumVerifyTypeNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumVerifyTypeNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumVerifyTypeNullableFilter copyWith(
          {Enum$VerifyType? Function()? equals,
          List<Enum$VerifyType?>? Function()? $in,
          List<Enum$VerifyType?>? Function()? notIn,
          Input$NestedEnumVerifyTypeNullableFilter? Function()? not}) =>
      Input$NestedEnumVerifyTypeNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumVerifyTypeNullableWithAggregatesFilter {
  Input$NestedEnumVerifyTypeNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumVerifyTypeNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumVerifyTypeNullableWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? $in;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final List<Enum$VerifyType?>? notIn;

  final Input$NestedEnumVerifyTypeNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumVerifyTypeNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumVerifyTypeNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumVerifyTypeNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumVerifyTypeNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumVerifyTypeNullableWithAggregatesFilter copyWith(
          {Enum$VerifyType? Function()? equals,
          List<Enum$VerifyType?>? Function()? $in,
          List<Enum$VerifyType?>? Function()? notIn,
          Input$NestedEnumVerifyTypeNullableWithAggregatesFilter? Function()?
              not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedEnumVerifyTypeNullableFilter? Function()? $_min,
          Input$NestedEnumVerifyTypeNullableFilter? Function()? $_max}) =>
      Input$NestedEnumVerifyTypeNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedFloatFilter {
  Input$NestedFloatFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedFloatFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedFloatFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedFloatFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedFloatFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedFloatFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatFilter? Function()? not}) =>
      Input$NestedFloatFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedFloatNullableFilter {
  Input$NestedFloatNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedFloatNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedFloatNullableFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedFloatNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedFloatNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedFloatNullableFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatNullableFilter? Function()? not}) =>
      Input$NestedFloatNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedFloatWithAggregatesFilter {
  Input$NestedFloatWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedFloatWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedFloatWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedFloatFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedFloatFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedFloatFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedFloatWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedFloatWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedFloatWithAggregatesFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedFloatFilter? Function()? $_sum,
          Input$NestedFloatFilter? Function()? $_min,
          Input$NestedFloatFilter? Function()? $_max}) =>
      Input$NestedFloatWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntFilter {
  Input$NestedIntFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedIntFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedIntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedIntFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedIntFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntFilter? Function()? not}) =>
      Input$NestedIntFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntNullableFilter {
  Input$NestedIntNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedIntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedIntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedIntNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedIntNullableFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableFilter? Function()? not}) =>
      Input$NestedIntNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntNullableWithAggregatesFilter {
  Input$NestedIntNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedIntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedIntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatNullableFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntNullableFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedIntNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedIntNullableWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedFloatNullableFilter? Function()? $_avg,
          Input$NestedIntNullableFilter? Function()? $_sum,
          Input$NestedIntNullableFilter? Function()? $_min,
          Input$NestedIntNullableFilter? Function()? $_max}) =>
      Input$NestedIntNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntWithAggregatesFilter {
  Input$NestedIntWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedIntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedIntWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedIntWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedIntFilter? Function()? $_sum,
          Input$NestedIntFilter? Function()? $_min,
          Input$NestedIntFilter? Function()? $_max}) =>
      Input$NestedIntWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringFilter {
  Input$NestedStringFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not});

  @override
  factory Input$NestedStringFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedStringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedStringFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedStringFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringFilter? Function()? not}) =>
      Input$NestedStringFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringNullableFilter {
  Input$NestedStringNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not});

  @override
  factory Input$NestedStringNullableFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedStringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedStringNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedStringNullableFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringNullableFilter? Function()? not}) =>
      Input$NestedStringNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringNullableWithAggregatesFilter {
  Input$NestedStringNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedStringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedStringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedStringNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedStringNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedStringNullableFilter? Function()? $_min,
          Input$NestedStringNullableFilter? Function()? $_max}) =>
      Input$NestedStringNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringWithAggregatesFilter {
  Input$NestedStringWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedStringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedStringWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedStringWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedStringFilter? Function()? $_min,
          Input$NestedStringFilter? Function()? $_max}) =>
      Input$NestedStringWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCountOrderByAggregateInput {
  Input$NotificationCountOrderByAggregateInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? picturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isRead;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpContext;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpData;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? picturePath,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? isRead,
          Enum$SortOrder? Function()? followUpContext,
          Enum$SortOrder? Function()? followUpData,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$NotificationCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateInput {
  Input$NotificationCreateInput(
      {this.id,
      this.picturePath,
      required this.title,
      required this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      required this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$NotificationCreateInputFromJson(json);

  final String? id;

  final String? picturePath;

  final String title;

  final String message;

  final bool? isRead;

  final String? followUpContext;

  final String? followUpData;

  final Input$UserCreateNestedOneWithoutNotificationsInput user;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$NotificationCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationCreateInput copyWith(
          {String? Function()? id,
          String? Function()? picturePath,
          String? title,
          String? message,
          bool? Function()? isRead,
          String? Function()? followUpContext,
          String? Function()? followUpData,
          Input$UserCreateNestedOneWithoutNotificationsInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$NotificationCreateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title,
          message: message == null ? this.message : message,
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateManyInput {
  Input$NotificationCreateManyInput(
      {this.id,
      this.picturePath,
      required this.title,
      required this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCreateManyInputFromJson(json);

  final String? id;

  final String? picturePath;

  final String title;

  final String message;

  final bool? isRead;

  final String? followUpContext;

  final String? followUpData;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationCreateManyInput copyWith(
          {String? Function()? id,
          String? Function()? picturePath,
          String? title,
          String? message,
          bool? Function()? isRead,
          String? Function()? followUpContext,
          String? Function()? followUpData,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$NotificationCreateManyInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title,
          message: message == null ? this.message : message,
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateManyUserInput {
  Input$NotificationCreateManyUserInput(
      {this.id,
      this.picturePath,
      required this.title,
      required this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCreateManyUserInputFromJson(json);

  final String? id;

  final String? picturePath;

  final String title;

  final String message;

  final bool? isRead;

  final String? followUpContext;

  final String? followUpData;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationCreateManyUserInput copyWith(
          {String? Function()? id,
          String? Function()? picturePath,
          String? title,
          String? message,
          bool? Function()? isRead,
          String? Function()? followUpContext,
          String? Function()? followUpData,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$NotificationCreateManyUserInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title,
          message: message == null ? this.message : message,
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateManyUserInputEnvelope {
  Input$NotificationCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$NotificationCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCreateManyUserInputEnvelopeFromJson(json);

  final Input$NotificationCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$NotificationCreateManyUserInputEnvelope copyWith(
          {Input$NotificationCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$NotificationCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateNestedManyWithoutUserInput {
  Input$NotificationCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$NotificationCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$NotificationCreateWithoutUserInput?>? create;

  final List<Input$NotificationCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$NotificationCreateManyUserInputEnvelope? createMany;

  final List<Input$NotificationWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$NotificationCreateNestedManyWithoutUserInput copyWith(
          {List<Input$NotificationCreateWithoutUserInput?>? Function()? create,
          List<Input$NotificationCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$NotificationCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$NotificationWhereUniqueInput?>? Function()? connect}) =>
      Input$NotificationCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateOrConnectWithoutUserInput {
  Input$NotificationCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$NotificationCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCreateOrConnectWithoutUserInputFromJson(json);

  final Input$NotificationWhereUniqueInput where;

  final Input$NotificationUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$NotificationCreateOrConnectWithoutUserInput copyWith(
          {Input$NotificationWhereUniqueInput? where,
          Input$NotificationUncheckedCreateWithoutUserInput? create}) =>
      Input$NotificationCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationCreateWithoutUserInput {
  Input$NotificationCreateWithoutUserInput(
      {this.id,
      this.picturePath,
      required this.title,
      required this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationCreateWithoutUserInputFromJson(json);

  final String? id;

  final String? picturePath;

  final String title;

  final String message;

  final bool? isRead;

  final String? followUpContext;

  final String? followUpData;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? Function()? picturePath,
          String? title,
          String? message,
          bool? Function()? isRead,
          String? Function()? followUpContext,
          String? Function()? followUpData,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$NotificationCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title,
          message: message == null ? this.message : message,
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationListRelationFilter {
  Input$NotificationListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$NotificationListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationListRelationFilterFromJson(json);

  final Input$NotificationWhereInput? every;

  final Input$NotificationWhereInput? some;

  final Input$NotificationWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$NotificationListRelationFilter copyWith(
          {Input$NotificationWhereInput? Function()? every,
          Input$NotificationWhereInput? Function()? some,
          Input$NotificationWhereInput? Function()? none}) =>
      Input$NotificationListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationMaxOrderByAggregateInput {
  Input$NotificationMaxOrderByAggregateInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? picturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isRead;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpContext;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpData;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? picturePath,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? isRead,
          Enum$SortOrder? Function()? followUpContext,
          Enum$SortOrder? Function()? followUpData,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$NotificationMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationMinOrderByAggregateInput {
  Input$NotificationMinOrderByAggregateInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? picturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isRead;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpContext;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpData;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? picturePath,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? isRead,
          Enum$SortOrder? Function()? followUpContext,
          Enum$SortOrder? Function()? followUpData,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$NotificationMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationOrderByRelationAggregateInput {
  Input$NotificationOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$NotificationOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$NotificationOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$NotificationOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationOrderByWithAggregationInput {
  Input$NotificationOrderByWithAggregationInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$NotificationOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? picturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isRead;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpContext;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpData;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$NotificationCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$NotificationMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$NotificationMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$NotificationOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? picturePath,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? isRead,
          Enum$SortOrder? Function()? followUpContext,
          Enum$SortOrder? Function()? followUpData,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$NotificationCountOrderByAggregateInput? Function()? $_count,
          Input$NotificationMaxOrderByAggregateInput? Function()? $_max,
          Input$NotificationMinOrderByAggregateInput? Function()? $_min}) =>
      Input$NotificationOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationOrderByWithRelationInput {
  Input$NotificationOrderByWithRelationInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? picturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isRead;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpContext;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? followUpData;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? picturePath,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? isRead,
          Enum$SortOrder? Function()? followUpContext,
          Enum$SortOrder? Function()? followUpData,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$NotificationOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationScalarWhereInput {
  Input$NotificationScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationScalarWhereInputFromJson(json);

  final List<Input$NotificationScalarWhereInput?>? AND;

  final List<Input$NotificationScalarWhereInput?>? OR;

  final List<Input$NotificationScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringNullableFilter? picturePath;

  final Input$StringFilter? title;

  final Input$StringFilter? message;

  final Input$BoolFilter? isRead;

  final Input$StringNullableFilter? followUpContext;

  final Input$StringNullableFilter? followUpData;

  final Input$StringFilter? userId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationScalarWhereInput copyWith(
          {List<Input$NotificationScalarWhereInput?>? Function()? AND,
          List<Input$NotificationScalarWhereInput?>? Function()? OR,
          List<Input$NotificationScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringNullableFilter? Function()? picturePath,
          Input$StringFilter? Function()? title,
          Input$StringFilter? Function()? message,
          Input$BoolFilter? Function()? isRead,
          Input$StringNullableFilter? Function()? followUpContext,
          Input$StringNullableFilter? Function()? followUpData,
          Input$StringFilter? Function()? userId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$NotificationScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationScalarWhereWithAggregatesInput {
  Input$NotificationScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$NotificationScalarWhereWithAggregatesInput?>? AND;

  final List<Input$NotificationScalarWhereWithAggregatesInput?>? OR;

  final List<Input$NotificationScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringNullableWithAggregatesFilter? picturePath;

  final Input$StringWithAggregatesFilter? title;

  final Input$StringWithAggregatesFilter? message;

  final Input$BoolWithAggregatesFilter? isRead;

  final Input$StringNullableWithAggregatesFilter? followUpContext;

  final Input$StringNullableWithAggregatesFilter? followUpData;

  final Input$StringWithAggregatesFilter? userId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationScalarWhereWithAggregatesInput copyWith(
          {List<Input$NotificationScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$NotificationScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$NotificationScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringNullableWithAggregatesFilter? Function()? picturePath,
          Input$StringWithAggregatesFilter? Function()? title,
          Input$StringWithAggregatesFilter? Function()? message,
          Input$BoolWithAggregatesFilter? Function()? isRead,
          Input$StringNullableWithAggregatesFilter? Function()? followUpContext,
          Input$StringNullableWithAggregatesFilter? Function()? followUpData,
          Input$StringWithAggregatesFilter? Function()? userId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$NotificationScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedCreateInput {
  Input$NotificationUncheckedCreateInput(
      {this.id,
      this.picturePath,
      required this.title,
      required this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedCreateInputFromJson(json);

  final String? id;

  final String? picturePath;

  final String title;

  final String message;

  final bool? isRead;

  final String? followUpContext;

  final String? followUpData;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? Function()? picturePath,
          String? title,
          String? message,
          bool? Function()? isRead,
          String? Function()? followUpContext,
          String? Function()? followUpData,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$NotificationUncheckedCreateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title,
          message: message == null ? this.message : message,
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedCreateNestedManyWithoutUserInput {
  Input$NotificationUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$NotificationUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$NotificationCreateWithoutUserInput?>? create;

  final List<Input$NotificationCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$NotificationCreateManyUserInputEnvelope? createMany;

  final List<Input$NotificationWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$NotificationUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$NotificationUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$NotificationCreateWithoutUserInput?>? Function()? create,
          List<Input$NotificationCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$NotificationCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$NotificationWhereUniqueInput?>? Function()? connect}) =>
      Input$NotificationUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedCreateWithoutUserInput {
  Input$NotificationUncheckedCreateWithoutUserInput(
      {this.id,
      this.picturePath,
      required this.title,
      required this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String? picturePath;

  final String title;

  final String message;

  final bool? isRead;

  final String? followUpContext;

  final String? followUpData;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? Function()? picturePath,
          String? title,
          String? message,
          bool? Function()? isRead,
          String? Function()? followUpContext,
          String? Function()? followUpData,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$NotificationUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title,
          message: message == null ? this.message : message,
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedUpdateInput {
  Input$NotificationUncheckedUpdateInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedUpdateManyInput {
  Input$NotificationUncheckedUpdateManyInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedUpdateManyWithoutNotificationsInput {
  Input$NotificationUncheckedUpdateManyWithoutNotificationsInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUncheckedUpdateManyWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedUpdateManyWithoutNotificationsInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedUpdateManyWithoutNotificationsInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$NotificationUncheckedUpdateManyWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUncheckedUpdateManyWithoutNotificationsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUncheckedUpdateManyWithoutNotificationsInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedUpdateManyWithoutUserInput {
  Input$NotificationUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$NotificationUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$NotificationCreateWithoutUserInput?>? create;

  final List<Input$NotificationCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$NotificationUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$NotificationCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$NotificationWhereUniqueInput?>? $set;

  final List<Input$NotificationWhereUniqueInput?>? disconnect;

  final List<Input$NotificationWhereUniqueInput?>? delete;

  final List<Input$NotificationWhereUniqueInput?>? connect;

  final List<Input$NotificationUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$NotificationUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$NotificationScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$NotificationUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$NotificationCreateWithoutUserInput?>? Function()? create,
          List<Input$NotificationCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$NotificationUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$NotificationCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$NotificationWhereUniqueInput?>? Function()? $set,
          List<Input$NotificationWhereUniqueInput?>? Function()? disconnect,
          List<Input$NotificationWhereUniqueInput?>? Function()? delete,
          List<Input$NotificationWhereUniqueInput?>? Function()? connect,
          List<Input$NotificationUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$NotificationUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$NotificationScalarWhereInput?>? Function()? deleteMany}) =>
      Input$NotificationUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUncheckedUpdateWithoutUserInput {
  Input$NotificationUncheckedUpdateWithoutUserInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpdateInput {
  Input$NotificationUpdateInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$NotificationUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$UserUpdateOneRequiredWithoutNotificationsInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$NotificationUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$UserUpdateOneRequiredWithoutNotificationsInput? Function()?
              user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUpdateInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpdateManyMutationInput {
  Input$NotificationUpdateManyMutationInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpdateManyWithoutUserInput {
  Input$NotificationUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$NotificationUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUpdateManyWithoutUserInputFromJson(json);

  final List<Input$NotificationCreateWithoutUserInput?>? create;

  final List<Input$NotificationCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$NotificationUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$NotificationCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$NotificationWhereUniqueInput?>? $set;

  final List<Input$NotificationWhereUniqueInput?>? disconnect;

  final List<Input$NotificationWhereUniqueInput?>? delete;

  final List<Input$NotificationWhereUniqueInput?>? connect;

  final List<Input$NotificationUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$NotificationUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$NotificationScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$NotificationUpdateManyWithoutUserInput copyWith(
          {List<Input$NotificationCreateWithoutUserInput?>? Function()? create,
          List<Input$NotificationCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$NotificationUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$NotificationCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$NotificationWhereUniqueInput?>? Function()? $set,
          List<Input$NotificationWhereUniqueInput?>? Function()? disconnect,
          List<Input$NotificationWhereUniqueInput?>? Function()? delete,
          List<Input$NotificationWhereUniqueInput?>? Function()? connect,
          List<Input$NotificationUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$NotificationUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$NotificationScalarWhereInput?>? Function()? deleteMany}) =>
      Input$NotificationUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpdateManyWithWhereWithoutUserInput {
  Input$NotificationUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$NotificationUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$NotificationScalarWhereInput where;

  final Input$NotificationUncheckedUpdateManyWithoutNotificationsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$NotificationUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$NotificationScalarWhereInput? where,
          Input$NotificationUncheckedUpdateManyWithoutNotificationsInput?
              data}) =>
      Input$NotificationUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpdateWithoutUserInput {
  Input$NotificationUpdateWithoutUserInput(
      {this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$NullableStringFieldUpdateOperationsInput? picturePath;

  final Input$StringFieldUpdateOperationsInput? title;

  final Input$StringFieldUpdateOperationsInput? message;

  final Input$BoolFieldUpdateOperationsInput? isRead;

  final Input$NullableStringFieldUpdateOperationsInput? followUpContext;

  final Input$NullableStringFieldUpdateOperationsInput? followUpData;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              picturePath,
          Input$StringFieldUpdateOperationsInput? Function()? title,
          Input$StringFieldUpdateOperationsInput? Function()? message,
          Input$BoolFieldUpdateOperationsInput? Function()? isRead,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpContext,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              followUpData,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$NotificationUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpdateWithWhereUniqueWithoutUserInput {
  Input$NotificationUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$NotificationUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$NotificationWhereUniqueInput where;

  final Input$NotificationUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$NotificationUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$NotificationWhereUniqueInput? where,
          Input$NotificationUncheckedUpdateWithoutUserInput? data}) =>
      Input$NotificationUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationUpsertWithWhereUniqueWithoutUserInput {
  Input$NotificationUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$NotificationUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$NotificationWhereUniqueInput where;

  final Input$NotificationUncheckedUpdateWithoutUserInput update;

  final Input$NotificationUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$NotificationUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$NotificationWhereUniqueInput? where,
          Input$NotificationUncheckedUpdateWithoutUserInput? update,
          Input$NotificationUncheckedCreateWithoutUserInput? create}) =>
      Input$NotificationUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationWhereInput {
  Input$NotificationWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.picturePath,
      this.title,
      this.message,
      this.isRead,
      this.followUpContext,
      this.followUpData,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$NotificationWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$NotificationWhereInputFromJson(json);

  final List<Input$NotificationWhereInput?>? AND;

  final List<Input$NotificationWhereInput?>? OR;

  final List<Input$NotificationWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringNullableFilter? picturePath;

  final Input$StringFilter? title;

  final Input$StringFilter? message;

  final Input$BoolFilter? isRead;

  final Input$StringNullableFilter? followUpContext;

  final Input$StringNullableFilter? followUpData;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$NotificationWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$picturePath = picturePath;
    final l$title = title;
    final l$message = message;
    final l$isRead = isRead;
    final l$followUpContext = followUpContext;
    final l$followUpData = followUpData;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$picturePath,
      l$title,
      l$message,
      l$isRead,
      l$followUpContext,
      l$followUpData,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$picturePath = picturePath;
    final lOther$picturePath = other.picturePath;
    if (l$picturePath != lOther$picturePath) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (l$isRead != lOther$isRead) return false;
    final l$followUpContext = followUpContext;
    final lOther$followUpContext = other.followUpContext;
    if (l$followUpContext != lOther$followUpContext) return false;
    final l$followUpData = followUpData;
    final lOther$followUpData = other.followUpData;
    if (l$followUpData != lOther$followUpData) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$NotificationWhereInput copyWith(
          {List<Input$NotificationWhereInput?>? Function()? AND,
          List<Input$NotificationWhereInput?>? Function()? OR,
          List<Input$NotificationWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringNullableFilter? Function()? picturePath,
          Input$StringFilter? Function()? title,
          Input$StringFilter? Function()? message,
          Input$BoolFilter? Function()? isRead,
          Input$StringNullableFilter? Function()? followUpContext,
          Input$StringNullableFilter? Function()? followUpData,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$NotificationWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          picturePath: picturePath == null ? this.picturePath : picturePath(),
          title: title == null ? this.title : title(),
          message: message == null ? this.message : message(),
          isRead: isRead == null ? this.isRead : isRead(),
          followUpContext: followUpContext == null
              ? this.followUpContext
              : followUpContext(),
          followUpData:
              followUpData == null ? this.followUpData : followUpData(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$NotificationWhereUniqueInput {
  Input$NotificationWhereUniqueInput({this.id});

  @override
  factory Input$NotificationWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NotificationWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$NotificationWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NotificationWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$NotificationWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$NotificationWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$NullableDateTimeFieldUpdateOperationsInput {
  Input$NullableDateTimeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NullableDateTimeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$NullableDateTimeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NullableDateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$NullableDateTimeFieldUpdateOperationsInput copyWith(
          {String? Function()? $set}) =>
      Input$NullableDateTimeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$NullableEnumVerifyTypeFieldUpdateOperationsInput {
  Input$NullableEnumVerifyTypeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$NullableEnumVerifyTypeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NullableEnumVerifyTypeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? $set;

  Map<String, dynamic> toJson() =>
      _$Input$NullableEnumVerifyTypeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NullableEnumVerifyTypeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$NullableEnumVerifyTypeFieldUpdateOperationsInput copyWith(
          {Enum$VerifyType? Function()? $set}) =>
      Input$NullableEnumVerifyTypeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$NullableIntFieldUpdateOperationsInput {
  Input$NullableIntFieldUpdateOperationsInput(
      {this.$set, this.increment, this.decrement, this.multiply, this.divide});

  @override
  factory Input$NullableIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NullableIntFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final int? $set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  Map<String, dynamic> toJson() =>
      _$Input$NullableIntFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll(
        [l$$set, l$increment, l$decrement, l$multiply, l$divide]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NullableIntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (l$increment != lOther$increment) return false;
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (l$decrement != lOther$decrement) return false;
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (l$multiply != lOther$multiply) return false;
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (l$divide != lOther$divide) return false;
    return true;
  }

  Input$NullableIntFieldUpdateOperationsInput copyWith(
          {int? Function()? $set,
          int? Function()? increment,
          int? Function()? decrement,
          int? Function()? multiply,
          int? Function()? divide}) =>
      Input$NullableIntFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set(),
          increment: increment == null ? this.increment : increment(),
          decrement: decrement == null ? this.decrement : decrement(),
          multiply: multiply == null ? this.multiply : multiply(),
          divide: divide == null ? this.divide : divide());
}

@JsonSerializable(explicitToJson: true)
class Input$NullableStringFieldUpdateOperationsInput {
  Input$NullableStringFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$NullableStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NullableStringFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$NullableStringFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NullableStringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$NullableStringFieldUpdateOperationsInput copyWith(
          {String? Function()? $set}) =>
      Input$NullableStringFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCountOrderByAggregateInput {
  Input$ProvinceCountOrderByAggregateInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ProvinceCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ProvinceCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateInput {
  Input$ProvinceCreateInput(
      {this.id,
      required this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ProvinceCreateInputFromJson(json);

  final String? id;

  final String name;

  final Input$RegencyCreateNestedManyWithoutProvinceInput? regencies;

  final String? createdAt;

  final String? updatedAt;

  final Input$UserCreateNestedManyWithoutProvinceInput? users;

  final Input$SchoolCreateNestedManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() => _$Input$ProvinceCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$id,
      l$name,
      l$regencies,
      l$createdAt,
      l$updatedAt,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Input$RegencyCreateNestedManyWithoutProvinceInput? Function()?
              regencies,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$UserCreateNestedManyWithoutProvinceInput? Function()? users,
          Input$SchoolCreateNestedManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateManyInput {
  Input$ProvinceCreateManyInput(
      {this.id, required this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ProvinceCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ProvinceCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ProvinceCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ProvinceCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateNestedOneWithoutRegenciesInput {
  Input$ProvinceCreateNestedOneWithoutRegenciesInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ProvinceCreateNestedOneWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateNestedOneWithoutRegenciesInputFromJson(json);

  final Input$ProvinceUncheckedCreateWithoutRegenciesInput? create;

  final Input$ProvinceCreateOrConnectWithoutRegenciesInput? connectOrCreate;

  final Input$ProvinceWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateNestedOneWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateNestedOneWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ProvinceCreateNestedOneWithoutRegenciesInput copyWith(
          {Input$ProvinceUncheckedCreateWithoutRegenciesInput? Function()?
              create,
          Input$ProvinceCreateOrConnectWithoutRegenciesInput? Function()?
              connectOrCreate,
          Input$ProvinceWhereUniqueInput? Function()? connect}) =>
      Input$ProvinceCreateNestedOneWithoutRegenciesInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateNestedOneWithoutSchoolInput {
  Input$ProvinceCreateNestedOneWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ProvinceCreateNestedOneWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateNestedOneWithoutSchoolInputFromJson(json);

  final Input$ProvinceUncheckedCreateWithoutSchoolInput? create;

  final Input$ProvinceCreateOrConnectWithoutSchoolInput? connectOrCreate;

  final Input$ProvinceWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateNestedOneWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateNestedOneWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ProvinceCreateNestedOneWithoutSchoolInput copyWith(
          {Input$ProvinceUncheckedCreateWithoutSchoolInput? Function()? create,
          Input$ProvinceCreateOrConnectWithoutSchoolInput? Function()?
              connectOrCreate,
          Input$ProvinceWhereUniqueInput? Function()? connect}) =>
      Input$ProvinceCreateNestedOneWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateNestedOneWithoutUsersInput {
  Input$ProvinceCreateNestedOneWithoutUsersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ProvinceCreateNestedOneWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateNestedOneWithoutUsersInputFromJson(json);

  final Input$ProvinceUncheckedCreateWithoutUsersInput? create;

  final Input$ProvinceCreateOrConnectWithoutUsersInput? connectOrCreate;

  final Input$ProvinceWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateNestedOneWithoutUsersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateNestedOneWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ProvinceCreateNestedOneWithoutUsersInput copyWith(
          {Input$ProvinceUncheckedCreateWithoutUsersInput? Function()? create,
          Input$ProvinceCreateOrConnectWithoutUsersInput? Function()?
              connectOrCreate,
          Input$ProvinceWhereUniqueInput? Function()? connect}) =>
      Input$ProvinceCreateNestedOneWithoutUsersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateOrConnectWithoutRegenciesInput {
  Input$ProvinceCreateOrConnectWithoutRegenciesInput(
      {required this.where, required this.create});

  @override
  factory Input$ProvinceCreateOrConnectWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateOrConnectWithoutRegenciesInputFromJson(json);

  final Input$ProvinceWhereUniqueInput where;

  final Input$ProvinceUncheckedCreateWithoutRegenciesInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateOrConnectWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateOrConnectWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ProvinceCreateOrConnectWithoutRegenciesInput copyWith(
          {Input$ProvinceWhereUniqueInput? where,
          Input$ProvinceUncheckedCreateWithoutRegenciesInput? create}) =>
      Input$ProvinceCreateOrConnectWithoutRegenciesInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateOrConnectWithoutSchoolInput {
  Input$ProvinceCreateOrConnectWithoutSchoolInput(
      {required this.where, required this.create});

  @override
  factory Input$ProvinceCreateOrConnectWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateOrConnectWithoutSchoolInputFromJson(json);

  final Input$ProvinceWhereUniqueInput where;

  final Input$ProvinceUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateOrConnectWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateOrConnectWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ProvinceCreateOrConnectWithoutSchoolInput copyWith(
          {Input$ProvinceWhereUniqueInput? where,
          Input$ProvinceUncheckedCreateWithoutSchoolInput? create}) =>
      Input$ProvinceCreateOrConnectWithoutSchoolInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateOrConnectWithoutUsersInput {
  Input$ProvinceCreateOrConnectWithoutUsersInput(
      {required this.where, required this.create});

  @override
  factory Input$ProvinceCreateOrConnectWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateOrConnectWithoutUsersInputFromJson(json);

  final Input$ProvinceWhereUniqueInput where;

  final Input$ProvinceUncheckedCreateWithoutUsersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateOrConnectWithoutUsersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateOrConnectWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ProvinceCreateOrConnectWithoutUsersInput copyWith(
          {Input$ProvinceWhereUniqueInput? where,
          Input$ProvinceUncheckedCreateWithoutUsersInput? create}) =>
      Input$ProvinceCreateOrConnectWithoutUsersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateWithoutRegenciesInput {
  Input$ProvinceCreateWithoutRegenciesInput(
      {this.id,
      required this.name,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceCreateWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateWithoutRegenciesInputFromJson(json);

  final String? id;

  final String name;

  final String? createdAt;

  final String? updatedAt;

  final Input$UserCreateNestedManyWithoutProvinceInput? users;

  final Input$SchoolCreateNestedManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$createdAt, l$updatedAt, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceCreateWithoutRegenciesInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$UserCreateNestedManyWithoutProvinceInput? Function()? users,
          Input$SchoolCreateNestedManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceCreateWithoutRegenciesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateWithoutSchoolInput {
  Input$ProvinceCreateWithoutSchoolInput(
      {this.id,
      required this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users});

  @override
  factory Input$ProvinceCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final Input$RegencyCreateNestedManyWithoutProvinceInput? regencies;

  final String? createdAt;

  final String? updatedAt;

  final Input$UserCreateNestedManyWithoutProvinceInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$ProvinceCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          Input$RegencyCreateNestedManyWithoutProvinceInput? Function()?
              regencies,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$UserCreateNestedManyWithoutProvinceInput? Function()? users}) =>
      Input$ProvinceCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceCreateWithoutUsersInput {
  Input$ProvinceCreateWithoutUsersInput(
      {this.id,
      required this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.School});

  @override
  factory Input$ProvinceCreateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceCreateWithoutUsersInputFromJson(json);

  final String? id;

  final String name;

  final Input$RegencyCreateNestedManyWithoutProvinceInput? regencies;

  final String? createdAt;

  final String? updatedAt;

  final Input$SchoolCreateNestedManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceCreateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceCreateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceCreateWithoutUsersInput copyWith(
          {String? Function()? id,
          String? name,
          Input$RegencyCreateNestedManyWithoutProvinceInput? Function()?
              regencies,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$SchoolCreateNestedManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceCreateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceMaxOrderByAggregateInput {
  Input$ProvinceMaxOrderByAggregateInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ProvinceMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ProvinceMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceMinOrderByAggregateInput {
  Input$ProvinceMinOrderByAggregateInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ProvinceMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ProvinceMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceOrderByWithAggregationInput {
  Input$ProvinceOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$ProvinceOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ProvinceCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$ProvinceMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ProvinceMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll(
        [l$id, l$name, l$createdAt, l$updatedAt, l$$_count, l$$_max, l$$_min]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$ProvinceOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ProvinceCountOrderByAggregateInput? Function()? $_count,
          Input$ProvinceMaxOrderByAggregateInput? Function()? $_max,
          Input$ProvinceMinOrderByAggregateInput? Function()? $_min}) =>
      Input$ProvinceOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceOrderByWithRelationInput {
  Input$ProvinceOrderByWithRelationInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  final Input$RegencyOrderByRelationAggregateInput? regencies;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$UserOrderByRelationAggregateInput? users;

  final Input$SchoolOrderByRelationAggregateInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$id,
      l$name,
      l$regencies,
      l$createdAt,
      l$updatedAt,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Input$RegencyOrderByRelationAggregateInput? Function()? regencies,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$UserOrderByRelationAggregateInput? Function()? users,
          Input$SchoolOrderByRelationAggregateInput? Function()? School}) =>
      Input$ProvinceOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceRelationFilter {
  Input$ProvinceRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ProvinceRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ProvinceRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ProvinceWhereInput? $is;

  final Input$ProvinceWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$ProvinceRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ProvinceRelationFilter copyWith(
          {Input$ProvinceWhereInput? Function()? $is,
          Input$ProvinceWhereInput? Function()? isNot}) =>
      Input$ProvinceRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceScalarWhereWithAggregatesInput {
  Input$ProvinceScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ProvinceScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ProvinceScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ProvinceScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ProvinceScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceScalarWhereWithAggregatesInput copyWith(
          {List<Input$ProvinceScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$ProvinceScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ProvinceScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ProvinceScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedCreateInput {
  Input$ProvinceUncheckedCreateInput(
      {this.id,
      required this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput? regencies;

  final String? createdAt;

  final String? updatedAt;

  final Input$UserUncheckedCreateNestedManyWithoutProvinceInput? users;

  final Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$id,
      l$name,
      l$regencies,
      l$createdAt,
      l$updatedAt,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput?
                  Function()?
              regencies,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$UserUncheckedCreateNestedManyWithoutProvinceInput? Function()?
              users,
          Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedCreateWithoutRegenciesInput {
  Input$ProvinceUncheckedCreateWithoutRegenciesInput(
      {this.id,
      required this.name,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceUncheckedCreateWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedCreateWithoutRegenciesInputFromJson(json);

  final String? id;

  final String name;

  final String? createdAt;

  final String? updatedAt;

  final Input$UserUncheckedCreateNestedManyWithoutProvinceInput? users;

  final Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedCreateWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$createdAt, l$updatedAt, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedCreateWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUncheckedCreateWithoutRegenciesInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$UserUncheckedCreateNestedManyWithoutProvinceInput? Function()?
              users,
          Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceUncheckedCreateWithoutRegenciesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedCreateWithoutSchoolInput {
  Input$ProvinceUncheckedCreateWithoutSchoolInput(
      {this.id,
      required this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users});

  @override
  factory Input$ProvinceUncheckedCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput? regencies;

  final String? createdAt;

  final String? updatedAt;

  final Input$UserUncheckedCreateNestedManyWithoutProvinceInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$ProvinceUncheckedCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput?
                  Function()?
              regencies,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$UserUncheckedCreateNestedManyWithoutProvinceInput? Function()?
              users}) =>
      Input$ProvinceUncheckedCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedCreateWithoutUsersInput {
  Input$ProvinceUncheckedCreateWithoutUsersInput(
      {this.id,
      required this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.School});

  @override
  factory Input$ProvinceUncheckedCreateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedCreateWithoutUsersInputFromJson(json);

  final String? id;

  final String name;

  final Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput? regencies;

  final String? createdAt;

  final String? updatedAt;

  final Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedCreateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedCreateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUncheckedCreateWithoutUsersInput copyWith(
          {String? Function()? id,
          String? name,
          Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput?
                  Function()?
              regencies,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceUncheckedCreateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedUpdateInput {
  Input$ProvinceUncheckedUpdateInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$RegencyUncheckedUpdateManyWithoutProvinceInput? regencies;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$UserUncheckedUpdateManyWithoutProvinceInput? users;

  final Input$SchoolUncheckedUpdateManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$id,
      l$name,
      l$regencies,
      l$createdAt,
      l$updatedAt,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$RegencyUncheckedUpdateManyWithoutProvinceInput? Function()?
              regencies,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$UserUncheckedUpdateManyWithoutProvinceInput? Function()? users,
          Input$SchoolUncheckedUpdateManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedUpdateManyInput {
  Input$ProvinceUncheckedUpdateManyInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ProvinceUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ProvinceUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedUpdateWithoutRegenciesInput {
  Input$ProvinceUncheckedUpdateWithoutRegenciesInput(
      {this.id,
      this.name,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceUncheckedUpdateWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedUpdateWithoutRegenciesInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$UserUncheckedUpdateManyWithoutProvinceInput? users;

  final Input$SchoolUncheckedUpdateManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedUpdateWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$createdAt, l$updatedAt, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedUpdateWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUncheckedUpdateWithoutRegenciesInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$UserUncheckedUpdateManyWithoutProvinceInput? Function()? users,
          Input$SchoolUncheckedUpdateManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceUncheckedUpdateWithoutRegenciesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedUpdateWithoutSchoolInput {
  Input$ProvinceUncheckedUpdateWithoutSchoolInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users});

  @override
  factory Input$ProvinceUncheckedUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$RegencyUncheckedUpdateManyWithoutProvinceInput? regencies;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$UserUncheckedUpdateManyWithoutProvinceInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$ProvinceUncheckedUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$RegencyUncheckedUpdateManyWithoutProvinceInput? Function()?
              regencies,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$UserUncheckedUpdateManyWithoutProvinceInput? Function()?
              users}) =>
      Input$ProvinceUncheckedUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUncheckedUpdateWithoutUsersInput {
  Input$ProvinceUncheckedUpdateWithoutUsersInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.School});

  @override
  factory Input$ProvinceUncheckedUpdateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUncheckedUpdateWithoutUsersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$RegencyUncheckedUpdateManyWithoutProvinceInput? regencies;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$SchoolUncheckedUpdateManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUncheckedUpdateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUncheckedUpdateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUncheckedUpdateWithoutUsersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$RegencyUncheckedUpdateManyWithoutProvinceInput? Function()?
              regencies,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$SchoolUncheckedUpdateManyWithoutProvinceInput? Function()?
              School}) =>
      Input$ProvinceUncheckedUpdateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateInput {
  Input$ProvinceUpdateInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$RegencyUpdateManyWithoutProvinceInput? regencies;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$UserUpdateManyWithoutProvinceInput? users;

  final Input$SchoolUpdateManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() => _$Input$ProvinceUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$id,
      l$name,
      l$regencies,
      l$createdAt,
      l$updatedAt,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$RegencyUpdateManyWithoutProvinceInput? Function()? regencies,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$UserUpdateManyWithoutProvinceInput? Function()? users,
          Input$SchoolUpdateManyWithoutProvinceInput? Function()? School}) =>
      Input$ProvinceUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateManyMutationInput {
  Input$ProvinceUpdateManyMutationInput(
      {this.id, this.name, this.createdAt, this.updatedAt});

  @override
  factory Input$ProvinceUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ProvinceUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ProvinceUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateOneRequiredWithoutRegenciesInput {
  Input$ProvinceUpdateOneRequiredWithoutRegenciesInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ProvinceUpdateOneRequiredWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateOneRequiredWithoutRegenciesInputFromJson(json);

  final Input$ProvinceUncheckedCreateWithoutRegenciesInput? create;

  final Input$ProvinceCreateOrConnectWithoutRegenciesInput? connectOrCreate;

  final Input$ProvinceUpsertWithoutRegenciesInput? upsert;

  final Input$ProvinceWhereUniqueInput? connect;

  final Input$ProvinceUncheckedUpdateWithoutRegenciesInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateOneRequiredWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateOneRequiredWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ProvinceUpdateOneRequiredWithoutRegenciesInput copyWith(
          {Input$ProvinceUncheckedCreateWithoutRegenciesInput? Function()?
              create,
          Input$ProvinceCreateOrConnectWithoutRegenciesInput? Function()?
              connectOrCreate,
          Input$ProvinceUpsertWithoutRegenciesInput? Function()? upsert,
          Input$ProvinceWhereUniqueInput? Function()? connect,
          Input$ProvinceUncheckedUpdateWithoutRegenciesInput? Function()?
              update}) =>
      Input$ProvinceUpdateOneRequiredWithoutRegenciesInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateOneRequiredWithoutSchoolInput {
  Input$ProvinceUpdateOneRequiredWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ProvinceUpdateOneRequiredWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateOneRequiredWithoutSchoolInputFromJson(json);

  final Input$ProvinceUncheckedCreateWithoutSchoolInput? create;

  final Input$ProvinceCreateOrConnectWithoutSchoolInput? connectOrCreate;

  final Input$ProvinceUpsertWithoutSchoolInput? upsert;

  final Input$ProvinceWhereUniqueInput? connect;

  final Input$ProvinceUncheckedUpdateWithoutSchoolInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateOneRequiredWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateOneRequiredWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ProvinceUpdateOneRequiredWithoutSchoolInput copyWith(
          {Input$ProvinceUncheckedCreateWithoutSchoolInput? Function()? create,
          Input$ProvinceCreateOrConnectWithoutSchoolInput? Function()?
              connectOrCreate,
          Input$ProvinceUpsertWithoutSchoolInput? Function()? upsert,
          Input$ProvinceWhereUniqueInput? Function()? connect,
          Input$ProvinceUncheckedUpdateWithoutSchoolInput? Function()?
              update}) =>
      Input$ProvinceUpdateOneRequiredWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateOneRequiredWithoutUsersInput {
  Input$ProvinceUpdateOneRequiredWithoutUsersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ProvinceUpdateOneRequiredWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateOneRequiredWithoutUsersInputFromJson(json);

  final Input$ProvinceUncheckedCreateWithoutUsersInput? create;

  final Input$ProvinceCreateOrConnectWithoutUsersInput? connectOrCreate;

  final Input$ProvinceUpsertWithoutUsersInput? upsert;

  final Input$ProvinceWhereUniqueInput? connect;

  final Input$ProvinceUncheckedUpdateWithoutUsersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateOneRequiredWithoutUsersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateOneRequiredWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ProvinceUpdateOneRequiredWithoutUsersInput copyWith(
          {Input$ProvinceUncheckedCreateWithoutUsersInput? Function()? create,
          Input$ProvinceCreateOrConnectWithoutUsersInput? Function()?
              connectOrCreate,
          Input$ProvinceUpsertWithoutUsersInput? Function()? upsert,
          Input$ProvinceWhereUniqueInput? Function()? connect,
          Input$ProvinceUncheckedUpdateWithoutUsersInput? Function()?
              update}) =>
      Input$ProvinceUpdateOneRequiredWithoutUsersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateWithoutRegenciesInput {
  Input$ProvinceUpdateWithoutRegenciesInput(
      {this.id,
      this.name,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceUpdateWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateWithoutRegenciesInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$UserUpdateManyWithoutProvinceInput? users;

  final Input$SchoolUpdateManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$createdAt, l$updatedAt, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUpdateWithoutRegenciesInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$UserUpdateManyWithoutProvinceInput? Function()? users,
          Input$SchoolUpdateManyWithoutProvinceInput? Function()? School}) =>
      Input$ProvinceUpdateWithoutRegenciesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateWithoutSchoolInput {
  Input$ProvinceUpdateWithoutSchoolInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users});

  @override
  factory Input$ProvinceUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$RegencyUpdateManyWithoutProvinceInput? regencies;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$UserUpdateManyWithoutProvinceInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$ProvinceUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$RegencyUpdateManyWithoutProvinceInput? Function()? regencies,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$UserUpdateManyWithoutProvinceInput? Function()? users}) =>
      Input$ProvinceUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpdateWithoutUsersInput {
  Input$ProvinceUpdateWithoutUsersInput(
      {this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.School});

  @override
  factory Input$ProvinceUpdateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpdateWithoutUsersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$RegencyUpdateManyWithoutProvinceInput? regencies;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$SchoolUpdateManyWithoutProvinceInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpdateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$regencies, l$createdAt, l$updatedAt, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpdateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceUpdateWithoutUsersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$RegencyUpdateManyWithoutProvinceInput? Function()? regencies,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$SchoolUpdateManyWithoutProvinceInput? Function()? School}) =>
      Input$ProvinceUpdateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpsertWithoutRegenciesInput {
  Input$ProvinceUpsertWithoutRegenciesInput(
      {required this.update, required this.create});

  @override
  factory Input$ProvinceUpsertWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpsertWithoutRegenciesInputFromJson(json);

  final Input$ProvinceUncheckedUpdateWithoutRegenciesInput update;

  final Input$ProvinceUncheckedCreateWithoutRegenciesInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpsertWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpsertWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ProvinceUpsertWithoutRegenciesInput copyWith(
          {Input$ProvinceUncheckedUpdateWithoutRegenciesInput? update,
          Input$ProvinceUncheckedCreateWithoutRegenciesInput? create}) =>
      Input$ProvinceUpsertWithoutRegenciesInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpsertWithoutSchoolInput {
  Input$ProvinceUpsertWithoutSchoolInput(
      {required this.update, required this.create});

  @override
  factory Input$ProvinceUpsertWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpsertWithoutSchoolInputFromJson(json);

  final Input$ProvinceUncheckedUpdateWithoutSchoolInput update;

  final Input$ProvinceUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpsertWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpsertWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ProvinceUpsertWithoutSchoolInput copyWith(
          {Input$ProvinceUncheckedUpdateWithoutSchoolInput? update,
          Input$ProvinceUncheckedCreateWithoutSchoolInput? create}) =>
      Input$ProvinceUpsertWithoutSchoolInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceUpsertWithoutUsersInput {
  Input$ProvinceUpsertWithoutUsersInput(
      {required this.update, required this.create});

  @override
  factory Input$ProvinceUpsertWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ProvinceUpsertWithoutUsersInputFromJson(json);

  final Input$ProvinceUncheckedUpdateWithoutUsersInput update;

  final Input$ProvinceUncheckedCreateWithoutUsersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ProvinceUpsertWithoutUsersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceUpsertWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ProvinceUpsertWithoutUsersInput copyWith(
          {Input$ProvinceUncheckedUpdateWithoutUsersInput? update,
          Input$ProvinceUncheckedCreateWithoutUsersInput? create}) =>
      Input$ProvinceUpsertWithoutUsersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceWhereInput {
  Input$ProvinceWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.regencies,
      this.createdAt,
      this.updatedAt,
      this.users,
      this.School});

  @override
  factory Input$ProvinceWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ProvinceWhereInputFromJson(json);

  final List<Input$ProvinceWhereInput?>? AND;

  final List<Input$ProvinceWhereInput?>? OR;

  final List<Input$ProvinceWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$RegencyListRelationFilter? regencies;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$UserListRelationFilter? users;

  final Input$SchoolListRelationFilter? School;

  Map<String, dynamic> toJson() => _$Input$ProvinceWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$regencies = regencies;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$regencies,
      l$createdAt,
      l$updatedAt,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$regencies = regencies;
    final lOther$regencies = other.regencies;
    if (l$regencies != lOther$regencies) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$ProvinceWhereInput copyWith(
          {List<Input$ProvinceWhereInput?>? Function()? AND,
          List<Input$ProvinceWhereInput?>? Function()? OR,
          List<Input$ProvinceWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$RegencyListRelationFilter? Function()? regencies,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$UserListRelationFilter? Function()? users,
          Input$SchoolListRelationFilter? Function()? School}) =>
      Input$ProvinceWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          regencies: regencies == null ? this.regencies : regencies(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$ProvinceWhereUniqueInput {
  Input$ProvinceWhereUniqueInput({this.id});

  @override
  factory Input$ProvinceWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ProvinceWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() => _$Input$ProvinceWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ProvinceWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ProvinceWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$ProvinceWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCountOrderByAggregateInput {
  Input$QuestionCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answerType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answers;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalQuestionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers,
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != lOther$answers) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? answerType,
          Enum$SortOrder? Function()? answers,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? originalQuestionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$QuestionCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateanswersInput {
  Input$QuestionCreateanswersInput({required this.$set});

  @override
  factory Input$QuestionCreateanswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateanswersInputFromJson(json);

  @JsonKey(name: 'set')
  final String $set;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateanswersInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateanswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$QuestionCreateanswersInput copyWith({String? $set}) =>
      Input$QuestionCreateanswersInput($set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateInput {
  Input$QuestionCreateInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.user,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionCreateInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final Input$UserCreateNestedOneWithoutQuestionsInput user;

  final Input$QuestionCreateNestedOneWithoutChildrensInput? originalQuestion;

  final Input$QuestionCreateNestedManyWithoutOriginalQuestionInput? childrens;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() => _$Input$QuestionCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          Input$UserCreateNestedOneWithoutQuestionsInput? user,
          Input$QuestionCreateNestedOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$QuestionCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user,
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateManyInput {
  Input$QuestionCreateManyInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionCreateManyInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String userId;

  final String? originalQuestionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$QuestionCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? userId,
          String? Function()? originalQuestionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$QuestionCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId,
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateManyOriginalQuestionInput {
  Input$QuestionCreateManyOriginalQuestionInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionCreateManyOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateManyOriginalQuestionInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateManyOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateManyOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionCreateManyOriginalQuestionInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$QuestionCreateManyOriginalQuestionInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateManyOriginalQuestionInputEnvelope {
  Input$QuestionCreateManyOriginalQuestionInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$QuestionCreateManyOriginalQuestionInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateManyOriginalQuestionInputEnvelopeFromJson(json);

  final Input$QuestionCreateManyOriginalQuestionInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateManyOriginalQuestionInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateManyOriginalQuestionInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$QuestionCreateManyOriginalQuestionInputEnvelope copyWith(
          {Input$QuestionCreateManyOriginalQuestionInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$QuestionCreateManyOriginalQuestionInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateManyUserInput {
  Input$QuestionCreateManyUserInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateManyUserInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String? originalQuestionId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionCreateManyUserInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? Function()? originalQuestionId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$QuestionCreateManyUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateManyUserInputEnvelope {
  Input$QuestionCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$QuestionCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateManyUserInputEnvelopeFromJson(json);

  final Input$QuestionCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$QuestionCreateManyUserInputEnvelope copyWith(
          {Input$QuestionCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$QuestionCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateNestedManyWithoutOriginalQuestionInput {
  Input$QuestionCreateNestedManyWithoutOriginalQuestionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$QuestionCreateNestedManyWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateNestedManyWithoutOriginalQuestionInputFromJson(
          json);

  final List<Input$QuestionCreateWithoutOriginalQuestionInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
      connectOrCreate;

  final Input$QuestionCreateManyOriginalQuestionInputEnvelope? createMany;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateNestedManyWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$QuestionCreateNestedManyWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$QuestionCreateNestedManyWithoutOriginalQuestionInput copyWith(
          {List<Input$QuestionCreateWithoutOriginalQuestionInput?>? Function()?
              create,
          List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
                  Function()?
              connectOrCreate,
          Input$QuestionCreateManyOriginalQuestionInputEnvelope? Function()?
              createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$QuestionCreateNestedManyWithoutOriginalQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateNestedManyWithoutUserInput {
  Input$QuestionCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$QuestionCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$QuestionCreateWithoutUserInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$QuestionCreateManyUserInputEnvelope? createMany;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$QuestionCreateNestedManyWithoutUserInput copyWith(
          {List<Input$QuestionCreateWithoutUserInput?>? Function()? create,
          List<Input$QuestionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$QuestionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$QuestionCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateNestedOneWithoutChildrensInput {
  Input$QuestionCreateNestedOneWithoutChildrensInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$QuestionCreateNestedOneWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateNestedOneWithoutChildrensInputFromJson(json);

  final Input$QuestionUncheckedCreateWithoutChildrensInput? create;

  final Input$QuestionCreateOrConnectWithoutChildrensInput? connectOrCreate;

  final Input$QuestionWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateNestedOneWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateNestedOneWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$QuestionCreateNestedOneWithoutChildrensInput copyWith(
          {Input$QuestionUncheckedCreateWithoutChildrensInput? Function()?
              create,
          Input$QuestionCreateOrConnectWithoutChildrensInput? Function()?
              connectOrCreate,
          Input$QuestionWhereUniqueInput? Function()? connect}) =>
      Input$QuestionCreateNestedOneWithoutChildrensInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateNestedOneWithoutExamquestionsInput {
  Input$QuestionCreateNestedOneWithoutExamquestionsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$QuestionCreateNestedOneWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateNestedOneWithoutExamquestionsInputFromJson(json);

  final Input$QuestionUncheckedCreateWithoutExamquestionsInput? create;

  final Input$QuestionCreateOrConnectWithoutExamquestionsInput? connectOrCreate;

  final Input$QuestionWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateNestedOneWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateNestedOneWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$QuestionCreateNestedOneWithoutExamquestionsInput copyWith(
          {Input$QuestionUncheckedCreateWithoutExamquestionsInput? Function()?
              create,
          Input$QuestionCreateOrConnectWithoutExamquestionsInput? Function()?
              connectOrCreate,
          Input$QuestionWhereUniqueInput? Function()? connect}) =>
      Input$QuestionCreateNestedOneWithoutExamquestionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateOrConnectWithoutChildrensInput {
  Input$QuestionCreateOrConnectWithoutChildrensInput(
      {required this.where, required this.create});

  @override
  factory Input$QuestionCreateOrConnectWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateOrConnectWithoutChildrensInputFromJson(json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedCreateWithoutChildrensInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateOrConnectWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateOrConnectWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionCreateOrConnectWithoutChildrensInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedCreateWithoutChildrensInput? create}) =>
      Input$QuestionCreateOrConnectWithoutChildrensInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateOrConnectWithoutExamquestionsInput {
  Input$QuestionCreateOrConnectWithoutExamquestionsInput(
      {required this.where, required this.create});

  @override
  factory Input$QuestionCreateOrConnectWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateOrConnectWithoutExamquestionsInputFromJson(json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedCreateWithoutExamquestionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateOrConnectWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateOrConnectWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionCreateOrConnectWithoutExamquestionsInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedCreateWithoutExamquestionsInput? create}) =>
      Input$QuestionCreateOrConnectWithoutExamquestionsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateOrConnectWithoutOriginalQuestionInput {
  Input$QuestionCreateOrConnectWithoutOriginalQuestionInput(
      {required this.where, required this.create});

  @override
  factory Input$QuestionCreateOrConnectWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateOrConnectWithoutOriginalQuestionInputFromJson(json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedCreateWithoutOriginalQuestionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateOrConnectWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateOrConnectWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionCreateOrConnectWithoutOriginalQuestionInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedCreateWithoutOriginalQuestionInput? create}) =>
      Input$QuestionCreateOrConnectWithoutOriginalQuestionInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateOrConnectWithoutUserInput {
  Input$QuestionCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$QuestionCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateOrConnectWithoutUserInputFromJson(json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionCreateOrConnectWithoutUserInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedCreateWithoutUserInput? create}) =>
      Input$QuestionCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateWithoutChildrensInput {
  Input$QuestionCreateWithoutChildrensInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.user,
      this.originalQuestion,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionCreateWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateWithoutChildrensInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final Input$UserCreateNestedOneWithoutQuestionsInput user;

  final Input$QuestionCreateNestedOneWithoutChildrensInput? originalQuestion;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$originalQuestion = originalQuestion;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$originalQuestion,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionCreateWithoutChildrensInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          Input$UserCreateNestedOneWithoutQuestionsInput? user,
          Input$QuestionCreateNestedOneWithoutChildrensInput? Function()?
              originalQuestion,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionCreateWithoutChildrensInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user,
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateWithoutExamquestionsInput {
  Input$QuestionCreateWithoutExamquestionsInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.user,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionCreateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateWithoutExamquestionsInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final Input$UserCreateNestedOneWithoutQuestionsInput user;

  final Input$QuestionCreateNestedOneWithoutChildrensInput? originalQuestion;

  final Input$QuestionCreateNestedManyWithoutOriginalQuestionInput? childrens;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionCreateWithoutExamquestionsInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          Input$UserCreateNestedOneWithoutQuestionsInput? user,
          Input$QuestionCreateNestedOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$QuestionCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$QuestionCreateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user,
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateWithoutOriginalQuestionInput {
  Input$QuestionCreateWithoutOriginalQuestionInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.user,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionCreateWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateWithoutOriginalQuestionInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final Input$UserCreateNestedOneWithoutQuestionsInput user;

  final Input$QuestionCreateNestedManyWithoutOriginalQuestionInput? childrens;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionCreateWithoutOriginalQuestionInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          Input$UserCreateNestedOneWithoutQuestionsInput? user,
          Input$QuestionCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionCreateWithoutOriginalQuestionInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user,
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionCreateWithoutUserInput {
  Input$QuestionCreateWithoutUserInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final Input$QuestionCreateNestedOneWithoutChildrensInput? originalQuestion;

  final Input$QuestionCreateNestedManyWithoutOriginalQuestionInput? childrens;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionCreateNestedManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          Input$QuestionCreateNestedOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$QuestionCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionCreateNestedManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionListRelationFilter {
  Input$QuestionListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$QuestionListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionListRelationFilterFromJson(json);

  final Input$QuestionWhereInput? every;

  final Input$QuestionWhereInput? some;

  final Input$QuestionWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$QuestionListRelationFilter copyWith(
          {Input$QuestionWhereInput? Function()? every,
          Input$QuestionWhereInput? Function()? some,
          Input$QuestionWhereInput? Function()? none}) =>
      Input$QuestionListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionMaxOrderByAggregateInput {
  Input$QuestionMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answerType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalQuestionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? answerType,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? originalQuestionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$QuestionMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionMinOrderByAggregateInput {
  Input$QuestionMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answerType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalQuestionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? answerType,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? originalQuestionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$QuestionMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionOrderByRelationAggregateInput {
  Input$QuestionOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$QuestionOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$QuestionOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$QuestionOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionOrderByWithAggregationInput {
  Input$QuestionOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$QuestionOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answerType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answers;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalQuestionId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$QuestionCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$QuestionMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$QuestionMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers,
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != lOther$answers) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$QuestionOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? answerType,
          Enum$SortOrder? Function()? answers,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? originalQuestionId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$QuestionCountOrderByAggregateInput? Function()? $_count,
          Input$QuestionMaxOrderByAggregateInput? Function()? $_max,
          Input$QuestionMinOrderByAggregateInput? Function()? $_min}) =>
      Input$QuestionOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionOrderByWithRelationInput {
  Input$QuestionOrderByWithRelationInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.user,
      this.originalQuestionId,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contentType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? content;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answerType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? answers;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalQuestionId;

  final Input$QuestionOrderByWithRelationInput? originalQuestion;

  final Input$QuestionOrderByRelationAggregateInput? childrens;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ExamQuestionOrderByRelationAggregateInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$user = user;
    final l$originalQuestionId = originalQuestionId;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers,
      l$userId,
      l$user,
      l$originalQuestionId,
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != lOther$answers) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? contentType,
          Enum$SortOrder? Function()? content,
          Enum$SortOrder? Function()? answerType,
          Enum$SortOrder? Function()? answers,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? originalQuestionId,
          Input$QuestionOrderByWithRelationInput? Function()? originalQuestion,
          Input$QuestionOrderByRelationAggregateInput? Function()? childrens,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ExamQuestionOrderByRelationAggregateInput? Function()?
              examquestions}) =>
      Input$QuestionOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionRelationFilter {
  Input$QuestionRelationFilter({this.$is, this.isNot});

  @override
  factory Input$QuestionRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$QuestionWhereInput? $is;

  final Input$QuestionWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$QuestionRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$QuestionRelationFilter copyWith(
          {Input$QuestionWhereInput? Function()? $is,
          Input$QuestionWhereInput? Function()? isNot}) =>
      Input$QuestionRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionScalarWhereInput {
  Input$QuestionScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionScalarWhereInputFromJson(json);

  final List<Input$QuestionScalarWhereInput?>? AND;

  final List<Input$QuestionScalarWhereInput?>? OR;

  final List<Input$QuestionScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$EnumQuestionTypeFilter? type;

  final Input$EnumContentTypeFilter? contentType;

  final Input$StringFilter? content;

  final Input$EnumContentTypeFilter? answerType;

  final Input$StringNullableListFilter? answers;

  final Input$StringFilter? userId;

  final Input$StringNullableFilter? originalQuestionId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$QuestionScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers,
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != lOther$answers) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionScalarWhereInput copyWith(
          {List<Input$QuestionScalarWhereInput?>? Function()? AND,
          List<Input$QuestionScalarWhereInput?>? Function()? OR,
          List<Input$QuestionScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$EnumQuestionTypeFilter? Function()? type,
          Input$EnumContentTypeFilter? Function()? contentType,
          Input$StringFilter? Function()? content,
          Input$EnumContentTypeFilter? Function()? answerType,
          Input$StringNullableListFilter? Function()? answers,
          Input$StringFilter? Function()? userId,
          Input$StringNullableFilter? Function()? originalQuestionId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$QuestionScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionScalarWhereWithAggregatesInput {
  Input$QuestionScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$QuestionScalarWhereWithAggregatesInput?>? AND;

  final List<Input$QuestionScalarWhereWithAggregatesInput?>? OR;

  final List<Input$QuestionScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$EnumQuestionTypeWithAggregatesFilter? type;

  final Input$EnumContentTypeWithAggregatesFilter? contentType;

  final Input$StringWithAggregatesFilter? content;

  final Input$EnumContentTypeWithAggregatesFilter? answerType;

  final Input$StringNullableListFilter? answers;

  final Input$StringWithAggregatesFilter? userId;

  final Input$StringNullableWithAggregatesFilter? originalQuestionId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers,
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != lOther$answers) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionScalarWhereWithAggregatesInput copyWith(
          {List<Input$QuestionScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$QuestionScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$QuestionScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$EnumQuestionTypeWithAggregatesFilter? Function()? type,
          Input$EnumContentTypeWithAggregatesFilter? Function()? contentType,
          Input$StringWithAggregatesFilter? Function()? content,
          Input$EnumContentTypeWithAggregatesFilter? Function()? answerType,
          Input$StringNullableListFilter? Function()? answers,
          Input$StringWithAggregatesFilter? Function()? userId,
          Input$StringNullableWithAggregatesFilter? Function()?
              originalQuestionId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$QuestionScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateInput {
  Input$QuestionUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.userId,
      this.originalQuestionId,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String userId;

  final String? originalQuestionId;

  final Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
      childrens;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? userId,
          String? Function()? originalQuestionId,
          Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
                  Function()?
              examquestions}) =>
      Input$QuestionUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId,
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput {
  Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInputFromJson(
          json);

  final List<Input$QuestionCreateWithoutOriginalQuestionInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
      connectOrCreate;

  final Input$QuestionCreateManyOriginalQuestionInputEnvelope? createMany;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput copyWith(
          {List<Input$QuestionCreateWithoutOriginalQuestionInput?>? Function()?
              create,
          List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
                  Function()?
              connectOrCreate,
          Input$QuestionCreateManyOriginalQuestionInputEnvelope? Function()?
              createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateNestedManyWithoutUserInput {
  Input$QuestionUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$QuestionUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$QuestionCreateWithoutUserInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$QuestionCreateManyUserInputEnvelope? createMany;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$QuestionUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$QuestionCreateWithoutUserInput?>? Function()? create,
          List<Input$QuestionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$QuestionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect}) =>
      Input$QuestionUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateWithoutChildrensInput {
  Input$QuestionUncheckedCreateWithoutChildrensInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedCreateWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateWithoutChildrensInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String userId;

  final String? originalQuestionId;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedCreateWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedCreateWithoutChildrensInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? userId,
          String? Function()? originalQuestionId,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
                  Function()?
              examquestions}) =>
      Input$QuestionUncheckedCreateWithoutChildrensInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId,
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateWithoutExamquestionsInput {
  Input$QuestionUncheckedCreateWithoutExamquestionsInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.userId,
      this.originalQuestionId,
      this.childrens,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUncheckedCreateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateWithoutExamquestionsInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String userId;

  final String? originalQuestionId;

  final Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
      childrens;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$childrens,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedCreateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUncheckedCreateWithoutExamquestionsInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? userId,
          String? Function()? originalQuestionId,
          Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$QuestionUncheckedCreateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId,
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateWithoutOriginalQuestionInput {
  Input$QuestionUncheckedCreateWithoutOriginalQuestionInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      required this.userId,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedCreateWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateWithoutOriginalQuestionInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String userId;

  final Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
      childrens;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedCreateWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedCreateWithoutOriginalQuestionInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? userId,
          Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
                  Function()?
              examquestions}) =>
      Input$QuestionUncheckedCreateWithoutOriginalQuestionInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId,
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedCreateWithoutUserInput {
  Input$QuestionUncheckedCreateWithoutUserInput(
      {this.id,
      required this.name,
      required this.type,
      required this.contentType,
      required this.content,
      required this.answerType,
      this.answers,
      this.originalQuestionId,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$QuestionType.$unknown)
  final Enum$QuestionType type;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType contentType;

  final String content;

  @JsonKey(unknownEnumValue: Enum$ContentType.$unknown)
  final Enum$ContentType answerType;

  final List<String?>? answers;

  final String? originalQuestionId;

  final Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
      childrens;

  final String? createdAt;

  final String? updatedAt;

  final Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$originalQuestionId = originalQuestionId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$originalQuestionId,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? name,
          Enum$QuestionType? type,
          Enum$ContentType? contentType,
          String? content,
          Enum$ContentType? answerType,
          List<String?>? Function()? answers,
          String? Function()? originalQuestionId,
          Input$QuestionUncheckedCreateNestedManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput?
                  Function()?
              examquestions}) =>
      Input$QuestionUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          type: type == null ? this.type : type,
          contentType: contentType == null ? this.contentType : contentType,
          content: content == null ? this.content : content,
          answerType: answerType == null ? this.answerType : answerType,
          answers: answers == null ? this.answers : answers(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateInput {
  Input$QuestionUncheckedUpdateInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$NullableStringFieldUpdateOperationsInput? originalQuestionId;

  final Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
      childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              originalQuestionId,
          Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateManyInput {
  Input$QuestionUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$NullableStringFieldUpdateOperationsInput? originalQuestionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              originalQuestionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$QuestionUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateManyWithoutChildrensInput {
  Input$QuestionUncheckedUpdateManyWithoutChildrensInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUncheckedUpdateManyWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateManyWithoutChildrensInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateManyWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateManyWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateManyWithoutChildrensInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$QuestionUncheckedUpdateManyWithoutChildrensInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput {
  Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInputFromJson(
          json);

  final List<Input$QuestionCreateWithoutOriginalQuestionInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
      connectOrCreate;

  final List<Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput?>?
      upsert;

  final Input$QuestionCreateManyOriginalQuestionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$QuestionWhereUniqueInput?>? $set;

  final List<Input$QuestionWhereUniqueInput?>? disconnect;

  final List<Input$QuestionWhereUniqueInput?>? delete;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  final List<Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput?>?
      update;

  final List<Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput?>?
      updateMany;

  final List<Input$QuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput copyWith(
          {List<Input$QuestionCreateWithoutOriginalQuestionInput?>? Function()?
              create,
          List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
                  Function()?
              connectOrCreate,
          List<Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput?>?
                  Function()?
              upsert,
          Input$QuestionCreateManyOriginalQuestionInputEnvelope? Function()?
              createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? $set,
          List<Input$QuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$QuestionWhereUniqueInput?>? Function()? delete,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect,
          List<Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput?>?
                  Function()?
              update,
          List<Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput?>?
                  Function()?
              updateMany,
          List<Input$QuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateManyWithoutQuestionsInput {
  Input$QuestionUncheckedUpdateManyWithoutQuestionsInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUncheckedUpdateManyWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateManyWithoutQuestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$NullableStringFieldUpdateOperationsInput? originalQuestionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateManyWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateManyWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateManyWithoutQuestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              originalQuestionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$QuestionUncheckedUpdateManyWithoutQuestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateManyWithoutUserInput {
  Input$QuestionUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$QuestionUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$QuestionCreateWithoutUserInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$QuestionUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$QuestionCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$QuestionWhereUniqueInput?>? $set;

  final List<Input$QuestionWhereUniqueInput?>? disconnect;

  final List<Input$QuestionWhereUniqueInput?>? delete;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  final List<Input$QuestionUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$QuestionUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$QuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$QuestionUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$QuestionCreateWithoutUserInput?>? Function()? create,
          List<Input$QuestionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$QuestionUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$QuestionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? $set,
          List<Input$QuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$QuestionWhereUniqueInput?>? Function()? delete,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect,
          List<Input$QuestionUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$QuestionUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$QuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$QuestionUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateWithoutChildrensInput {
  Input$QuestionUncheckedUpdateWithoutChildrensInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedUpdateWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateWithoutChildrensInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$NullableStringFieldUpdateOperationsInput? originalQuestionId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateWithoutChildrensInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              originalQuestionId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUncheckedUpdateWithoutChildrensInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateWithoutExamquestionsInput {
  Input$QuestionUncheckedUpdateWithoutExamquestionsInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.originalQuestionId,
      this.childrens,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUncheckedUpdateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateWithoutExamquestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$NullableStringFieldUpdateOperationsInput? originalQuestionId;

  final Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
      childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$originalQuestionId = originalQuestionId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$originalQuestionId,
      l$childrens,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateWithoutExamquestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              originalQuestionId,
          Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$QuestionUncheckedUpdateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput {
  Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateWithoutOriginalQuestionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$StringFieldUpdateOperationsInput? userId;

  final Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
      childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$userId,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUncheckedUpdateWithoutUserInput {
  Input$QuestionUncheckedUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.originalQuestionId,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$NullableStringFieldUpdateOperationsInput? originalQuestionId;

  final Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
      childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput?
      examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$originalQuestionId = originalQuestionId;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$originalQuestionId,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              originalQuestionId,
          Input$QuestionUncheckedUpdateManyWithoutOriginalQuestionInput?
                  Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUncheckedUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateanswersInput {
  Input$QuestionUpdateanswersInput({this.$set, this.push});

  @override
  factory Input$QuestionUpdateanswersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateanswersInputFromJson(json);

  @JsonKey(name: 'set')
  final List<String?>? $set;

  final List<String?>? push;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateanswersInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateanswersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$QuestionUpdateanswersInput copyWith(
          {List<String?>? Function()? $set, List<String?>? Function()? push}) =>
      Input$QuestionUpdateanswersInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateInput {
  Input$QuestionUpdateInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.user,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$UserUpdateOneRequiredWithoutQuestionsInput? user;

  final Input$QuestionUpdateOneWithoutChildrensInput? originalQuestion;

  final Input$QuestionUpdateManyWithoutOriginalQuestionInput? childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() => _$Input$QuestionUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$UserUpdateOneRequiredWithoutQuestionsInput? Function()? user,
          Input$QuestionUpdateOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$QuestionUpdateManyWithoutOriginalQuestionInput? Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateManyMutationInput {
  Input$QuestionUpdateManyMutationInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$QuestionUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateManyWithoutOriginalQuestionInput {
  Input$QuestionUpdateManyWithoutOriginalQuestionInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$QuestionUpdateManyWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateManyWithoutOriginalQuestionInputFromJson(json);

  final List<Input$QuestionCreateWithoutOriginalQuestionInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
      connectOrCreate;

  final List<Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput?>?
      upsert;

  final Input$QuestionCreateManyOriginalQuestionInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$QuestionWhereUniqueInput?>? $set;

  final List<Input$QuestionWhereUniqueInput?>? disconnect;

  final List<Input$QuestionWhereUniqueInput?>? delete;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  final List<Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput?>?
      update;

  final List<Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput?>?
      updateMany;

  final List<Input$QuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateManyWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateManyWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$QuestionUpdateManyWithoutOriginalQuestionInput copyWith(
          {List<Input$QuestionCreateWithoutOriginalQuestionInput?>? Function()?
              create,
          List<Input$QuestionCreateOrConnectWithoutOriginalQuestionInput?>?
                  Function()?
              connectOrCreate,
          List<Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput?>?
                  Function()?
              upsert,
          Input$QuestionCreateManyOriginalQuestionInputEnvelope? Function()?
              createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? $set,
          List<Input$QuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$QuestionWhereUniqueInput?>? Function()? delete,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect,
          List<Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput?>?
                  Function()?
              update,
          List<Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput?>?
                  Function()?
              updateMany,
          List<Input$QuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$QuestionUpdateManyWithoutOriginalQuestionInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateManyWithoutUserInput {
  Input$QuestionUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$QuestionUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateManyWithoutUserInputFromJson(json);

  final List<Input$QuestionCreateWithoutUserInput?>? create;

  final List<Input$QuestionCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$QuestionUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$QuestionCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$QuestionWhereUniqueInput?>? $set;

  final List<Input$QuestionWhereUniqueInput?>? disconnect;

  final List<Input$QuestionWhereUniqueInput?>? delete;

  final List<Input$QuestionWhereUniqueInput?>? connect;

  final List<Input$QuestionUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$QuestionUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$QuestionScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$QuestionUpdateManyWithoutUserInput copyWith(
          {List<Input$QuestionCreateWithoutUserInput?>? Function()? create,
          List<Input$QuestionCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$QuestionUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$QuestionCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$QuestionWhereUniqueInput?>? Function()? $set,
          List<Input$QuestionWhereUniqueInput?>? Function()? disconnect,
          List<Input$QuestionWhereUniqueInput?>? Function()? delete,
          List<Input$QuestionWhereUniqueInput?>? Function()? connect,
          List<Input$QuestionUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$QuestionUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$QuestionScalarWhereInput?>? Function()? deleteMany}) =>
      Input$QuestionUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput {
  Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput(
      {required this.where, required this.data});

  @override
  factory Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInputFromJson(
          json);

  final Input$QuestionScalarWhereInput where;

  final Input$QuestionUncheckedUpdateManyWithoutChildrensInput data;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput copyWith(
          {Input$QuestionScalarWhereInput? where,
          Input$QuestionUncheckedUpdateManyWithoutChildrensInput? data}) =>
      Input$QuestionUpdateManyWithWhereWithoutOriginalQuestionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateManyWithWhereWithoutUserInput {
  Input$QuestionUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$QuestionUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$QuestionScalarWhereInput where;

  final Input$QuestionUncheckedUpdateManyWithoutQuestionsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$QuestionUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$QuestionScalarWhereInput? where,
          Input$QuestionUncheckedUpdateManyWithoutQuestionsInput? data}) =>
      Input$QuestionUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateOneRequiredWithoutExamquestionsInput {
  Input$QuestionUpdateOneRequiredWithoutExamquestionsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$QuestionUpdateOneRequiredWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateOneRequiredWithoutExamquestionsInputFromJson(json);

  final Input$QuestionUncheckedCreateWithoutExamquestionsInput? create;

  final Input$QuestionCreateOrConnectWithoutExamquestionsInput? connectOrCreate;

  final Input$QuestionUpsertWithoutExamquestionsInput? upsert;

  final Input$QuestionWhereUniqueInput? connect;

  final Input$QuestionUncheckedUpdateWithoutExamquestionsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateOneRequiredWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateOneRequiredWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$QuestionUpdateOneRequiredWithoutExamquestionsInput copyWith(
          {Input$QuestionUncheckedCreateWithoutExamquestionsInput? Function()?
              create,
          Input$QuestionCreateOrConnectWithoutExamquestionsInput? Function()?
              connectOrCreate,
          Input$QuestionUpsertWithoutExamquestionsInput? Function()? upsert,
          Input$QuestionWhereUniqueInput? Function()? connect,
          Input$QuestionUncheckedUpdateWithoutExamquestionsInput? Function()?
              update}) =>
      Input$QuestionUpdateOneRequiredWithoutExamquestionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateOneWithoutChildrensInput {
  Input$QuestionUpdateOneWithoutChildrensInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.disconnect,
      this.delete,
      this.connect,
      this.update});

  @override
  factory Input$QuestionUpdateOneWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateOneWithoutChildrensInputFromJson(json);

  final Input$QuestionUncheckedCreateWithoutChildrensInput? create;

  final Input$QuestionCreateOrConnectWithoutChildrensInput? connectOrCreate;

  final Input$QuestionUpsertWithoutChildrensInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final Input$QuestionWhereUniqueInput? connect;

  final Input$QuestionUncheckedUpdateWithoutChildrensInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateOneWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      l$create,
      l$connectOrCreate,
      l$upsert,
      l$disconnect,
      l$delete,
      l$connect,
      l$update
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateOneWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != lOther$disconnect) return false;
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != lOther$delete) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$QuestionUpdateOneWithoutChildrensInput copyWith(
          {Input$QuestionUncheckedCreateWithoutChildrensInput? Function()?
              create,
          Input$QuestionCreateOrConnectWithoutChildrensInput? Function()?
              connectOrCreate,
          Input$QuestionUpsertWithoutChildrensInput? Function()? upsert,
          bool? Function()? disconnect,
          bool? Function()? delete,
          Input$QuestionWhereUniqueInput? Function()? connect,
          Input$QuestionUncheckedUpdateWithoutChildrensInput? Function()?
              update}) =>
      Input$QuestionUpdateOneWithoutChildrensInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateWithoutChildrensInput {
  Input$QuestionUpdateWithoutChildrensInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.user,
      this.originalQuestion,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUpdateWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateWithoutChildrensInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$UserUpdateOneRequiredWithoutQuestionsInput? user;

  final Input$QuestionUpdateOneWithoutChildrensInput? originalQuestion;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$originalQuestion = originalQuestion;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$originalQuestion,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUpdateWithoutChildrensInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$UserUpdateOneRequiredWithoutQuestionsInput? Function()? user,
          Input$QuestionUpdateOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUpdateWithoutChildrensInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateWithoutExamquestionsInput {
  Input$QuestionUpdateWithoutExamquestionsInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.user,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$QuestionUpdateWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateWithoutExamquestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$UserUpdateOneRequiredWithoutQuestionsInput? user;

  final Input$QuestionUpdateOneWithoutChildrensInput? originalQuestion;

  final Input$QuestionUpdateManyWithoutOriginalQuestionInput? childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$QuestionUpdateWithoutExamquestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$UserUpdateOneRequiredWithoutQuestionsInput? Function()? user,
          Input$QuestionUpdateOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$QuestionUpdateManyWithoutOriginalQuestionInput? Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$QuestionUpdateWithoutExamquestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateWithoutOriginalQuestionInput {
  Input$QuestionUpdateWithoutOriginalQuestionInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.user,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUpdateWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateWithoutOriginalQuestionInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$UserUpdateOneRequiredWithoutQuestionsInput? user;

  final Input$QuestionUpdateManyWithoutOriginalQuestionInput? childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateWithoutOriginalQuestionInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$user = user;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$user,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUpdateWithoutOriginalQuestionInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$UserUpdateOneRequiredWithoutQuestionsInput? Function()? user,
          Input$QuestionUpdateManyWithoutOriginalQuestionInput? Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUpdateWithoutOriginalQuestionInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          user: user == null ? this.user : user(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateWithoutUserInput {
  Input$QuestionUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$EnumQuestionTypeFieldUpdateOperationsInput? type;

  final Input$EnumContentTypeFieldUpdateOperationsInput? contentType;

  final Input$StringFieldUpdateOperationsInput? content;

  final Input$EnumContentTypeFieldUpdateOperationsInput? answerType;

  final List<String?>? answers;

  final Input$QuestionUpdateOneWithoutChildrensInput? originalQuestion;

  final Input$QuestionUpdateManyWithoutOriginalQuestionInput? childrens;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ExamQuestionUpdateManyWithoutQuestionInput? examquestions;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers == null ? null : Object.hashAll(l$answers.map((v) => v)),
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != null && lOther$answers != null) {
      if (l$answers.length != lOther$answers.length) return false;
      for (int i = 0; i < l$answers.length; i++) {
        final l$answers$entry = l$answers[i];
        final lOther$answers$entry = lOther$answers[i];
        if (l$answers$entry != lOther$answers$entry) return false;
      }
    } else if (l$answers != lOther$answers) {
      return false;
    }

    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$EnumQuestionTypeFieldUpdateOperationsInput? Function()? type,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              contentType,
          Input$StringFieldUpdateOperationsInput? Function()? content,
          Input$EnumContentTypeFieldUpdateOperationsInput? Function()?
              answerType,
          List<String?>? Function()? answers,
          Input$QuestionUpdateOneWithoutChildrensInput? Function()?
              originalQuestion,
          Input$QuestionUpdateManyWithoutOriginalQuestionInput? Function()?
              childrens,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ExamQuestionUpdateManyWithoutQuestionInput? Function()?
              examquestions}) =>
      Input$QuestionUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput {
  Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput(
      {required this.where, required this.data});

  @override
  factory Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInputFromJson(
          json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput data;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput? data}) =>
      Input$QuestionUpdateWithWhereUniqueWithoutOriginalQuestionInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpdateWithWhereUniqueWithoutUserInput {
  Input$QuestionUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$QuestionUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$QuestionUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedUpdateWithoutUserInput? data}) =>
      Input$QuestionUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpsertWithoutChildrensInput {
  Input$QuestionUpsertWithoutChildrensInput(
      {required this.update, required this.create});

  @override
  factory Input$QuestionUpsertWithoutChildrensInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpsertWithoutChildrensInputFromJson(json);

  final Input$QuestionUncheckedUpdateWithoutChildrensInput update;

  final Input$QuestionUncheckedCreateWithoutChildrensInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpsertWithoutChildrensInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpsertWithoutChildrensInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionUpsertWithoutChildrensInput copyWith(
          {Input$QuestionUncheckedUpdateWithoutChildrensInput? update,
          Input$QuestionUncheckedCreateWithoutChildrensInput? create}) =>
      Input$QuestionUpsertWithoutChildrensInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpsertWithoutExamquestionsInput {
  Input$QuestionUpsertWithoutExamquestionsInput(
      {required this.update, required this.create});

  @override
  factory Input$QuestionUpsertWithoutExamquestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpsertWithoutExamquestionsInputFromJson(json);

  final Input$QuestionUncheckedUpdateWithoutExamquestionsInput update;

  final Input$QuestionUncheckedCreateWithoutExamquestionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpsertWithoutExamquestionsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpsertWithoutExamquestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionUpsertWithoutExamquestionsInput copyWith(
          {Input$QuestionUncheckedUpdateWithoutExamquestionsInput? update,
          Input$QuestionUncheckedCreateWithoutExamquestionsInput? create}) =>
      Input$QuestionUpsertWithoutExamquestionsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput {
  Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInputFromJson(
          json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput update;

  final Input$QuestionUncheckedCreateWithoutOriginalQuestionInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInputToJson(
          this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedUpdateWithoutOriginalQuestionInput? update,
          Input$QuestionUncheckedCreateWithoutOriginalQuestionInput? create}) =>
      Input$QuestionUpsertWithWhereUniqueWithoutOriginalQuestionInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionUpsertWithWhereUniqueWithoutUserInput {
  Input$QuestionUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$QuestionUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$QuestionUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$QuestionWhereUniqueInput where;

  final Input$QuestionUncheckedUpdateWithoutUserInput update;

  final Input$QuestionUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$QuestionUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$QuestionUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$QuestionWhereUniqueInput? where,
          Input$QuestionUncheckedUpdateWithoutUserInput? update,
          Input$QuestionUncheckedCreateWithoutUserInput? create}) =>
      Input$QuestionUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionWhereInput {
  Input$QuestionWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.type,
      this.contentType,
      this.content,
      this.answerType,
      this.answers,
      this.userId,
      this.user,
      this.originalQuestionId,
      this.originalQuestion,
      this.childrens,
      this.createdAt,
      this.updatedAt,
      this.examquestions});

  @override
  factory Input$QuestionWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionWhereInputFromJson(json);

  final List<Input$QuestionWhereInput?>? AND;

  final List<Input$QuestionWhereInput?>? OR;

  final List<Input$QuestionWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$EnumQuestionTypeFilter? type;

  final Input$EnumContentTypeFilter? contentType;

  final Input$StringFilter? content;

  final Input$EnumContentTypeFilter? answerType;

  final Input$StringNullableListFilter? answers;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$StringNullableFilter? originalQuestionId;

  final Input$QuestionWhereInput? originalQuestion;

  final Input$QuestionListRelationFilter? childrens;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ExamQuestionListRelationFilter? examquestions;

  Map<String, dynamic> toJson() => _$Input$QuestionWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$type = type;
    final l$contentType = contentType;
    final l$content = content;
    final l$answerType = answerType;
    final l$answers = answers;
    final l$userId = userId;
    final l$user = user;
    final l$originalQuestionId = originalQuestionId;
    final l$originalQuestion = originalQuestion;
    final l$childrens = childrens;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$examquestions = examquestions;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$type,
      l$contentType,
      l$content,
      l$answerType,
      l$answers,
      l$userId,
      l$user,
      l$originalQuestionId,
      l$originalQuestion,
      l$childrens,
      l$createdAt,
      l$updatedAt,
      l$examquestions
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (l$contentType != lOther$contentType) return false;
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) return false;
    final l$answerType = answerType;
    final lOther$answerType = other.answerType;
    if (l$answerType != lOther$answerType) return false;
    final l$answers = answers;
    final lOther$answers = other.answers;
    if (l$answers != lOther$answers) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$originalQuestionId = originalQuestionId;
    final lOther$originalQuestionId = other.originalQuestionId;
    if (l$originalQuestionId != lOther$originalQuestionId) return false;
    final l$originalQuestion = originalQuestion;
    final lOther$originalQuestion = other.originalQuestion;
    if (l$originalQuestion != lOther$originalQuestion) return false;
    final l$childrens = childrens;
    final lOther$childrens = other.childrens;
    if (l$childrens != lOther$childrens) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$examquestions = examquestions;
    final lOther$examquestions = other.examquestions;
    if (l$examquestions != lOther$examquestions) return false;
    return true;
  }

  Input$QuestionWhereInput copyWith(
          {List<Input$QuestionWhereInput?>? Function()? AND,
          List<Input$QuestionWhereInput?>? Function()? OR,
          List<Input$QuestionWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$EnumQuestionTypeFilter? Function()? type,
          Input$EnumContentTypeFilter? Function()? contentType,
          Input$StringFilter? Function()? content,
          Input$EnumContentTypeFilter? Function()? answerType,
          Input$StringNullableListFilter? Function()? answers,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$StringNullableFilter? Function()? originalQuestionId,
          Input$QuestionWhereInput? Function()? originalQuestion,
          Input$QuestionListRelationFilter? Function()? childrens,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ExamQuestionListRelationFilter? Function()? examquestions}) =>
      Input$QuestionWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          type: type == null ? this.type : type(),
          contentType: contentType == null ? this.contentType : contentType(),
          content: content == null ? this.content : content(),
          answerType: answerType == null ? this.answerType : answerType(),
          answers: answers == null ? this.answers : answers(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          originalQuestionId: originalQuestionId == null
              ? this.originalQuestionId
              : originalQuestionId(),
          originalQuestion: originalQuestion == null
              ? this.originalQuestion
              : originalQuestion(),
          childrens: childrens == null ? this.childrens : childrens(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          examquestions:
              examquestions == null ? this.examquestions : examquestions());
}

@JsonSerializable(explicitToJson: true)
class Input$QuestionWhereUniqueInput {
  Input$QuestionWhereUniqueInput({this.id});

  @override
  factory Input$QuestionWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$QuestionWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() => _$Input$QuestionWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$QuestionWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$QuestionWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$QuestionWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCountOrderByAggregateInput {
  Input$RegencyCountOrderByAggregateInput(
      {this.id, this.name, this.provinceId});

  @override
  factory Input$RegencyCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([l$id, l$name, l$provinceId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? provinceId}) =>
      Input$RegencyCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateInput {
  Input$RegencyCreateInput(
      {this.id,
      required this.name,
      required this.province,
      this.users,
      this.School});

  @override
  factory Input$RegencyCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyCreateInputFromJson(json);

  final String? id;

  final String name;

  final Input$ProvinceCreateNestedOneWithoutRegenciesInput province;

  final Input$UserCreateNestedManyWithoutRegencyInput? users;

  final Input$SchoolCreateNestedManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() => _$Input$RegencyCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$province = province;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$province, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyCreateInput copyWith(
          {String? Function()? id,
          String? name,
          Input$ProvinceCreateNestedOneWithoutRegenciesInput? province,
          Input$UserCreateNestedManyWithoutRegencyInput? Function()? users,
          Input$SchoolCreateNestedManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          province: province == null ? this.province : province,
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateManyInput {
  Input$RegencyCreateManyInput(
      {this.id, required this.name, required this.provinceId});

  @override
  factory Input$RegencyCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String provinceId;

  Map<String, dynamic> toJson() => _$Input$RegencyCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([l$id, l$name, l$provinceId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyCreateManyInput copyWith(
          {String? Function()? id, String? name, String? provinceId}) =>
      Input$RegencyCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          provinceId: provinceId == null ? this.provinceId : provinceId);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateManyProvinceInput {
  Input$RegencyCreateManyProvinceInput({this.id, required this.name});

  @override
  factory Input$RegencyCreateManyProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateManyProvinceInputFromJson(json);

  final String? id;

  final String name;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateManyProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([l$id, l$name]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateManyProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    return true;
  }

  Input$RegencyCreateManyProvinceInput copyWith(
          {String? Function()? id, String? name}) =>
      Input$RegencyCreateManyProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateManyProvinceInputEnvelope {
  Input$RegencyCreateManyProvinceInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$RegencyCreateManyProvinceInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateManyProvinceInputEnvelopeFromJson(json);

  final Input$RegencyCreateManyProvinceInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateManyProvinceInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateManyProvinceInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$RegencyCreateManyProvinceInputEnvelope copyWith(
          {Input$RegencyCreateManyProvinceInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$RegencyCreateManyProvinceInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateNestedManyWithoutProvinceInput {
  Input$RegencyCreateNestedManyWithoutProvinceInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$RegencyCreateNestedManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateNestedManyWithoutProvinceInputFromJson(json);

  final List<Input$RegencyCreateWithoutProvinceInput?>? create;

  final List<Input$RegencyCreateOrConnectWithoutProvinceInput?>?
      connectOrCreate;

  final Input$RegencyCreateManyProvinceInputEnvelope? createMany;

  final List<Input$RegencyWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateNestedManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateNestedManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$RegencyCreateNestedManyWithoutProvinceInput copyWith(
          {List<Input$RegencyCreateWithoutProvinceInput?>? Function()? create,
          List<Input$RegencyCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          Input$RegencyCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$RegencyWhereUniqueInput?>? Function()? connect}) =>
      Input$RegencyCreateNestedManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateNestedOneWithoutSchoolInput {
  Input$RegencyCreateNestedOneWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$RegencyCreateNestedOneWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateNestedOneWithoutSchoolInputFromJson(json);

  final Input$RegencyUncheckedCreateWithoutSchoolInput? create;

  final Input$RegencyCreateOrConnectWithoutSchoolInput? connectOrCreate;

  final Input$RegencyWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateNestedOneWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateNestedOneWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$RegencyCreateNestedOneWithoutSchoolInput copyWith(
          {Input$RegencyUncheckedCreateWithoutSchoolInput? Function()? create,
          Input$RegencyCreateOrConnectWithoutSchoolInput? Function()?
              connectOrCreate,
          Input$RegencyWhereUniqueInput? Function()? connect}) =>
      Input$RegencyCreateNestedOneWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateNestedOneWithoutUsersInput {
  Input$RegencyCreateNestedOneWithoutUsersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$RegencyCreateNestedOneWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateNestedOneWithoutUsersInputFromJson(json);

  final Input$RegencyUncheckedCreateWithoutUsersInput? create;

  final Input$RegencyCreateOrConnectWithoutUsersInput? connectOrCreate;

  final Input$RegencyWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateNestedOneWithoutUsersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateNestedOneWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$RegencyCreateNestedOneWithoutUsersInput copyWith(
          {Input$RegencyUncheckedCreateWithoutUsersInput? Function()? create,
          Input$RegencyCreateOrConnectWithoutUsersInput? Function()?
              connectOrCreate,
          Input$RegencyWhereUniqueInput? Function()? connect}) =>
      Input$RegencyCreateNestedOneWithoutUsersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateOrConnectWithoutProvinceInput {
  Input$RegencyCreateOrConnectWithoutProvinceInput(
      {required this.where, required this.create});

  @override
  factory Input$RegencyCreateOrConnectWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateOrConnectWithoutProvinceInputFromJson(json);

  final Input$RegencyWhereUniqueInput where;

  final Input$RegencyUncheckedCreateWithoutProvinceInput create;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateOrConnectWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateOrConnectWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$RegencyCreateOrConnectWithoutProvinceInput copyWith(
          {Input$RegencyWhereUniqueInput? where,
          Input$RegencyUncheckedCreateWithoutProvinceInput? create}) =>
      Input$RegencyCreateOrConnectWithoutProvinceInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateOrConnectWithoutSchoolInput {
  Input$RegencyCreateOrConnectWithoutSchoolInput(
      {required this.where, required this.create});

  @override
  factory Input$RegencyCreateOrConnectWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateOrConnectWithoutSchoolInputFromJson(json);

  final Input$RegencyWhereUniqueInput where;

  final Input$RegencyUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateOrConnectWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateOrConnectWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$RegencyCreateOrConnectWithoutSchoolInput copyWith(
          {Input$RegencyWhereUniqueInput? where,
          Input$RegencyUncheckedCreateWithoutSchoolInput? create}) =>
      Input$RegencyCreateOrConnectWithoutSchoolInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateOrConnectWithoutUsersInput {
  Input$RegencyCreateOrConnectWithoutUsersInput(
      {required this.where, required this.create});

  @override
  factory Input$RegencyCreateOrConnectWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateOrConnectWithoutUsersInputFromJson(json);

  final Input$RegencyWhereUniqueInput where;

  final Input$RegencyUncheckedCreateWithoutUsersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateOrConnectWithoutUsersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateOrConnectWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$RegencyCreateOrConnectWithoutUsersInput copyWith(
          {Input$RegencyWhereUniqueInput? where,
          Input$RegencyUncheckedCreateWithoutUsersInput? create}) =>
      Input$RegencyCreateOrConnectWithoutUsersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateWithoutProvinceInput {
  Input$RegencyCreateWithoutProvinceInput(
      {this.id, required this.name, this.users, this.School});

  @override
  factory Input$RegencyCreateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateWithoutProvinceInputFromJson(json);

  final String? id;

  final String name;

  final Input$UserCreateNestedManyWithoutRegencyInput? users;

  final Input$SchoolCreateNestedManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyCreateWithoutProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          Input$UserCreateNestedManyWithoutRegencyInput? Function()? users,
          Input$SchoolCreateNestedManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyCreateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateWithoutSchoolInput {
  Input$RegencyCreateWithoutSchoolInput(
      {this.id, required this.name, required this.province, this.users});

  @override
  factory Input$RegencyCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final Input$ProvinceCreateNestedOneWithoutRegenciesInput province;

  final Input$UserCreateNestedManyWithoutRegencyInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$province = province;
    final l$users = users;
    return Object.hashAll([l$id, l$name, l$province, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$RegencyCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          Input$ProvinceCreateNestedOneWithoutRegenciesInput? province,
          Input$UserCreateNestedManyWithoutRegencyInput? Function()? users}) =>
      Input$RegencyCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          province: province == null ? this.province : province,
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyCreateWithoutUsersInput {
  Input$RegencyCreateWithoutUsersInput(
      {this.id, required this.name, required this.province, this.School});

  @override
  factory Input$RegencyCreateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyCreateWithoutUsersInputFromJson(json);

  final String? id;

  final String name;

  final Input$ProvinceCreateNestedOneWithoutRegenciesInput province;

  final Input$SchoolCreateNestedManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyCreateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$province = province;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$province, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyCreateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyCreateWithoutUsersInput copyWith(
          {String? Function()? id,
          String? name,
          Input$ProvinceCreateNestedOneWithoutRegenciesInput? province,
          Input$SchoolCreateNestedManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyCreateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          province: province == null ? this.province : province,
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyListRelationFilter {
  Input$RegencyListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$RegencyListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyListRelationFilterFromJson(json);

  final Input$RegencyWhereInput? every;

  final Input$RegencyWhereInput? some;

  final Input$RegencyWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$RegencyListRelationFilter copyWith(
          {Input$RegencyWhereInput? Function()? every,
          Input$RegencyWhereInput? Function()? some,
          Input$RegencyWhereInput? Function()? none}) =>
      Input$RegencyListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyMaxOrderByAggregateInput {
  Input$RegencyMaxOrderByAggregateInput({this.id, this.name, this.provinceId});

  @override
  factory Input$RegencyMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([l$id, l$name, l$provinceId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? provinceId}) =>
      Input$RegencyMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyMinOrderByAggregateInput {
  Input$RegencyMinOrderByAggregateInput({this.id, this.name, this.provinceId});

  @override
  factory Input$RegencyMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([l$id, l$name, l$provinceId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? provinceId}) =>
      Input$RegencyMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyOrderByRelationAggregateInput {
  Input$RegencyOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$RegencyOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$RegencyOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$RegencyOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyOrderByWithAggregationInput {
  Input$RegencyOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.provinceId,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$RegencyOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(name: '_count')
  final Input$RegencyCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$RegencyMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$RegencyMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll(
        [l$id, l$name, l$provinceId, l$$_count, l$$_max, l$$_min]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$RegencyOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? provinceId,
          Input$RegencyCountOrderByAggregateInput? Function()? $_count,
          Input$RegencyMaxOrderByAggregateInput? Function()? $_max,
          Input$RegencyMinOrderByAggregateInput? Function()? $_min}) =>
      Input$RegencyOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyOrderByWithRelationInput {
  Input$RegencyOrderByWithRelationInput(
      {this.id,
      this.name,
      this.provinceId,
      this.province,
      this.users,
      this.School});

  @override
  factory Input$RegencyOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  final Input$ProvinceOrderByWithRelationInput? province;

  final Input$UserOrderByRelationAggregateInput? users;

  final Input$SchoolOrderByRelationAggregateInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$province = province;
    final l$users = users;
    final l$School = School;
    return Object.hashAll(
        [l$id, l$name, l$provinceId, l$province, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? provinceId,
          Input$ProvinceOrderByWithRelationInput? Function()? province,
          Input$UserOrderByRelationAggregateInput? Function()? users,
          Input$SchoolOrderByRelationAggregateInput? Function()? School}) =>
      Input$RegencyOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          province: province == null ? this.province : province(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyRelationFilter {
  Input$RegencyRelationFilter({this.$is, this.isNot});

  @override
  factory Input$RegencyRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$RegencyWhereInput? $is;

  final Input$RegencyWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$RegencyRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$RegencyRelationFilter copyWith(
          {Input$RegencyWhereInput? Function()? $is,
          Input$RegencyWhereInput? Function()? isNot}) =>
      Input$RegencyRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyScalarWhereInput {
  Input$RegencyScalarWhereInput(
      {this.AND, this.OR, this.NOT, this.id, this.name, this.provinceId});

  @override
  factory Input$RegencyScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyScalarWhereInputFromJson(json);

  final List<Input$RegencyScalarWhereInput?>? AND;

  final List<Input$RegencyScalarWhereInput?>? OR;

  final List<Input$RegencyScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? provinceId;

  Map<String, dynamic> toJson() => _$Input$RegencyScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$provinceId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyScalarWhereInput copyWith(
          {List<Input$RegencyScalarWhereInput?>? Function()? AND,
          List<Input$RegencyScalarWhereInput?>? Function()? OR,
          List<Input$RegencyScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? provinceId}) =>
      Input$RegencyScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyScalarWhereWithAggregatesInput {
  Input$RegencyScalarWhereWithAggregatesInput(
      {this.AND, this.OR, this.NOT, this.id, this.name, this.provinceId});

  @override
  factory Input$RegencyScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$RegencyScalarWhereWithAggregatesInput?>? AND;

  final List<Input$RegencyScalarWhereWithAggregatesInput?>? OR;

  final List<Input$RegencyScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? provinceId;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$provinceId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyScalarWhereWithAggregatesInput copyWith(
          {List<Input$RegencyScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$RegencyScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$RegencyScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? provinceId}) =>
      Input$RegencyScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedCreateInput {
  Input$RegencyUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.provinceId,
      this.users,
      this.School});

  @override
  factory Input$RegencyUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String provinceId;

  final Input$UserUncheckedCreateNestedManyWithoutRegencyInput? users;

  final Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$provinceId, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? provinceId,
          Input$UserUncheckedCreateNestedManyWithoutRegencyInput? Function()?
              users,
          Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          provinceId: provinceId == null ? this.provinceId : provinceId,
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput {
  Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedCreateNestedManyWithoutProvinceInputFromJson(
          json);

  final List<Input$RegencyCreateWithoutProvinceInput?>? create;

  final List<Input$RegencyCreateOrConnectWithoutProvinceInput?>?
      connectOrCreate;

  final Input$RegencyCreateManyProvinceInputEnvelope? createMany;

  final List<Input$RegencyWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedCreateNestedManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput copyWith(
          {List<Input$RegencyCreateWithoutProvinceInput?>? Function()? create,
          List<Input$RegencyCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          Input$RegencyCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$RegencyWhereUniqueInput?>? Function()? connect}) =>
      Input$RegencyUncheckedCreateNestedManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedCreateWithoutProvinceInput {
  Input$RegencyUncheckedCreateWithoutProvinceInput(
      {this.id, required this.name, this.users, this.School});

  @override
  factory Input$RegencyUncheckedCreateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedCreateWithoutProvinceInputFromJson(json);

  final String? id;

  final String name;

  final Input$UserUncheckedCreateNestedManyWithoutRegencyInput? users;

  final Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedCreateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedCreateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUncheckedCreateWithoutProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          Input$UserUncheckedCreateNestedManyWithoutRegencyInput? Function()?
              users,
          Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyUncheckedCreateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedCreateWithoutSchoolInput {
  Input$RegencyUncheckedCreateWithoutSchoolInput(
      {this.id, required this.name, required this.provinceId, this.users});

  @override
  factory Input$RegencyUncheckedCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final String provinceId;

  final Input$UserUncheckedCreateNestedManyWithoutRegencyInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$users = users;
    return Object.hashAll([l$id, l$name, l$provinceId, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$RegencyUncheckedCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          String? provinceId,
          Input$UserUncheckedCreateNestedManyWithoutRegencyInput? Function()?
              users}) =>
      Input$RegencyUncheckedCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          provinceId: provinceId == null ? this.provinceId : provinceId,
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedCreateWithoutUsersInput {
  Input$RegencyUncheckedCreateWithoutUsersInput(
      {this.id, required this.name, required this.provinceId, this.School});

  @override
  factory Input$RegencyUncheckedCreateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedCreateWithoutUsersInputFromJson(json);

  final String? id;

  final String name;

  final String provinceId;

  final Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedCreateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$provinceId, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedCreateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUncheckedCreateWithoutUsersInput copyWith(
          {String? Function()? id,
          String? name,
          String? provinceId,
          Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyUncheckedCreateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          provinceId: provinceId == null ? this.provinceId : provinceId,
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateInput {
  Input$RegencyUncheckedUpdateInput(
      {this.id, this.name, this.provinceId, this.users, this.School});

  @override
  factory Input$RegencyUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$UserUncheckedUpdateManyWithoutRegencyInput? users;

  final Input$SchoolUncheckedUpdateManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$provinceId, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$UserUncheckedUpdateManyWithoutRegencyInput? Function()? users,
          Input$SchoolUncheckedUpdateManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateManyInput {
  Input$RegencyUncheckedUpdateManyInput({this.id, this.name, this.provinceId});

  @override
  factory Input$RegencyUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    return Object.hashAll([l$id, l$name, l$provinceId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$RegencyUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId}) =>
      Input$RegencyUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateManyWithoutProvinceInput {
  Input$RegencyUncheckedUpdateManyWithoutProvinceInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$RegencyUncheckedUpdateManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateManyWithoutProvinceInputFromJson(json);

  final List<Input$RegencyCreateWithoutProvinceInput?>? create;

  final List<Input$RegencyCreateOrConnectWithoutProvinceInput?>?
      connectOrCreate;

  final List<Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput?>? upsert;

  final Input$RegencyCreateManyProvinceInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$RegencyWhereUniqueInput?>? $set;

  final List<Input$RegencyWhereUniqueInput?>? disconnect;

  final List<Input$RegencyWhereUniqueInput?>? delete;

  final List<Input$RegencyWhereUniqueInput?>? connect;

  final List<Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput?>? update;

  final List<Input$RegencyUpdateManyWithWhereWithoutProvinceInput?>? updateMany;

  final List<Input$RegencyScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$RegencyUncheckedUpdateManyWithoutProvinceInput copyWith(
          {List<Input$RegencyCreateWithoutProvinceInput?>? Function()? create,
          List<Input$RegencyCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          List<Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              upsert,
          Input$RegencyCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$RegencyWhereUniqueInput?>? Function()? $set,
          List<Input$RegencyWhereUniqueInput?>? Function()? disconnect,
          List<Input$RegencyWhereUniqueInput?>? Function()? delete,
          List<Input$RegencyWhereUniqueInput?>? Function()? connect,
          List<Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              update,
          List<Input$RegencyUpdateManyWithWhereWithoutProvinceInput?>?
                  Function()?
              updateMany,
          List<Input$RegencyScalarWhereInput?>? Function()? deleteMany}) =>
      Input$RegencyUncheckedUpdateManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateManyWithoutRegenciesInput {
  Input$RegencyUncheckedUpdateManyWithoutRegenciesInput({this.id, this.name});

  @override
  factory Input$RegencyUncheckedUpdateManyWithoutRegenciesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateManyWithoutRegenciesInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateManyWithoutRegenciesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([l$id, l$name]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateManyWithoutRegenciesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    return true;
  }

  Input$RegencyUncheckedUpdateManyWithoutRegenciesInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name}) =>
      Input$RegencyUncheckedUpdateManyWithoutRegenciesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateWithoutProvinceInput {
  Input$RegencyUncheckedUpdateWithoutProvinceInput(
      {this.id, this.name, this.users, this.School});

  @override
  factory Input$RegencyUncheckedUpdateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateWithoutProvinceInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$UserUncheckedUpdateManyWithoutRegencyInput? users;

  final Input$SchoolUncheckedUpdateManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUncheckedUpdateWithoutProvinceInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$UserUncheckedUpdateManyWithoutRegencyInput? Function()? users,
          Input$SchoolUncheckedUpdateManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyUncheckedUpdateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateWithoutSchoolInput {
  Input$RegencyUncheckedUpdateWithoutSchoolInput(
      {this.id, this.name, this.provinceId, this.users});

  @override
  factory Input$RegencyUncheckedUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$UserUncheckedUpdateManyWithoutRegencyInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$users = users;
    return Object.hashAll([l$id, l$name, l$provinceId, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$RegencyUncheckedUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$UserUncheckedUpdateManyWithoutRegencyInput? Function()?
              users}) =>
      Input$RegencyUncheckedUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUncheckedUpdateWithoutUsersInput {
  Input$RegencyUncheckedUpdateWithoutUsersInput(
      {this.id, this.name, this.provinceId, this.School});

  @override
  factory Input$RegencyUncheckedUpdateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUncheckedUpdateWithoutUsersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$SchoolUncheckedUpdateManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUncheckedUpdateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$provinceId, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUncheckedUpdateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUncheckedUpdateWithoutUsersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$SchoolUncheckedUpdateManyWithoutRegencyInput? Function()?
              School}) =>
      Input$RegencyUncheckedUpdateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateInput {
  Input$RegencyUpdateInput(
      {this.id, this.name, this.province, this.users, this.School});

  @override
  factory Input$RegencyUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$ProvinceUpdateOneRequiredWithoutRegenciesInput? province;

  final Input$UserUpdateManyWithoutRegencyInput? users;

  final Input$SchoolUpdateManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() => _$Input$RegencyUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$province = province;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$province, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$ProvinceUpdateOneRequiredWithoutRegenciesInput? Function()?
              province,
          Input$UserUpdateManyWithoutRegencyInput? Function()? users,
          Input$SchoolUpdateManyWithoutRegencyInput? Function()? School}) =>
      Input$RegencyUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          province: province == null ? this.province : province(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateManyMutationInput {
  Input$RegencyUpdateManyMutationInput({this.id, this.name});

  @override
  factory Input$RegencyUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([l$id, l$name]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    return true;
  }

  Input$RegencyUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name}) =>
      Input$RegencyUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateManyWithoutProvinceInput {
  Input$RegencyUpdateManyWithoutProvinceInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$RegencyUpdateManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateManyWithoutProvinceInputFromJson(json);

  final List<Input$RegencyCreateWithoutProvinceInput?>? create;

  final List<Input$RegencyCreateOrConnectWithoutProvinceInput?>?
      connectOrCreate;

  final List<Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput?>? upsert;

  final Input$RegencyCreateManyProvinceInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$RegencyWhereUniqueInput?>? $set;

  final List<Input$RegencyWhereUniqueInput?>? disconnect;

  final List<Input$RegencyWhereUniqueInput?>? delete;

  final List<Input$RegencyWhereUniqueInput?>? connect;

  final List<Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput?>? update;

  final List<Input$RegencyUpdateManyWithWhereWithoutProvinceInput?>? updateMany;

  final List<Input$RegencyScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$RegencyUpdateManyWithoutProvinceInput copyWith(
          {List<Input$RegencyCreateWithoutProvinceInput?>? Function()? create,
          List<Input$RegencyCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          List<Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              upsert,
          Input$RegencyCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$RegencyWhereUniqueInput?>? Function()? $set,
          List<Input$RegencyWhereUniqueInput?>? Function()? disconnect,
          List<Input$RegencyWhereUniqueInput?>? Function()? delete,
          List<Input$RegencyWhereUniqueInput?>? Function()? connect,
          List<Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              update,
          List<Input$RegencyUpdateManyWithWhereWithoutProvinceInput?>?
                  Function()?
              updateMany,
          List<Input$RegencyScalarWhereInput?>? Function()? deleteMany}) =>
      Input$RegencyUpdateManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateManyWithWhereWithoutProvinceInput {
  Input$RegencyUpdateManyWithWhereWithoutProvinceInput(
      {required this.where, required this.data});

  @override
  factory Input$RegencyUpdateManyWithWhereWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateManyWithWhereWithoutProvinceInputFromJson(json);

  final Input$RegencyScalarWhereInput where;

  final Input$RegencyUncheckedUpdateManyWithoutRegenciesInput data;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateManyWithWhereWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateManyWithWhereWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$RegencyUpdateManyWithWhereWithoutProvinceInput copyWith(
          {Input$RegencyScalarWhereInput? where,
          Input$RegencyUncheckedUpdateManyWithoutRegenciesInput? data}) =>
      Input$RegencyUpdateManyWithWhereWithoutProvinceInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateOneRequiredWithoutSchoolInput {
  Input$RegencyUpdateOneRequiredWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$RegencyUpdateOneRequiredWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateOneRequiredWithoutSchoolInputFromJson(json);

  final Input$RegencyUncheckedCreateWithoutSchoolInput? create;

  final Input$RegencyCreateOrConnectWithoutSchoolInput? connectOrCreate;

  final Input$RegencyUpsertWithoutSchoolInput? upsert;

  final Input$RegencyWhereUniqueInput? connect;

  final Input$RegencyUncheckedUpdateWithoutSchoolInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateOneRequiredWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateOneRequiredWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$RegencyUpdateOneRequiredWithoutSchoolInput copyWith(
          {Input$RegencyUncheckedCreateWithoutSchoolInput? Function()? create,
          Input$RegencyCreateOrConnectWithoutSchoolInput? Function()?
              connectOrCreate,
          Input$RegencyUpsertWithoutSchoolInput? Function()? upsert,
          Input$RegencyWhereUniqueInput? Function()? connect,
          Input$RegencyUncheckedUpdateWithoutSchoolInput? Function()?
              update}) =>
      Input$RegencyUpdateOneRequiredWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateOneRequiredWithoutUsersInput {
  Input$RegencyUpdateOneRequiredWithoutUsersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$RegencyUpdateOneRequiredWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateOneRequiredWithoutUsersInputFromJson(json);

  final Input$RegencyUncheckedCreateWithoutUsersInput? create;

  final Input$RegencyCreateOrConnectWithoutUsersInput? connectOrCreate;

  final Input$RegencyUpsertWithoutUsersInput? upsert;

  final Input$RegencyWhereUniqueInput? connect;

  final Input$RegencyUncheckedUpdateWithoutUsersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateOneRequiredWithoutUsersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateOneRequiredWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$RegencyUpdateOneRequiredWithoutUsersInput copyWith(
          {Input$RegencyUncheckedCreateWithoutUsersInput? Function()? create,
          Input$RegencyCreateOrConnectWithoutUsersInput? Function()?
              connectOrCreate,
          Input$RegencyUpsertWithoutUsersInput? Function()? upsert,
          Input$RegencyWhereUniqueInput? Function()? connect,
          Input$RegencyUncheckedUpdateWithoutUsersInput? Function()? update}) =>
      Input$RegencyUpdateOneRequiredWithoutUsersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateWithoutProvinceInput {
  Input$RegencyUpdateWithoutProvinceInput(
      {this.id, this.name, this.users, this.School});

  @override
  factory Input$RegencyUpdateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateWithoutProvinceInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$UserUpdateManyWithoutRegencyInput? users;

  final Input$SchoolUpdateManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$users, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUpdateWithoutProvinceInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$UserUpdateManyWithoutRegencyInput? Function()? users,
          Input$SchoolUpdateManyWithoutRegencyInput? Function()? School}) =>
      Input$RegencyUpdateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateWithoutSchoolInput {
  Input$RegencyUpdateWithoutSchoolInput(
      {this.id, this.name, this.province, this.users});

  @override
  factory Input$RegencyUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$ProvinceUpdateOneRequiredWithoutRegenciesInput? province;

  final Input$UserUpdateManyWithoutRegencyInput? users;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$province = province;
    final l$users = users;
    return Object.hashAll([l$id, l$name, l$province, l$users]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    return true;
  }

  Input$RegencyUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$ProvinceUpdateOneRequiredWithoutRegenciesInput? Function()?
              province,
          Input$UserUpdateManyWithoutRegencyInput? Function()? users}) =>
      Input$RegencyUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          province: province == null ? this.province : province(),
          users: users == null ? this.users : users());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateWithoutUsersInput {
  Input$RegencyUpdateWithoutUsersInput(
      {this.id, this.name, this.province, this.School});

  @override
  factory Input$RegencyUpdateWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateWithoutUsersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$ProvinceUpdateOneRequiredWithoutRegenciesInput? province;

  final Input$SchoolUpdateManyWithoutRegencyInput? School;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$province = province;
    final l$School = School;
    return Object.hashAll([l$id, l$name, l$province, l$School]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyUpdateWithoutUsersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$ProvinceUpdateOneRequiredWithoutRegenciesInput? Function()?
              province,
          Input$SchoolUpdateManyWithoutRegencyInput? Function()? School}) =>
      Input$RegencyUpdateWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          province: province == null ? this.province : province(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput {
  Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput(
      {required this.where, required this.data});

  @override
  factory Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpdateWithWhereUniqueWithoutProvinceInputFromJson(json);

  final Input$RegencyWhereUniqueInput where;

  final Input$RegencyUncheckedUpdateWithoutProvinceInput data;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpdateWithWhereUniqueWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput copyWith(
          {Input$RegencyWhereUniqueInput? where,
          Input$RegencyUncheckedUpdateWithoutProvinceInput? data}) =>
      Input$RegencyUpdateWithWhereUniqueWithoutProvinceInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpsertWithoutSchoolInput {
  Input$RegencyUpsertWithoutSchoolInput(
      {required this.update, required this.create});

  @override
  factory Input$RegencyUpsertWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpsertWithoutSchoolInputFromJson(json);

  final Input$RegencyUncheckedUpdateWithoutSchoolInput update;

  final Input$RegencyUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpsertWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpsertWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$RegencyUpsertWithoutSchoolInput copyWith(
          {Input$RegencyUncheckedUpdateWithoutSchoolInput? update,
          Input$RegencyUncheckedCreateWithoutSchoolInput? create}) =>
      Input$RegencyUpsertWithoutSchoolInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpsertWithoutUsersInput {
  Input$RegencyUpsertWithoutUsersInput(
      {required this.update, required this.create});

  @override
  factory Input$RegencyUpsertWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpsertWithoutUsersInputFromJson(json);

  final Input$RegencyUncheckedUpdateWithoutUsersInput update;

  final Input$RegencyUncheckedCreateWithoutUsersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpsertWithoutUsersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpsertWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$RegencyUpsertWithoutUsersInput copyWith(
          {Input$RegencyUncheckedUpdateWithoutUsersInput? update,
          Input$RegencyUncheckedCreateWithoutUsersInput? create}) =>
      Input$RegencyUpsertWithoutUsersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput {
  Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$RegencyUpsertWithWhereUniqueWithoutProvinceInputFromJson(json);

  final Input$RegencyWhereUniqueInput where;

  final Input$RegencyUncheckedUpdateWithoutProvinceInput update;

  final Input$RegencyUncheckedCreateWithoutProvinceInput create;

  Map<String, dynamic> toJson() =>
      _$Input$RegencyUpsertWithWhereUniqueWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput copyWith(
          {Input$RegencyWhereUniqueInput? where,
          Input$RegencyUncheckedUpdateWithoutProvinceInput? update,
          Input$RegencyUncheckedCreateWithoutProvinceInput? create}) =>
      Input$RegencyUpsertWithWhereUniqueWithoutProvinceInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyWhereInput {
  Input$RegencyWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.provinceId,
      this.province,
      this.users,
      this.School});

  @override
  factory Input$RegencyWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyWhereInputFromJson(json);

  final List<Input$RegencyWhereInput?>? AND;

  final List<Input$RegencyWhereInput?>? OR;

  final List<Input$RegencyWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? provinceId;

  final Input$ProvinceWhereInput? province;

  final Input$UserListRelationFilter? users;

  final Input$SchoolListRelationFilter? School;

  Map<String, dynamic> toJson() => _$Input$RegencyWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$provinceId = provinceId;
    final l$province = province;
    final l$users = users;
    final l$School = School;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$provinceId,
      l$province,
      l$users,
      l$School
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$users = users;
    final lOther$users = other.users;
    if (l$users != lOther$users) return false;
    final l$School = School;
    final lOther$School = other.School;
    if (l$School != lOther$School) return false;
    return true;
  }

  Input$RegencyWhereInput copyWith(
          {List<Input$RegencyWhereInput?>? Function()? AND,
          List<Input$RegencyWhereInput?>? Function()? OR,
          List<Input$RegencyWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? provinceId,
          Input$ProvinceWhereInput? Function()? province,
          Input$UserListRelationFilter? Function()? users,
          Input$SchoolListRelationFilter? Function()? School}) =>
      Input$RegencyWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          province: province == null ? this.province : province(),
          users: users == null ? this.users : users(),
          School: School == null ? this.School : School());
}

@JsonSerializable(explicitToJson: true)
class Input$RegencyWhereUniqueInput {
  Input$RegencyWhereUniqueInput({this.id});

  @override
  factory Input$RegencyWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$RegencyWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() => _$Input$RegencyWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$RegencyWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$RegencyWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$RegencyWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolAvgOrderByAggregateInput {
  Input$SchoolAvgOrderByAggregateInput({this.levels});

  @override
  factory Input$SchoolAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? levels;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$levels = levels;
    return Object.hashAll([l$levels]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    return true;
  }

  Input$SchoolAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? levels}) =>
      Input$SchoolAvgOrderByAggregateInput(
          levels: levels == null ? this.levels : levels());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCountOrderByAggregateInput {
  Input$SchoolCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId});

  @override
  factory Input$SchoolCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? npsn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? levels;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? logoPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bannerPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? npsn,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? levels,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? logoPath,
          Enum$SortOrder? Function()? bannerPath,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId}) =>
      Input$SchoolCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateInput {
  Input$SchoolCreateInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.province,
      required this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolCreateInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final Input$ProvinceCreateNestedOneWithoutSchoolInput province;

  final Input$RegencyCreateNestedOneWithoutSchoolInput regency;

  final Input$SchoolStaffCreateNestedManyWithoutSchoolInput? schoolStaffs;

  final Input$UserCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() => _$Input$SchoolCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomCreateNestedManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          Input$ProvinceCreateNestedOneWithoutSchoolInput? province,
          Input$RegencyCreateNestedOneWithoutSchoolInput? regency,
          Input$SchoolStaffCreateNestedManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreatelevelsInput {
  Input$SchoolCreatelevelsInput({required this.$set});

  @override
  factory Input$SchoolCreatelevelsInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolCreatelevelsInputFromJson(json);

  @JsonKey(name: 'set')
  final int $set;

  Map<String, dynamic> toJson() => _$Input$SchoolCreatelevelsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreatelevelsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$SchoolCreatelevelsInput copyWith({int? $set}) =>
      Input$SchoolCreatelevelsInput($set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateManyInput {
  Input$SchoolCreateManyInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId,
      required this.regencyId});

  @override
  factory Input$SchoolCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  final String regencyId;

  Map<String, dynamic> toJson() => _$Input$SchoolCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId,
          String? regencyId}) =>
      Input$SchoolCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateManyProvinceInput {
  Input$SchoolCreateManyProvinceInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.regencyId});

  @override
  factory Input$SchoolCreateManyProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateManyProvinceInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateManyProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateManyProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolCreateManyProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? regencyId}) =>
      Input$SchoolCreateManyProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          regencyId: regencyId == null ? this.regencyId : regencyId);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateManyProvinceInputEnvelope {
  Input$SchoolCreateManyProvinceInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$SchoolCreateManyProvinceInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateManyProvinceInputEnvelopeFromJson(json);

  final Input$SchoolCreateManyProvinceInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateManyProvinceInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateManyProvinceInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$SchoolCreateManyProvinceInputEnvelope copyWith(
          {Input$SchoolCreateManyProvinceInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$SchoolCreateManyProvinceInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateManyRegencyInput {
  Input$SchoolCreateManyRegencyInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId});

  @override
  factory Input$SchoolCreateManyRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateManyRegencyInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateManyRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateManyRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    return true;
  }

  Input$SchoolCreateManyRegencyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId}) =>
      Input$SchoolCreateManyRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateManyRegencyInputEnvelope {
  Input$SchoolCreateManyRegencyInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$SchoolCreateManyRegencyInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateManyRegencyInputEnvelopeFromJson(json);

  final Input$SchoolCreateManyRegencyInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateManyRegencyInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateManyRegencyInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$SchoolCreateManyRegencyInputEnvelope copyWith(
          {Input$SchoolCreateManyRegencyInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$SchoolCreateManyRegencyInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateNestedManyWithoutProvinceInput {
  Input$SchoolCreateNestedManyWithoutProvinceInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolCreateNestedManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateNestedManyWithoutProvinceInputFromJson(json);

  final List<Input$SchoolCreateWithoutProvinceInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final Input$SchoolCreateManyProvinceInputEnvelope? createMany;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateNestedManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateNestedManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolCreateNestedManyWithoutProvinceInput copyWith(
          {List<Input$SchoolCreateWithoutProvinceInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          Input$SchoolCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolCreateNestedManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateNestedManyWithoutRegencyInput {
  Input$SchoolCreateNestedManyWithoutRegencyInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolCreateNestedManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateNestedManyWithoutRegencyInputFromJson(json);

  final List<Input$SchoolCreateWithoutRegencyInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final Input$SchoolCreateManyRegencyInputEnvelope? createMany;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateNestedManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateNestedManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolCreateNestedManyWithoutRegencyInput copyWith(
          {List<Input$SchoolCreateWithoutRegencyInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          Input$SchoolCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolCreateNestedManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateNestedOneWithoutClassroomsInput {
  Input$SchoolCreateNestedOneWithoutClassroomsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$SchoolCreateNestedOneWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateNestedOneWithoutClassroomsInputFromJson(json);

  final Input$SchoolUncheckedCreateWithoutClassroomsInput? create;

  final Input$SchoolCreateOrConnectWithoutClassroomsInput? connectOrCreate;

  final Input$SchoolWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateNestedOneWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateNestedOneWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$SchoolCreateNestedOneWithoutClassroomsInput copyWith(
          {Input$SchoolUncheckedCreateWithoutClassroomsInput? Function()?
              create,
          Input$SchoolCreateOrConnectWithoutClassroomsInput? Function()?
              connectOrCreate,
          Input$SchoolWhereUniqueInput? Function()? connect}) =>
      Input$SchoolCreateNestedOneWithoutClassroomsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateNestedOneWithoutSchoolStaffsInput {
  Input$SchoolCreateNestedOneWithoutSchoolStaffsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$SchoolCreateNestedOneWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateNestedOneWithoutSchoolStaffsInputFromJson(json);

  final Input$SchoolUncheckedCreateWithoutSchoolStaffsInput? create;

  final Input$SchoolCreateOrConnectWithoutSchoolStaffsInput? connectOrCreate;

  final Input$SchoolWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateNestedOneWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateNestedOneWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$SchoolCreateNestedOneWithoutSchoolStaffsInput copyWith(
          {Input$SchoolUncheckedCreateWithoutSchoolStaffsInput? Function()?
              create,
          Input$SchoolCreateOrConnectWithoutSchoolStaffsInput? Function()?
              connectOrCreate,
          Input$SchoolWhereUniqueInput? Function()? connect}) =>
      Input$SchoolCreateNestedOneWithoutSchoolStaffsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateNestedOneWithoutStudentsInput {
  Input$SchoolCreateNestedOneWithoutStudentsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$SchoolCreateNestedOneWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateNestedOneWithoutStudentsInputFromJson(json);

  final Input$SchoolUncheckedCreateWithoutStudentsInput? create;

  final Input$SchoolCreateOrConnectWithoutStudentsInput? connectOrCreate;

  final Input$SchoolWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateNestedOneWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateNestedOneWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$SchoolCreateNestedOneWithoutStudentsInput copyWith(
          {Input$SchoolUncheckedCreateWithoutStudentsInput? Function()? create,
          Input$SchoolCreateOrConnectWithoutStudentsInput? Function()?
              connectOrCreate,
          Input$SchoolWhereUniqueInput? Function()? connect}) =>
      Input$SchoolCreateNestedOneWithoutStudentsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateOrConnectWithoutClassroomsInput {
  Input$SchoolCreateOrConnectWithoutClassroomsInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolCreateOrConnectWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateOrConnectWithoutClassroomsInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedCreateWithoutClassroomsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateOrConnectWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateOrConnectWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolCreateOrConnectWithoutClassroomsInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedCreateWithoutClassroomsInput? create}) =>
      Input$SchoolCreateOrConnectWithoutClassroomsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateOrConnectWithoutProvinceInput {
  Input$SchoolCreateOrConnectWithoutProvinceInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolCreateOrConnectWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateOrConnectWithoutProvinceInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedCreateWithoutProvinceInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateOrConnectWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateOrConnectWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolCreateOrConnectWithoutProvinceInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedCreateWithoutProvinceInput? create}) =>
      Input$SchoolCreateOrConnectWithoutProvinceInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateOrConnectWithoutRegencyInput {
  Input$SchoolCreateOrConnectWithoutRegencyInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolCreateOrConnectWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateOrConnectWithoutRegencyInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedCreateWithoutRegencyInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateOrConnectWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateOrConnectWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolCreateOrConnectWithoutRegencyInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedCreateWithoutRegencyInput? create}) =>
      Input$SchoolCreateOrConnectWithoutRegencyInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateOrConnectWithoutSchoolStaffsInput {
  Input$SchoolCreateOrConnectWithoutSchoolStaffsInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolCreateOrConnectWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateOrConnectWithoutSchoolStaffsInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedCreateWithoutSchoolStaffsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateOrConnectWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateOrConnectWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolCreateOrConnectWithoutSchoolStaffsInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedCreateWithoutSchoolStaffsInput? create}) =>
      Input$SchoolCreateOrConnectWithoutSchoolStaffsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateOrConnectWithoutStudentsInput {
  Input$SchoolCreateOrConnectWithoutStudentsInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolCreateOrConnectWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateOrConnectWithoutStudentsInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedCreateWithoutStudentsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateOrConnectWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateOrConnectWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolCreateOrConnectWithoutStudentsInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedCreateWithoutStudentsInput? create}) =>
      Input$SchoolCreateOrConnectWithoutStudentsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateWithoutClassroomsInput {
  Input$SchoolCreateWithoutClassroomsInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.province,
      required this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolCreateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateWithoutClassroomsInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final Input$ProvinceCreateNestedOneWithoutSchoolInput province;

  final Input$RegencyCreateNestedOneWithoutSchoolInput regency;

  final Input$SchoolStaffCreateNestedManyWithoutSchoolInput? schoolStaffs;

  final Input$UserCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolCreateWithoutClassroomsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          Input$ProvinceCreateNestedOneWithoutSchoolInput? province,
          Input$RegencyCreateNestedOneWithoutSchoolInput? regency,
          Input$SchoolStaffCreateNestedManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolCreateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateWithoutProvinceInput {
  Input$SchoolCreateWithoutProvinceInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolCreateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateWithoutProvinceInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final Input$RegencyCreateNestedOneWithoutSchoolInput regency;

  final Input$SchoolStaffCreateNestedManyWithoutSchoolInput? schoolStaffs;

  final Input$UserCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolCreateWithoutProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomCreateNestedManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          Input$RegencyCreateNestedOneWithoutSchoolInput? regency,
          Input$SchoolStaffCreateNestedManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolCreateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          regency: regency == null ? this.regency : regency,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateWithoutRegencyInput {
  Input$SchoolCreateWithoutRegencyInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.province,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolCreateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateWithoutRegencyInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final Input$ProvinceCreateNestedOneWithoutSchoolInput province;

  final Input$SchoolStaffCreateNestedManyWithoutSchoolInput? schoolStaffs;

  final Input$UserCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolCreateWithoutRegencyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomCreateNestedManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          Input$ProvinceCreateNestedOneWithoutSchoolInput? province,
          Input$SchoolStaffCreateNestedManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolCreateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateWithoutSchoolStaffsInput {
  Input$SchoolCreateWithoutSchoolStaffsInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.province,
      required this.regency,
      this.students});

  @override
  factory Input$SchoolCreateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateWithoutSchoolStaffsInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final Input$ProvinceCreateNestedOneWithoutSchoolInput province;

  final Input$RegencyCreateNestedOneWithoutSchoolInput regency;

  final Input$UserCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolCreateWithoutSchoolStaffsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomCreateNestedManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          Input$ProvinceCreateNestedOneWithoutSchoolInput? province,
          Input$RegencyCreateNestedOneWithoutSchoolInput? regency,
          Input$UserCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolCreateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolCreateWithoutStudentsInput {
  Input$SchoolCreateWithoutStudentsInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.province,
      required this.regency,
      this.schoolStaffs});

  @override
  factory Input$SchoolCreateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolCreateWithoutStudentsInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final Input$ProvinceCreateNestedOneWithoutSchoolInput province;

  final Input$RegencyCreateNestedOneWithoutSchoolInput regency;

  final Input$SchoolStaffCreateNestedManyWithoutSchoolInput? schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolCreateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolCreateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$SchoolCreateWithoutStudentsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomCreateNestedManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          Input$ProvinceCreateNestedOneWithoutSchoolInput? province,
          Input$RegencyCreateNestedOneWithoutSchoolInput? regency,
          Input$SchoolStaffCreateNestedManyWithoutSchoolInput? Function()?
              schoolStaffs}) =>
      Input$SchoolCreateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolListRelationFilter {
  Input$SchoolListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$SchoolListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolListRelationFilterFromJson(json);

  final Input$SchoolWhereInput? every;

  final Input$SchoolWhereInput? some;

  final Input$SchoolWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$SchoolListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$SchoolListRelationFilter copyWith(
          {Input$SchoolWhereInput? Function()? every,
          Input$SchoolWhereInput? Function()? some,
          Input$SchoolWhereInput? Function()? none}) =>
      Input$SchoolListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolMaxOrderByAggregateInput {
  Input$SchoolMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId});

  @override
  factory Input$SchoolMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? npsn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? logoPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bannerPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? npsn,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? logoPath,
          Enum$SortOrder? Function()? bannerPath,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId}) =>
      Input$SchoolMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolMinOrderByAggregateInput {
  Input$SchoolMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId});

  @override
  factory Input$SchoolMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? npsn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? logoPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bannerPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? npsn,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? logoPath,
          Enum$SortOrder? Function()? bannerPath,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId}) =>
      Input$SchoolMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolOrderByRelationAggregateInput {
  Input$SchoolOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$SchoolOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$SchoolOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$SchoolOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolOrderByWithAggregationInput {
  Input$SchoolOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$SchoolOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? npsn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? levels;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? logoPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bannerPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  @JsonKey(name: '_count')
  final Input$SchoolCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$SchoolAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$SchoolMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$SchoolMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$SchoolSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$SchoolOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? npsn,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? levels,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? logoPath,
          Enum$SortOrder? Function()? bannerPath,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId,
          Input$SchoolCountOrderByAggregateInput? Function()? $_count,
          Input$SchoolAvgOrderByAggregateInput? Function()? $_avg,
          Input$SchoolMaxOrderByAggregateInput? Function()? $_max,
          Input$SchoolMinOrderByAggregateInput? Function()? $_min,
          Input$SchoolSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$SchoolOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolOrderByWithRelationInput {
  Input$SchoolOrderByWithRelationInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.province,
      this.regencyId,
      this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? npsn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ClassroomOrderByRelationAggregateInput? classrooms;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? levels;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? logoPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bannerPath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  final Input$ProvinceOrderByWithRelationInput? province;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  final Input$RegencyOrderByWithRelationInput? regency;

  final Input$SchoolStaffOrderByRelationAggregateInput? schoolStaffs;

  final Input$UserOrderByRelationAggregateInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$province = province;
    final l$regencyId = regencyId;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$province,
      l$regencyId,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? npsn,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ClassroomOrderByRelationAggregateInput? Function()? classrooms,
          Enum$SortOrder? Function()? levels,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? logoPath,
          Enum$SortOrder? Function()? bannerPath,
          Enum$SortOrder? Function()? provinceId,
          Input$ProvinceOrderByWithRelationInput? Function()? province,
          Enum$SortOrder? Function()? regencyId,
          Input$RegencyOrderByWithRelationInput? Function()? regency,
          Input$SchoolStaffOrderByRelationAggregateInput? Function()?
              schoolStaffs,
          Input$UserOrderByRelationAggregateInput? Function()? students}) =>
      Input$SchoolOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          province: province == null ? this.province : province(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          regency: regency == null ? this.regency : regency(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolRelationFilter {
  Input$SchoolRelationFilter({this.$is, this.isNot});

  @override
  factory Input$SchoolRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$SchoolWhereInput? $is;

  final Input$SchoolWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$SchoolRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$SchoolRelationFilter copyWith(
          {Input$SchoolWhereInput? Function()? $is,
          Input$SchoolWhereInput? Function()? isNot}) =>
      Input$SchoolRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolScalarWhereInput {
  Input$SchoolScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId});

  @override
  factory Input$SchoolScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolScalarWhereInputFromJson(json);

  final List<Input$SchoolScalarWhereInput?>? AND;

  final List<Input$SchoolScalarWhereInput?>? OR;

  final List<Input$SchoolScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringNullableFilter? npsn;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$IntNullableListFilter? levels;

  final Input$StringFilter? type;

  final Input$StringNullableFilter? address;

  final Input$StringNullableFilter? logoPath;

  final Input$StringNullableFilter? bannerPath;

  final Input$StringFilter? provinceId;

  final Input$StringFilter? regencyId;

  Map<String, dynamic> toJson() => _$Input$SchoolScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolScalarWhereInput copyWith(
          {List<Input$SchoolScalarWhereInput?>? Function()? AND,
          List<Input$SchoolScalarWhereInput?>? Function()? OR,
          List<Input$SchoolScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringNullableFilter? Function()? npsn,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$IntNullableListFilter? Function()? levels,
          Input$StringFilter? Function()? type,
          Input$StringNullableFilter? Function()? address,
          Input$StringNullableFilter? Function()? logoPath,
          Input$StringNullableFilter? Function()? bannerPath,
          Input$StringFilter? Function()? provinceId,
          Input$StringFilter? Function()? regencyId}) =>
      Input$SchoolScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolScalarWhereWithAggregatesInput {
  Input$SchoolScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId});

  @override
  factory Input$SchoolScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$SchoolScalarWhereWithAggregatesInput?>? AND;

  final List<Input$SchoolScalarWhereWithAggregatesInput?>? OR;

  final List<Input$SchoolScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringNullableWithAggregatesFilter? npsn;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  final Input$IntNullableListFilter? levels;

  final Input$StringWithAggregatesFilter? type;

  final Input$StringNullableWithAggregatesFilter? address;

  final Input$StringNullableWithAggregatesFilter? logoPath;

  final Input$StringNullableWithAggregatesFilter? bannerPath;

  final Input$StringWithAggregatesFilter? provinceId;

  final Input$StringWithAggregatesFilter? regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolScalarWhereWithAggregatesInput copyWith(
          {List<Input$SchoolScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$SchoolScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$SchoolScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringNullableWithAggregatesFilter? Function()? npsn,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt,
          Input$IntNullableListFilter? Function()? levels,
          Input$StringWithAggregatesFilter? Function()? type,
          Input$StringNullableWithAggregatesFilter? Function()? address,
          Input$StringNullableWithAggregatesFilter? Function()? logoPath,
          Input$StringNullableWithAggregatesFilter? Function()? bannerPath,
          Input$StringWithAggregatesFilter? Function()? provinceId,
          Input$StringWithAggregatesFilter? Function()? regencyId}) =>
      Input$SchoolScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCountOrderByAggregateInput {
  Input$SchoolStaffCountOrderByAggregateInput(
      {this.id,
      this.schoolId,
      this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? roles;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$schoolId, l$userId, l$roles, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != lOther$roles) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? roles,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$SchoolStaffCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateInput {
  Input$SchoolStaffCreateInput(
      {this.id,
      required this.school,
      required this.user,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateInputFromJson(json);

  final String? id;

  final Input$SchoolCreateNestedOneWithoutSchoolStaffsInput school;

  final Input$UserCreateNestedOneWithoutSchoolStaffsInput user;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$SchoolStaffCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$school = school;
    final l$user = user;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$school,
      l$user,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCreateInput copyWith(
          {String? Function()? id,
          Input$SchoolCreateNestedOneWithoutSchoolStaffsInput? school,
          Input$UserCreateNestedOneWithoutSchoolStaffsInput? user,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffCreateInput(
          id: id == null ? this.id : id(),
          school: school == null ? this.school : school,
          user: user == null ? this.user : user,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateManyInput {
  Input$SchoolStaffCreateManyInput(
      {this.id,
      required this.schoolId,
      required this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateManyInputFromJson(json);

  final String? id;

  final String schoolId;

  final String userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCreateManyInput copyWith(
          {String? Function()? id,
          String? schoolId,
          String? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffCreateManyInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId,
          userId: userId == null ? this.userId : userId,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateManySchoolInput {
  Input$SchoolStaffCreateManySchoolInput(
      {this.id,
      required this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCreateManySchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateManySchoolInputFromJson(json);

  final String? id;

  final String userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateManySchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateManySchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCreateManySchoolInput copyWith(
          {String? Function()? id,
          String? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffCreateManySchoolInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateManySchoolInputEnvelope {
  Input$SchoolStaffCreateManySchoolInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$SchoolStaffCreateManySchoolInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateManySchoolInputEnvelopeFromJson(json);

  final Input$SchoolStaffCreateManySchoolInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateManySchoolInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateManySchoolInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$SchoolStaffCreateManySchoolInputEnvelope copyWith(
          {Input$SchoolStaffCreateManySchoolInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$SchoolStaffCreateManySchoolInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateManyUserInput {
  Input$SchoolStaffCreateManyUserInput(
      {this.id,
      required this.schoolId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateManyUserInputFromJson(json);

  final String? id;

  final String schoolId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCreateManyUserInput copyWith(
          {String? Function()? id,
          String? schoolId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffCreateManyUserInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateManyUserInputEnvelope {
  Input$SchoolStaffCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$SchoolStaffCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateManyUserInputEnvelopeFromJson(json);

  final Input$SchoolStaffCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$SchoolStaffCreateManyUserInputEnvelope copyWith(
          {Input$SchoolStaffCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$SchoolStaffCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateNestedManyWithoutSchoolInput {
  Input$SchoolStaffCreateNestedManyWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolStaffCreateNestedManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateNestedManyWithoutSchoolInputFromJson(json);

  final List<Input$SchoolStaffCreateWithoutSchoolInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final Input$SchoolStaffCreateManySchoolInputEnvelope? createMany;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateNestedManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateNestedManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffCreateNestedManyWithoutSchoolInput copyWith(
          {List<Input$SchoolStaffCreateWithoutSchoolInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          Input$SchoolStaffCreateManySchoolInputEnvelope? Function()?
              createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolStaffCreateNestedManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateNestedManyWithoutUserInput {
  Input$SchoolStaffCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolStaffCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$SchoolStaffCreateWithoutUserInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$SchoolStaffCreateManyUserInputEnvelope? createMany;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffCreateNestedManyWithoutUserInput copyWith(
          {List<Input$SchoolStaffCreateWithoutUserInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$SchoolStaffCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolStaffCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateOrConnectWithoutSchoolInput {
  Input$SchoolStaffCreateOrConnectWithoutSchoolInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolStaffCreateOrConnectWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateOrConnectWithoutSchoolInputFromJson(json);

  final Input$SchoolStaffWhereUniqueInput where;

  final Input$SchoolStaffUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateOrConnectWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateOrConnectWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolStaffCreateOrConnectWithoutSchoolInput copyWith(
          {Input$SchoolStaffWhereUniqueInput? where,
          Input$SchoolStaffUncheckedCreateWithoutSchoolInput? create}) =>
      Input$SchoolStaffCreateOrConnectWithoutSchoolInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateOrConnectWithoutUserInput {
  Input$SchoolStaffCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$SchoolStaffCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateOrConnectWithoutUserInputFromJson(json);

  final Input$SchoolStaffWhereUniqueInput where;

  final Input$SchoolStaffUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolStaffCreateOrConnectWithoutUserInput copyWith(
          {Input$SchoolStaffWhereUniqueInput? where,
          Input$SchoolStaffUncheckedCreateWithoutUserInput? create}) =>
      Input$SchoolStaffCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreaterolesInput {
  Input$SchoolStaffCreaterolesInput({required this.$set});

  @override
  factory Input$SchoolStaffCreaterolesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreaterolesInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final Enum$SchoolStaffRoles $set;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreaterolesInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreaterolesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$SchoolStaffCreaterolesInput copyWith({Enum$SchoolStaffRoles? $set}) =>
      Input$SchoolStaffCreaterolesInput($set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateWithoutSchoolInput {
  Input$SchoolStaffCreateWithoutSchoolInput(
      {this.id,
      required this.user,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final Input$UserCreateNestedOneWithoutSchoolStaffsInput user;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$user = user;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$user,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          Input$UserCreateNestedOneWithoutSchoolStaffsInput? user,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          user: user == null ? this.user : user,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffCreateWithoutUserInput {
  Input$SchoolStaffCreateWithoutUserInput(
      {this.id,
      required this.school,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffCreateWithoutUserInputFromJson(json);

  final String? id;

  final Input$SchoolCreateNestedOneWithoutSchoolStaffsInput school;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$school = school;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$school,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffCreateWithoutUserInput copyWith(
          {String? Function()? id,
          Input$SchoolCreateNestedOneWithoutSchoolStaffsInput? school,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          school: school == null ? this.school : school,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffListRelationFilter {
  Input$SchoolStaffListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$SchoolStaffListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffListRelationFilterFromJson(json);

  final Input$SchoolStaffWhereInput? every;

  final Input$SchoolStaffWhereInput? some;

  final Input$SchoolStaffWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$SchoolStaffListRelationFilter copyWith(
          {Input$SchoolStaffWhereInput? Function()? every,
          Input$SchoolStaffWhereInput? Function()? some,
          Input$SchoolStaffWhereInput? Function()? none}) =>
      Input$SchoolStaffListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffMaxOrderByAggregateInput {
  Input$SchoolStaffMaxOrderByAggregateInput(
      {this.id, this.schoolId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$schoolId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$SchoolStaffMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffMinOrderByAggregateInput {
  Input$SchoolStaffMinOrderByAggregateInput(
      {this.id, this.schoolId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$schoolId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$SchoolStaffMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffOrderByRelationAggregateInput {
  Input$SchoolStaffOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$SchoolStaffOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$SchoolStaffOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$SchoolStaffOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffOrderByWithAggregationInput {
  Input$SchoolStaffOrderByWithAggregationInput(
      {this.id,
      this.schoolId,
      this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_max,
      this.$_min});

  @override
  factory Input$SchoolStaffOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? roles;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$SchoolStaffCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_max')
  final Input$SchoolStaffMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$SchoolStaffMinOrderByAggregateInput? $_min;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$userId,
      l$roles,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_max,
      l$$_min
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != lOther$roles) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    return true;
  }

  Input$SchoolStaffOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? schoolId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? roles,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$SchoolStaffCountOrderByAggregateInput? Function()? $_count,
          Input$SchoolStaffMaxOrderByAggregateInput? Function()? $_max,
          Input$SchoolStaffMinOrderByAggregateInput? Function()? $_min}) =>
      Input$SchoolStaffOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffOrderByWithRelationInput {
  Input$SchoolStaffOrderByWithRelationInput(
      {this.id,
      this.schoolId,
      this.school,
      this.userId,
      this.user,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  final Input$SchoolOrderByWithRelationInput? school;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? roles;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$school = school;
    final l$userId = userId;
    final l$user = user;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$school,
      l$userId,
      l$user,
      l$roles,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != lOther$roles) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? schoolId,
          Input$SchoolOrderByWithRelationInput? Function()? school,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? roles,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$SchoolStaffOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          school: school == null ? this.school : school(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffScalarWhereInput {
  Input$SchoolStaffScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.schoolId,
      this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffScalarWhereInputFromJson(json);

  final List<Input$SchoolStaffScalarWhereInput?>? AND;

  final List<Input$SchoolStaffScalarWhereInput?>? OR;

  final List<Input$SchoolStaffScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? schoolId;

  final Input$StringFilter? userId;

  final Input$EnumSchoolStaffRolesNullableListFilter? roles;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$schoolId,
      l$userId,
      l$roles,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != lOther$roles) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffScalarWhereInput copyWith(
          {List<Input$SchoolStaffScalarWhereInput?>? Function()? AND,
          List<Input$SchoolStaffScalarWhereInput?>? Function()? OR,
          List<Input$SchoolStaffScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? schoolId,
          Input$StringFilter? Function()? userId,
          Input$EnumSchoolStaffRolesNullableListFilter? Function()? roles,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$SchoolStaffScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffScalarWhereWithAggregatesInput {
  Input$SchoolStaffScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.schoolId,
      this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$SchoolStaffScalarWhereWithAggregatesInput?>? AND;

  final List<Input$SchoolStaffScalarWhereWithAggregatesInput?>? OR;

  final List<Input$SchoolStaffScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? schoolId;

  final Input$StringWithAggregatesFilter? userId;

  final Input$EnumSchoolStaffRolesNullableListFilter? roles;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$schoolId,
      l$userId,
      l$roles,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != lOther$roles) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffScalarWhereWithAggregatesInput copyWith(
          {List<Input$SchoolStaffScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$SchoolStaffScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$SchoolStaffScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? schoolId,
          Input$StringWithAggregatesFilter? Function()? userId,
          Input$EnumSchoolStaffRolesNullableListFilter? Function()? roles,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$SchoolStaffScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedCreateInput {
  Input$SchoolStaffUncheckedCreateInput(
      {this.id,
      required this.schoolId,
      required this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedCreateInputFromJson(json);

  final String? id;

  final String schoolId;

  final String userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? schoolId,
          String? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedCreateInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId,
          userId: userId == null ? this.userId : userId,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput {
  Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInputFromJson(
          json);

  final List<Input$SchoolStaffCreateWithoutSchoolInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final Input$SchoolStaffCreateManySchoolInputEnvelope? createMany;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput copyWith(
          {List<Input$SchoolStaffCreateWithoutSchoolInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          Input$SchoolStaffCreateManySchoolInputEnvelope? Function()?
              createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput {
  Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$SchoolStaffCreateWithoutUserInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$SchoolStaffCreateManyUserInputEnvelope? createMany;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$SchoolStaffCreateWithoutUserInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$SchoolStaffCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedCreateWithoutSchoolInput {
  Input$SchoolStaffUncheckedCreateWithoutSchoolInput(
      {this.id,
      required this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedCreateWithoutUserInput {
  Input$SchoolStaffUncheckedCreateWithoutUserInput(
      {this.id,
      required this.schoolId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedCreateWithoutUserInputFromJson(json);

  final String? id;

  final String schoolId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedCreateWithoutUserInput copyWith(
          {String? Function()? id,
          String? schoolId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId,
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateInput {
  Input$SchoolStaffUncheckedUpdateInput(
      {this.id,
      this.schoolId,
      this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? schoolId;

  final Input$StringFieldUpdateOperationsInput? userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? schoolId,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateManyInput {
  Input$SchoolStaffUncheckedUpdateManyInput(
      {this.id,
      this.schoolId,
      this.userId,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? schoolId;

  final Input$StringFieldUpdateOperationsInput? userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? schoolId,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput {
  Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInputFromJson(json);

  final List<Input$SchoolStaffCreateWithoutSchoolInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final List<Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput?>? upsert;

  final Input$SchoolStaffCreateManySchoolInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolStaffWhereUniqueInput?>? $set;

  final List<Input$SchoolStaffWhereUniqueInput?>? disconnect;

  final List<Input$SchoolStaffWhereUniqueInput?>? delete;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  final List<Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput?>? update;

  final List<Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput?>?
      updateMany;

  final List<Input$SchoolStaffScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput copyWith(
          {List<Input$SchoolStaffCreateWithoutSchoolInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              upsert,
          Input$SchoolStaffCreateManySchoolInputEnvelope? Function()?
              createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              update,
          List<Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput?>?
                  Function()?
              updateMany,
          List<Input$SchoolStaffScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput {
  Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput(
      {this.id, this.schoolId, this.roles, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInputFromJson(
          json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? schoolId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? schoolId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateManyWithoutUserInput {
  Input$SchoolStaffUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolStaffUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$SchoolStaffCreateWithoutUserInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$SchoolStaffCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolStaffWhereUniqueInput?>? $set;

  final List<Input$SchoolStaffWhereUniqueInput?>? disconnect;

  final List<Input$SchoolStaffWhereUniqueInput?>? delete;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  final List<Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$SchoolStaffUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$SchoolStaffScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$SchoolStaffCreateWithoutUserInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$SchoolStaffCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$SchoolStaffUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$SchoolStaffScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolStaffUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateWithoutSchoolInput {
  Input$SchoolStaffUncheckedUpdateWithoutSchoolInput(
      {this.id, this.userId, this.roles, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? userId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? userId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUncheckedUpdateWithoutUserInput {
  Input$SchoolStaffUncheckedUpdateWithoutUserInput(
      {this.id, this.schoolId, this.roles, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? schoolId;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$schoolId = schoolId;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$schoolId,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUncheckedUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? schoolId,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateInput {
  Input$SchoolStaffUpdateInput(
      {this.id,
      this.school,
      this.user,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput? school;

  final Input$UserUpdateOneRequiredWithoutSchoolStaffsInput? user;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$SchoolStaffUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$school = school;
    final l$user = user;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$school,
      l$user,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput? Function()?
              school,
          Input$UserUpdateOneRequiredWithoutSchoolStaffsInput? Function()? user,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUpdateInput(
          id: id == null ? this.id : id(),
          school: school == null ? this.school : school(),
          user: user == null ? this.user : user(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateManyMutationInput {
  Input$SchoolStaffUpdateManyMutationInput(
      {this.id, this.roles, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateManyWithoutSchoolInput {
  Input$SchoolStaffUpdateManyWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolStaffUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateManyWithoutSchoolInputFromJson(json);

  final List<Input$SchoolStaffCreateWithoutSchoolInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>?
      connectOrCreate;

  final List<Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput?>? upsert;

  final Input$SchoolStaffCreateManySchoolInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolStaffWhereUniqueInput?>? $set;

  final List<Input$SchoolStaffWhereUniqueInput?>? disconnect;

  final List<Input$SchoolStaffWhereUniqueInput?>? delete;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  final List<Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput?>? update;

  final List<Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput?>?
      updateMany;

  final List<Input$SchoolStaffScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUpdateManyWithoutSchoolInput copyWith(
          {List<Input$SchoolStaffCreateWithoutSchoolInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              upsert,
          Input$SchoolStaffCreateManySchoolInputEnvelope? Function()?
              createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput?>?
                  Function()?
              update,
          List<Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput?>?
                  Function()?
              updateMany,
          List<Input$SchoolStaffScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolStaffUpdateManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateManyWithoutUserInput {
  Input$SchoolStaffUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolStaffUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateManyWithoutUserInputFromJson(json);

  final List<Input$SchoolStaffCreateWithoutUserInput?>? create;

  final List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$SchoolStaffCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolStaffWhereUniqueInput?>? $set;

  final List<Input$SchoolStaffWhereUniqueInput?>? disconnect;

  final List<Input$SchoolStaffWhereUniqueInput?>? delete;

  final List<Input$SchoolStaffWhereUniqueInput?>? connect;

  final List<Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$SchoolStaffUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$SchoolStaffScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUpdateManyWithoutUserInput copyWith(
          {List<Input$SchoolStaffCreateWithoutUserInput?>? Function()? create,
          List<Input$SchoolStaffCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$SchoolStaffCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolStaffWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$SchoolStaffUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$SchoolStaffScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolStaffUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput {
  Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInputFromJson(json);

  final Input$SchoolStaffScalarWhereInput where;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput copyWith(
          {Input$SchoolStaffScalarWhereInput? where,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput?
              data}) =>
      Input$SchoolStaffUpdateManyWithWhereWithoutSchoolInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateManyWithWhereWithoutUserInput {
  Input$SchoolStaffUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolStaffUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$SchoolStaffScalarWhereInput where;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolStaffUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$SchoolStaffScalarWhereInput? where,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolStaffsInput?
              data}) =>
      Input$SchoolStaffUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdaterolesInput {
  Input$SchoolStaffUpdaterolesInput({this.$set, this.push});

  @override
  factory Input$SchoolStaffUpdaterolesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdaterolesInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? $set;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? push;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdaterolesInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdaterolesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$SchoolStaffUpdaterolesInput copyWith(
          {List<Enum$SchoolStaffRoles?>? Function()? $set,
          List<Enum$SchoolStaffRoles?>? Function()? push}) =>
      Input$SchoolStaffUpdaterolesInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateWithoutSchoolInput {
  Input$SchoolStaffUpdateWithoutSchoolInput(
      {this.id, this.user, this.roles, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$UserUpdateOneRequiredWithoutSchoolStaffsInput? user;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$user = user;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$user,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$UserUpdateOneRequiredWithoutSchoolStaffsInput? Function()? user,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          user: user == null ? this.user : user(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateWithoutUserInput {
  Input$SchoolStaffUpdateWithoutUserInput(
      {this.id, this.school, this.roles, this.createdAt, this.updatedAt});

  @override
  factory Input$SchoolStaffUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput? school;

  @JsonKey(unknownEnumValue: Enum$SchoolStaffRoles.$unknown)
  final List<Enum$SchoolStaffRoles?>? roles;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$school = school;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$school,
      l$roles == null ? null : Object.hashAll(l$roles.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != null && lOther$roles != null) {
      if (l$roles.length != lOther$roles.length) return false;
      for (int i = 0; i < l$roles.length; i++) {
        final l$roles$entry = l$roles[i];
        final lOther$roles$entry = lOther$roles[i];
        if (l$roles$entry != lOther$roles$entry) return false;
      }
    } else if (l$roles != lOther$roles) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput? Function()?
              school,
          List<Enum$SchoolStaffRoles?>? Function()? roles,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$SchoolStaffUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          school: school == null ? this.school : school(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput {
  Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInputFromJson(json);

  final Input$SchoolStaffWhereUniqueInput where;

  final Input$SchoolStaffUncheckedUpdateWithoutSchoolInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput copyWith(
          {Input$SchoolStaffWhereUniqueInput? where,
          Input$SchoolStaffUncheckedUpdateWithoutSchoolInput? data}) =>
      Input$SchoolStaffUpdateWithWhereUniqueWithoutSchoolInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput {
  Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$SchoolStaffWhereUniqueInput where;

  final Input$SchoolStaffUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$SchoolStaffWhereUniqueInput? where,
          Input$SchoolStaffUncheckedUpdateWithoutUserInput? data}) =>
      Input$SchoolStaffUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput {
  Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInputFromJson(json);

  final Input$SchoolStaffWhereUniqueInput where;

  final Input$SchoolStaffUncheckedUpdateWithoutSchoolInput update;

  final Input$SchoolStaffUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput copyWith(
          {Input$SchoolStaffWhereUniqueInput? where,
          Input$SchoolStaffUncheckedUpdateWithoutSchoolInput? update,
          Input$SchoolStaffUncheckedCreateWithoutSchoolInput? create}) =>
      Input$SchoolStaffUpsertWithWhereUniqueWithoutSchoolInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput {
  Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$SchoolStaffWhereUniqueInput where;

  final Input$SchoolStaffUncheckedUpdateWithoutUserInput update;

  final Input$SchoolStaffUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$SchoolStaffWhereUniqueInput? where,
          Input$SchoolStaffUncheckedUpdateWithoutUserInput? update,
          Input$SchoolStaffUncheckedCreateWithoutUserInput? create}) =>
      Input$SchoolStaffUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffWhereInput {
  Input$SchoolStaffWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.schoolId,
      this.school,
      this.userId,
      this.user,
      this.roles,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$SchoolStaffWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolStaffWhereInputFromJson(json);

  final List<Input$SchoolStaffWhereInput?>? AND;

  final List<Input$SchoolStaffWhereInput?>? OR;

  final List<Input$SchoolStaffWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? schoolId;

  final Input$SchoolWhereInput? school;

  final Input$StringFilter? userId;

  final Input$UserWhereInput? user;

  final Input$EnumSchoolStaffRolesNullableListFilter? roles;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$SchoolStaffWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$schoolId = schoolId;
    final l$school = school;
    final l$userId = userId;
    final l$user = user;
    final l$roles = roles;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$schoolId,
      l$school,
      l$userId,
      l$user,
      l$roles,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (l$roles != lOther$roles) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$SchoolStaffWhereInput copyWith(
          {List<Input$SchoolStaffWhereInput?>? Function()? AND,
          List<Input$SchoolStaffWhereInput?>? Function()? OR,
          List<Input$SchoolStaffWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? schoolId,
          Input$SchoolWhereInput? Function()? school,
          Input$StringFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$EnumSchoolStaffRolesNullableListFilter? Function()? roles,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$SchoolStaffWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          school: school == null ? this.school : school(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          roles: roles == null ? this.roles : roles(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolStaffWhereUniqueInput {
  Input$SchoolStaffWhereUniqueInput({this.id});

  @override
  factory Input$SchoolStaffWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolStaffWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolStaffWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolStaffWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$SchoolStaffWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$SchoolStaffWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolSumOrderByAggregateInput {
  Input$SchoolSumOrderByAggregateInput({this.levels});

  @override
  factory Input$SchoolSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? levels;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$levels = levels;
    return Object.hashAll([l$levels]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    return true;
  }

  Input$SchoolSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? levels}) =>
      Input$SchoolSumOrderByAggregateInput(
          levels: levels == null ? this.levels : levels());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateInput {
  Input$SchoolUncheckedCreateInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId,
      required this.regencyId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  final String regencyId;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
      schoolStaffs;

  final Input$UserUncheckedCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId,
          String? regencyId,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              schoolStaffs,
          Input$UserUncheckedCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput {
  Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateNestedManyWithoutProvinceInputFromJson(json);

  final List<Input$SchoolCreateWithoutProvinceInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final Input$SchoolCreateManyProvinceInputEnvelope? createMany;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateNestedManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput copyWith(
          {List<Input$SchoolCreateWithoutProvinceInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          Input$SchoolCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolUncheckedCreateNestedManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput {
  Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateNestedManyWithoutRegencyInputFromJson(json);

  final List<Input$SchoolCreateWithoutRegencyInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final Input$SchoolCreateManyRegencyInputEnvelope? createMany;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateNestedManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput copyWith(
          {List<Input$SchoolCreateWithoutRegencyInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          Input$SchoolCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect}) =>
      Input$SchoolUncheckedCreateNestedManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateWithoutClassroomsInput {
  Input$SchoolUncheckedCreateWithoutClassroomsInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId,
      required this.regencyId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedCreateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateWithoutClassroomsInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  final String regencyId;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
      schoolStaffs;

  final Input$UserUncheckedCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedCreateWithoutClassroomsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId,
          String? regencyId,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              schoolStaffs,
          Input$UserUncheckedCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedCreateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateWithoutProvinceInput {
  Input$SchoolUncheckedCreateWithoutProvinceInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.regencyId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedCreateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateWithoutProvinceInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String regencyId;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
      schoolStaffs;

  final Input$UserUncheckedCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$regencyId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedCreateWithoutProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? regencyId,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              schoolStaffs,
          Input$UserUncheckedCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedCreateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          regencyId: regencyId == null ? this.regencyId : regencyId,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateWithoutRegencyInput {
  Input$SchoolUncheckedCreateWithoutRegencyInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedCreateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateWithoutRegencyInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
      schoolStaffs;

  final Input$UserUncheckedCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedCreateWithoutRegencyInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              schoolStaffs,
          Input$UserUncheckedCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedCreateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateWithoutSchoolStaffsInput {
  Input$SchoolUncheckedCreateWithoutSchoolStaffsInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId,
      required this.regencyId,
      this.students});

  @override
  factory Input$SchoolUncheckedCreateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateWithoutSchoolStaffsInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  final String regencyId;

  final Input$UserUncheckedCreateNestedManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedCreateWithoutSchoolStaffsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId,
          String? regencyId,
          Input$UserUncheckedCreateNestedManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedCreateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedCreateWithoutStudentsInput {
  Input$SchoolUncheckedCreateWithoutStudentsInput(
      {this.id,
      required this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      required this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      required this.provinceId,
      required this.regencyId,
      this.schoolStaffs});

  @override
  factory Input$SchoolUncheckedCreateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedCreateWithoutStudentsInputFromJson(json);

  final String? id;

  final String name;

  final String? npsn;

  final String? createdAt;

  final String? updatedAt;

  final Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final String type;

  final String? address;

  final String? logoPath;

  final String? bannerPath;

  final String provinceId;

  final String regencyId;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
      schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedCreateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedCreateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$SchoolUncheckedCreateWithoutStudentsInput copyWith(
          {String? Function()? id,
          String? name,
          String? Function()? npsn,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ClassroomUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              classrooms,
          List<int?>? Function()? levels,
          String? type,
          String? Function()? address,
          String? Function()? logoPath,
          String? Function()? bannerPath,
          String? provinceId,
          String? regencyId,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutSchoolInput?
                  Function()?
              schoolStaffs}) =>
      Input$SchoolUncheckedCreateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type,
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateInput {
  Input$SchoolUncheckedUpdateInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUncheckedUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUncheckedUpdateManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateManyInput {
  Input$SchoolUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId});

  @override
  factory Input$SchoolUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId}) =>
      Input$SchoolUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateManyWithoutProvinceInput {
  Input$SchoolUncheckedUpdateManyWithoutProvinceInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolUncheckedUpdateManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateManyWithoutProvinceInputFromJson(json);

  final List<Input$SchoolCreateWithoutProvinceInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final List<Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput?>? upsert;

  final Input$SchoolCreateManyProvinceInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolWhereUniqueInput?>? $set;

  final List<Input$SchoolWhereUniqueInput?>? disconnect;

  final List<Input$SchoolWhereUniqueInput?>? delete;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  final List<Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput?>? update;

  final List<Input$SchoolUpdateManyWithWhereWithoutProvinceInput?>? updateMany;

  final List<Input$SchoolScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolUncheckedUpdateManyWithoutProvinceInput copyWith(
          {List<Input$SchoolCreateWithoutProvinceInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              upsert,
          Input$SchoolCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              update,
          List<Input$SchoolUpdateManyWithWhereWithoutProvinceInput?>?
                  Function()?
              updateMany,
          List<Input$SchoolScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolUncheckedUpdateManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateManyWithoutRegencyInput {
  Input$SchoolUncheckedUpdateManyWithoutRegencyInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolUncheckedUpdateManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateManyWithoutRegencyInputFromJson(json);

  final List<Input$SchoolCreateWithoutRegencyInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final List<Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput?>? upsert;

  final Input$SchoolCreateManyRegencyInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolWhereUniqueInput?>? $set;

  final List<Input$SchoolWhereUniqueInput?>? disconnect;

  final List<Input$SchoolWhereUniqueInput?>? delete;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  final List<Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput?>? update;

  final List<Input$SchoolUpdateManyWithWhereWithoutRegencyInput?>? updateMany;

  final List<Input$SchoolScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolUncheckedUpdateManyWithoutRegencyInput copyWith(
          {List<Input$SchoolCreateWithoutRegencyInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput?>?
                  Function()?
              upsert,
          Input$SchoolCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput?>?
                  Function()?
              update,
          List<Input$SchoolUpdateManyWithWhereWithoutRegencyInput?>? Function()?
              updateMany,
          List<Input$SchoolScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolUncheckedUpdateManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateManyWithoutSchoolInput {
  Input$SchoolUncheckedUpdateManyWithoutSchoolInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.regencyId});

  @override
  factory Input$SchoolUncheckedUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateManyWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$regencyId = regencyId;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$regencyId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateManyWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId}) =>
      Input$SchoolUncheckedUpdateManyWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          regencyId: regencyId == null ? this.regencyId : regencyId());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateWithoutClassroomsInput {
  Input$SchoolUncheckedUpdateWithoutClassroomsInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedUpdateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateWithoutClassroomsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUncheckedUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateWithoutClassroomsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUncheckedUpdateManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedUpdateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateWithoutProvinceInput {
  Input$SchoolUncheckedUpdateWithoutProvinceInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.regencyId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedUpdateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateWithoutProvinceInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUncheckedUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$regencyId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateWithoutProvinceInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUncheckedUpdateManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedUpdateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateWithoutRegencyInput {
  Input$SchoolUncheckedUpdateWithoutRegencyInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUncheckedUpdateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateWithoutRegencyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUncheckedUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateWithoutRegencyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUncheckedUpdateManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedUpdateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput {
  Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId,
      this.students});

  @override
  factory Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateWithoutSchoolStaffsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$UserUncheckedUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$UserUncheckedUpdateManyWithoutSchoolInput? Function()?
              students}) =>
      Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUncheckedUpdateWithoutStudentsInput {
  Input$SchoolUncheckedUpdateWithoutStudentsInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.regencyId,
      this.schoolStaffs});

  @override
  factory Input$SchoolUncheckedUpdateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUncheckedUpdateWithoutStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUncheckedUpdateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$regencyId,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUncheckedUpdateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$SchoolUncheckedUpdateWithoutStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUncheckedUpdateManyWithoutSchoolInput? Function()?
              classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$SchoolStaffUncheckedUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs}) =>
      Input$SchoolUncheckedUpdateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateInput {
  Input$SchoolUpdateInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.province,
      this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$ProvinceUpdateOneRequiredWithoutSchoolInput? province;

  final Input$RegencyUpdateOneRequiredWithoutSchoolInput? regency;

  final Input$SchoolStaffUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() => _$Input$SchoolUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUpdateManyWithoutSchoolInput? Function()? classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$ProvinceUpdateOneRequiredWithoutSchoolInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutSchoolInput? Function()? regency,
          Input$SchoolStaffUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUpdateManyWithoutSchoolInput? Function()? students}) =>
      Input$SchoolUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdatelevelsInput {
  Input$SchoolUpdatelevelsInput({this.$set, this.push});

  @override
  factory Input$SchoolUpdatelevelsInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolUpdatelevelsInputFromJson(json);

  @JsonKey(name: 'set')
  final List<int?>? $set;

  final List<int?>? push;

  Map<String, dynamic> toJson() => _$Input$SchoolUpdatelevelsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdatelevelsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$SchoolUpdatelevelsInput copyWith(
          {List<int?>? Function()? $set, List<int?>? Function()? push}) =>
      Input$SchoolUpdatelevelsInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateManyMutationInput {
  Input$SchoolUpdateManyMutationInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath});

  @override
  factory Input$SchoolUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    return true;
  }

  Input$SchoolUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath}) =>
      Input$SchoolUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateManyWithoutProvinceInput {
  Input$SchoolUpdateManyWithoutProvinceInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolUpdateManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateManyWithoutProvinceInputFromJson(json);

  final List<Input$SchoolCreateWithoutProvinceInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final List<Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput?>? upsert;

  final Input$SchoolCreateManyProvinceInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolWhereUniqueInput?>? $set;

  final List<Input$SchoolWhereUniqueInput?>? disconnect;

  final List<Input$SchoolWhereUniqueInput?>? delete;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  final List<Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput?>? update;

  final List<Input$SchoolUpdateManyWithWhereWithoutProvinceInput?>? updateMany;

  final List<Input$SchoolScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolUpdateManyWithoutProvinceInput copyWith(
          {List<Input$SchoolCreateWithoutProvinceInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              upsert,
          Input$SchoolCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              update,
          List<Input$SchoolUpdateManyWithWhereWithoutProvinceInput?>?
                  Function()?
              updateMany,
          List<Input$SchoolScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolUpdateManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateManyWithoutRegencyInput {
  Input$SchoolUpdateManyWithoutRegencyInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$SchoolUpdateManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateManyWithoutRegencyInputFromJson(json);

  final List<Input$SchoolCreateWithoutRegencyInput?>? create;

  final List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final List<Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput?>? upsert;

  final Input$SchoolCreateManyRegencyInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$SchoolWhereUniqueInput?>? $set;

  final List<Input$SchoolWhereUniqueInput?>? disconnect;

  final List<Input$SchoolWhereUniqueInput?>? delete;

  final List<Input$SchoolWhereUniqueInput?>? connect;

  final List<Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput?>? update;

  final List<Input$SchoolUpdateManyWithWhereWithoutRegencyInput?>? updateMany;

  final List<Input$SchoolScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$SchoolUpdateManyWithoutRegencyInput copyWith(
          {List<Input$SchoolCreateWithoutRegencyInput?>? Function()? create,
          List<Input$SchoolCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          List<Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput?>?
                  Function()?
              upsert,
          Input$SchoolCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$SchoolWhereUniqueInput?>? Function()? $set,
          List<Input$SchoolWhereUniqueInput?>? Function()? disconnect,
          List<Input$SchoolWhereUniqueInput?>? Function()? delete,
          List<Input$SchoolWhereUniqueInput?>? Function()? connect,
          List<Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput?>?
                  Function()?
              update,
          List<Input$SchoolUpdateManyWithWhereWithoutRegencyInput?>? Function()?
              updateMany,
          List<Input$SchoolScalarWhereInput?>? Function()? deleteMany}) =>
      Input$SchoolUpdateManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateManyWithWhereWithoutProvinceInput {
  Input$SchoolUpdateManyWithWhereWithoutProvinceInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolUpdateManyWithWhereWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateManyWithWhereWithoutProvinceInputFromJson(json);

  final Input$SchoolScalarWhereInput where;

  final Input$SchoolUncheckedUpdateManyWithoutSchoolInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateManyWithWhereWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateManyWithWhereWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolUpdateManyWithWhereWithoutProvinceInput copyWith(
          {Input$SchoolScalarWhereInput? where,
          Input$SchoolUncheckedUpdateManyWithoutSchoolInput? data}) =>
      Input$SchoolUpdateManyWithWhereWithoutProvinceInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateManyWithWhereWithoutRegencyInput {
  Input$SchoolUpdateManyWithWhereWithoutRegencyInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolUpdateManyWithWhereWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateManyWithWhereWithoutRegencyInputFromJson(json);

  final Input$SchoolScalarWhereInput where;

  final Input$SchoolUncheckedUpdateManyWithoutSchoolInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateManyWithWhereWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateManyWithWhereWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolUpdateManyWithWhereWithoutRegencyInput copyWith(
          {Input$SchoolScalarWhereInput? where,
          Input$SchoolUncheckedUpdateManyWithoutSchoolInput? data}) =>
      Input$SchoolUpdateManyWithWhereWithoutRegencyInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput {
  Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInputFromJson(json);

  final Input$SchoolUncheckedCreateWithoutSchoolStaffsInput? create;

  final Input$SchoolCreateOrConnectWithoutSchoolStaffsInput? connectOrCreate;

  final Input$SchoolUpsertWithoutSchoolStaffsInput? upsert;

  final Input$SchoolWhereUniqueInput? connect;

  final Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput copyWith(
          {Input$SchoolUncheckedCreateWithoutSchoolStaffsInput? Function()?
              create,
          Input$SchoolCreateOrConnectWithoutSchoolStaffsInput? Function()?
              connectOrCreate,
          Input$SchoolUpsertWithoutSchoolStaffsInput? Function()? upsert,
          Input$SchoolWhereUniqueInput? Function()? connect,
          Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput? Function()?
              update}) =>
      Input$SchoolUpdateOneRequiredWithoutSchoolStaffsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateOneWithoutClassroomsInput {
  Input$SchoolUpdateOneWithoutClassroomsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.disconnect,
      this.delete,
      this.connect,
      this.update});

  @override
  factory Input$SchoolUpdateOneWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateOneWithoutClassroomsInputFromJson(json);

  final Input$SchoolUncheckedCreateWithoutClassroomsInput? create;

  final Input$SchoolCreateOrConnectWithoutClassroomsInput? connectOrCreate;

  final Input$SchoolUpsertWithoutClassroomsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final Input$SchoolWhereUniqueInput? connect;

  final Input$SchoolUncheckedUpdateWithoutClassroomsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateOneWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      l$create,
      l$connectOrCreate,
      l$upsert,
      l$disconnect,
      l$delete,
      l$connect,
      l$update
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateOneWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != lOther$disconnect) return false;
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != lOther$delete) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$SchoolUpdateOneWithoutClassroomsInput copyWith(
          {Input$SchoolUncheckedCreateWithoutClassroomsInput? Function()?
              create,
          Input$SchoolCreateOrConnectWithoutClassroomsInput? Function()?
              connectOrCreate,
          Input$SchoolUpsertWithoutClassroomsInput? Function()? upsert,
          bool? Function()? disconnect,
          bool? Function()? delete,
          Input$SchoolWhereUniqueInput? Function()? connect,
          Input$SchoolUncheckedUpdateWithoutClassroomsInput? Function()?
              update}) =>
      Input$SchoolUpdateOneWithoutClassroomsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateOneWithoutStudentsInput {
  Input$SchoolUpdateOneWithoutStudentsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.disconnect,
      this.delete,
      this.connect,
      this.update});

  @override
  factory Input$SchoolUpdateOneWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateOneWithoutStudentsInputFromJson(json);

  final Input$SchoolUncheckedCreateWithoutStudentsInput? create;

  final Input$SchoolCreateOrConnectWithoutStudentsInput? connectOrCreate;

  final Input$SchoolUpsertWithoutStudentsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final Input$SchoolWhereUniqueInput? connect;

  final Input$SchoolUncheckedUpdateWithoutStudentsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateOneWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      l$create,
      l$connectOrCreate,
      l$upsert,
      l$disconnect,
      l$delete,
      l$connect,
      l$update
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateOneWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != lOther$disconnect) return false;
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != lOther$delete) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$SchoolUpdateOneWithoutStudentsInput copyWith(
          {Input$SchoolUncheckedCreateWithoutStudentsInput? Function()? create,
          Input$SchoolCreateOrConnectWithoutStudentsInput? Function()?
              connectOrCreate,
          Input$SchoolUpsertWithoutStudentsInput? Function()? upsert,
          bool? Function()? disconnect,
          bool? Function()? delete,
          Input$SchoolWhereUniqueInput? Function()? connect,
          Input$SchoolUncheckedUpdateWithoutStudentsInput? Function()?
              update}) =>
      Input$SchoolUpdateOneWithoutStudentsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithoutClassroomsInput {
  Input$SchoolUpdateWithoutClassroomsInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.province,
      this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUpdateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithoutClassroomsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$ProvinceUpdateOneRequiredWithoutSchoolInput? province;

  final Input$RegencyUpdateOneRequiredWithoutSchoolInput? regency;

  final Input$SchoolStaffUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUpdateWithoutClassroomsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$ProvinceUpdateOneRequiredWithoutSchoolInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutSchoolInput? Function()? regency,
          Input$SchoolStaffUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUpdateManyWithoutSchoolInput? Function()? students}) =>
      Input$SchoolUpdateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithoutProvinceInput {
  Input$SchoolUpdateWithoutProvinceInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUpdateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithoutProvinceInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$RegencyUpdateOneRequiredWithoutSchoolInput? regency;

  final Input$SchoolStaffUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUpdateWithoutProvinceInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUpdateManyWithoutSchoolInput? Function()? classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$RegencyUpdateOneRequiredWithoutSchoolInput? Function()? regency,
          Input$SchoolStaffUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUpdateManyWithoutSchoolInput? Function()? students}) =>
      Input$SchoolUpdateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          regency: regency == null ? this.regency : regency(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithoutRegencyInput {
  Input$SchoolUpdateWithoutRegencyInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.province,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolUpdateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithoutRegencyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$ProvinceUpdateOneRequiredWithoutSchoolInput? province;

  final Input$SchoolStaffUpdateManyWithoutSchoolInput? schoolStaffs;

  final Input$UserUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUpdateWithoutRegencyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUpdateManyWithoutSchoolInput? Function()? classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$ProvinceUpdateOneRequiredWithoutSchoolInput? Function()?
              province,
          Input$SchoolStaffUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs,
          Input$UserUpdateManyWithoutSchoolInput? Function()? students}) =>
      Input$SchoolUpdateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithoutSchoolStaffsInput {
  Input$SchoolUpdateWithoutSchoolStaffsInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.province,
      this.regency,
      this.students});

  @override
  factory Input$SchoolUpdateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithoutSchoolStaffsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$ProvinceUpdateOneRequiredWithoutSchoolInput? province;

  final Input$RegencyUpdateOneRequiredWithoutSchoolInput? regency;

  final Input$UserUpdateManyWithoutSchoolInput? students;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$students = students;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolUpdateWithoutSchoolStaffsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUpdateManyWithoutSchoolInput? Function()? classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$ProvinceUpdateOneRequiredWithoutSchoolInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutSchoolInput? Function()? regency,
          Input$UserUpdateManyWithoutSchoolInput? Function()? students}) =>
      Input$SchoolUpdateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithoutStudentsInput {
  Input$SchoolUpdateWithoutStudentsInput(
      {this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.province,
      this.regency,
      this.schoolStaffs});

  @override
  factory Input$SchoolUpdateWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithoutStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? npsn;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ClassroomUpdateManyWithoutSchoolInput? classrooms;

  final List<int?>? levels;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? logoPath;

  final Input$NullableStringFieldUpdateOperationsInput? bannerPath;

  final Input$ProvinceUpdateOneRequiredWithoutSchoolInput? province;

  final Input$RegencyUpdateOneRequiredWithoutSchoolInput? regency;

  final Input$SchoolStaffUpdateManyWithoutSchoolInput? schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$province = province;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels == null ? null : Object.hashAll(l$levels.map((v) => v)),
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$province,
      l$regency,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != null && lOther$levels != null) {
      if (l$levels.length != lOther$levels.length) return false;
      for (int i = 0; i < l$levels.length; i++) {
        final l$levels$entry = l$levels[i];
        final lOther$levels$entry = lOther$levels[i];
        if (l$levels$entry != lOther$levels$entry) return false;
      }
    } else if (l$levels != lOther$levels) {
      return false;
    }

    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$SchoolUpdateWithoutStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? npsn,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ClassroomUpdateManyWithoutSchoolInput? Function()? classrooms,
          List<int?>? Function()? levels,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()? logoPath,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              bannerPath,
          Input$ProvinceUpdateOneRequiredWithoutSchoolInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutSchoolInput? Function()? regency,
          Input$SchoolStaffUpdateManyWithoutSchoolInput? Function()?
              schoolStaffs}) =>
      Input$SchoolUpdateWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput {
  Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithWhereUniqueWithoutProvinceInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedUpdateWithoutProvinceInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithWhereUniqueWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedUpdateWithoutProvinceInput? data}) =>
      Input$SchoolUpdateWithWhereUniqueWithoutProvinceInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput {
  Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput(
      {required this.where, required this.data});

  @override
  factory Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpdateWithWhereUniqueWithoutRegencyInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedUpdateWithoutRegencyInput data;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpdateWithWhereUniqueWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedUpdateWithoutRegencyInput? data}) =>
      Input$SchoolUpdateWithWhereUniqueWithoutRegencyInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpsertWithoutClassroomsInput {
  Input$SchoolUpsertWithoutClassroomsInput(
      {required this.update, required this.create});

  @override
  factory Input$SchoolUpsertWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpsertWithoutClassroomsInputFromJson(json);

  final Input$SchoolUncheckedUpdateWithoutClassroomsInput update;

  final Input$SchoolUncheckedCreateWithoutClassroomsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpsertWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpsertWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolUpsertWithoutClassroomsInput copyWith(
          {Input$SchoolUncheckedUpdateWithoutClassroomsInput? update,
          Input$SchoolUncheckedCreateWithoutClassroomsInput? create}) =>
      Input$SchoolUpsertWithoutClassroomsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpsertWithoutSchoolStaffsInput {
  Input$SchoolUpsertWithoutSchoolStaffsInput(
      {required this.update, required this.create});

  @override
  factory Input$SchoolUpsertWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpsertWithoutSchoolStaffsInputFromJson(json);

  final Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput update;

  final Input$SchoolUncheckedCreateWithoutSchoolStaffsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpsertWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpsertWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolUpsertWithoutSchoolStaffsInput copyWith(
          {Input$SchoolUncheckedUpdateWithoutSchoolStaffsInput? update,
          Input$SchoolUncheckedCreateWithoutSchoolStaffsInput? create}) =>
      Input$SchoolUpsertWithoutSchoolStaffsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpsertWithoutStudentsInput {
  Input$SchoolUpsertWithoutStudentsInput(
      {required this.update, required this.create});

  @override
  factory Input$SchoolUpsertWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpsertWithoutStudentsInputFromJson(json);

  final Input$SchoolUncheckedUpdateWithoutStudentsInput update;

  final Input$SchoolUncheckedCreateWithoutStudentsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpsertWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpsertWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolUpsertWithoutStudentsInput copyWith(
          {Input$SchoolUncheckedUpdateWithoutStudentsInput? update,
          Input$SchoolUncheckedCreateWithoutStudentsInput? create}) =>
      Input$SchoolUpsertWithoutStudentsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput {
  Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpsertWithWhereUniqueWithoutProvinceInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedUpdateWithoutProvinceInput update;

  final Input$SchoolUncheckedCreateWithoutProvinceInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpsertWithWhereUniqueWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedUpdateWithoutProvinceInput? update,
          Input$SchoolUncheckedCreateWithoutProvinceInput? create}) =>
      Input$SchoolUpsertWithWhereUniqueWithoutProvinceInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput {
  Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$SchoolUpsertWithWhereUniqueWithoutRegencyInputFromJson(json);

  final Input$SchoolWhereUniqueInput where;

  final Input$SchoolUncheckedUpdateWithoutRegencyInput update;

  final Input$SchoolUncheckedCreateWithoutRegencyInput create;

  Map<String, dynamic> toJson() =>
      _$Input$SchoolUpsertWithWhereUniqueWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput copyWith(
          {Input$SchoolWhereUniqueInput? where,
          Input$SchoolUncheckedUpdateWithoutRegencyInput? update,
          Input$SchoolUncheckedCreateWithoutRegencyInput? create}) =>
      Input$SchoolUpsertWithWhereUniqueWithoutRegencyInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolWhereInput {
  Input$SchoolWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.npsn,
      this.createdAt,
      this.updatedAt,
      this.classrooms,
      this.levels,
      this.type,
      this.address,
      this.logoPath,
      this.bannerPath,
      this.provinceId,
      this.province,
      this.regencyId,
      this.regency,
      this.schoolStaffs,
      this.students});

  @override
  factory Input$SchoolWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolWhereInputFromJson(json);

  final List<Input$SchoolWhereInput?>? AND;

  final List<Input$SchoolWhereInput?>? OR;

  final List<Input$SchoolWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringNullableFilter? npsn;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ClassroomListRelationFilter? classrooms;

  final Input$IntNullableListFilter? levels;

  final Input$StringFilter? type;

  final Input$StringNullableFilter? address;

  final Input$StringNullableFilter? logoPath;

  final Input$StringNullableFilter? bannerPath;

  final Input$StringFilter? provinceId;

  final Input$ProvinceWhereInput? province;

  final Input$StringFilter? regencyId;

  final Input$RegencyWhereInput? regency;

  final Input$SchoolStaffListRelationFilter? schoolStaffs;

  final Input$UserListRelationFilter? students;

  Map<String, dynamic> toJson() => _$Input$SchoolWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$npsn = npsn;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$classrooms = classrooms;
    final l$levels = levels;
    final l$type = type;
    final l$address = address;
    final l$logoPath = logoPath;
    final l$bannerPath = bannerPath;
    final l$provinceId = provinceId;
    final l$province = province;
    final l$regencyId = regencyId;
    final l$regency = regency;
    final l$schoolStaffs = schoolStaffs;
    final l$students = students;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$npsn,
      l$createdAt,
      l$updatedAt,
      l$classrooms,
      l$levels,
      l$type,
      l$address,
      l$logoPath,
      l$bannerPath,
      l$provinceId,
      l$province,
      l$regencyId,
      l$regency,
      l$schoolStaffs,
      l$students
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$npsn = npsn;
    final lOther$npsn = other.npsn;
    if (l$npsn != lOther$npsn) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$levels = levels;
    final lOther$levels = other.levels;
    if (l$levels != lOther$levels) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$logoPath = logoPath;
    final lOther$logoPath = other.logoPath;
    if (l$logoPath != lOther$logoPath) return false;
    final l$bannerPath = bannerPath;
    final lOther$bannerPath = other.bannerPath;
    if (l$bannerPath != lOther$bannerPath) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$students = students;
    final lOther$students = other.students;
    if (l$students != lOther$students) return false;
    return true;
  }

  Input$SchoolWhereInput copyWith(
          {List<Input$SchoolWhereInput?>? Function()? AND,
          List<Input$SchoolWhereInput?>? Function()? OR,
          List<Input$SchoolWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringNullableFilter? Function()? npsn,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ClassroomListRelationFilter? Function()? classrooms,
          Input$IntNullableListFilter? Function()? levels,
          Input$StringFilter? Function()? type,
          Input$StringNullableFilter? Function()? address,
          Input$StringNullableFilter? Function()? logoPath,
          Input$StringNullableFilter? Function()? bannerPath,
          Input$StringFilter? Function()? provinceId,
          Input$ProvinceWhereInput? Function()? province,
          Input$StringFilter? Function()? regencyId,
          Input$RegencyWhereInput? Function()? regency,
          Input$SchoolStaffListRelationFilter? Function()? schoolStaffs,
          Input$UserListRelationFilter? Function()? students}) =>
      Input$SchoolWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          npsn: npsn == null ? this.npsn : npsn(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          levels: levels == null ? this.levels : levels(),
          type: type == null ? this.type : type(),
          address: address == null ? this.address : address(),
          logoPath: logoPath == null ? this.logoPath : logoPath(),
          bannerPath: bannerPath == null ? this.bannerPath : bannerPath(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          province: province == null ? this.province : province(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          regency: regency == null ? this.regency : regency(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          students: students == null ? this.students : students());
}

@JsonSerializable(explicitToJson: true)
class Input$SchoolWhereUniqueInput {
  Input$SchoolWhereUniqueInput({this.id});

  @override
  factory Input$SchoolWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$SchoolWhereUniqueInputFromJson(json);

  final String? id;

  Map<String, dynamic> toJson() => _$Input$SchoolWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$SchoolWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$SchoolWhereUniqueInput copyWith({String? Function()? id}) =>
      Input$SchoolWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$StringFieldUpdateOperationsInput {
  Input$StringFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$StringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$StringFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$StringFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$StringFieldUpdateOperationsInput copyWith({String? Function()? $set}) =>
      Input$StringFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$StringFilter {
  Input$StringFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not});

  @override
  factory Input$StringFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$StringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringFilter? not;

  Map<String, dynamic> toJson() => _$Input$StringFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$StringFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringFilter? Function()? not}) =>
      Input$StringFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$StringNullableFilter {
  Input$StringNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not});

  @override
  factory Input$StringNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$StringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$StringNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$StringNullableFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringNullableFilter? Function()? not}) =>
      Input$StringNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$StringNullableListFilter {
  Input$StringNullableListFilter(
      {this.equals, this.has, this.hasEvery, this.hasSome, this.isEmpty});

  @override
  factory Input$StringNullableListFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$StringNullableListFilterFromJson(json);

  final List<String?>? equals;

  final String? has;

  final List<String?>? hasEvery;

  final List<String?>? hasSome;

  final bool? isEmpty;

  Map<String, dynamic> toJson() => _$Input$StringNullableListFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$has = has;
    final l$hasEvery = hasEvery;
    final l$hasSome = hasSome;
    final l$isEmpty = isEmpty;
    return Object.hashAll([
      l$equals == null ? null : Object.hashAll(l$equals.map((v) => v)),
      l$has,
      l$hasEvery == null ? null : Object.hashAll(l$hasEvery.map((v) => v)),
      l$hasSome == null ? null : Object.hashAll(l$hasSome.map((v) => v)),
      l$isEmpty
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringNullableListFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != null && lOther$equals != null) {
      if (l$equals.length != lOther$equals.length) return false;
      for (int i = 0; i < l$equals.length; i++) {
        final l$equals$entry = l$equals[i];
        final lOther$equals$entry = lOther$equals[i];
        if (l$equals$entry != lOther$equals$entry) return false;
      }
    } else if (l$equals != lOther$equals) {
      return false;
    }

    final l$has = has;
    final lOther$has = other.has;
    if (l$has != lOther$has) return false;
    final l$hasEvery = hasEvery;
    final lOther$hasEvery = other.hasEvery;
    if (l$hasEvery != null && lOther$hasEvery != null) {
      if (l$hasEvery.length != lOther$hasEvery.length) return false;
      for (int i = 0; i < l$hasEvery.length; i++) {
        final l$hasEvery$entry = l$hasEvery[i];
        final lOther$hasEvery$entry = lOther$hasEvery[i];
        if (l$hasEvery$entry != lOther$hasEvery$entry) return false;
      }
    } else if (l$hasEvery != lOther$hasEvery) {
      return false;
    }

    final l$hasSome = hasSome;
    final lOther$hasSome = other.hasSome;
    if (l$hasSome != null && lOther$hasSome != null) {
      if (l$hasSome.length != lOther$hasSome.length) return false;
      for (int i = 0; i < l$hasSome.length; i++) {
        final l$hasSome$entry = l$hasSome[i];
        final lOther$hasSome$entry = lOther$hasSome[i];
        if (l$hasSome$entry != lOther$hasSome$entry) return false;
      }
    } else if (l$hasSome != lOther$hasSome) {
      return false;
    }

    final l$isEmpty = isEmpty;
    final lOther$isEmpty = other.isEmpty;
    if (l$isEmpty != lOther$isEmpty) return false;
    return true;
  }

  Input$StringNullableListFilter copyWith(
          {List<String?>? Function()? equals,
          String? Function()? has,
          List<String?>? Function()? hasEvery,
          List<String?>? Function()? hasSome,
          bool? Function()? isEmpty}) =>
      Input$StringNullableListFilter(
          equals: equals == null ? this.equals : equals(),
          has: has == null ? this.has : has(),
          hasEvery: hasEvery == null ? this.hasEvery : hasEvery(),
          hasSome: hasSome == null ? this.hasSome : hasSome(),
          isEmpty: isEmpty == null ? this.isEmpty : isEmpty());
}

@JsonSerializable(explicitToJson: true)
class Input$StringNullableWithAggregatesFilter {
  Input$StringNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$StringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$StringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$StringNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$StringNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedStringNullableFilter? Function()? $_min,
          Input$NestedStringNullableFilter? Function()? $_max}) =>
      Input$StringNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$StringWithAggregatesFilter {
  Input$StringWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$StringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$StringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$StringWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$StringWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedStringFilter? Function()? $_min,
          Input$NestedStringFilter? Function()? $_max}) =>
      Input$StringWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$UserAvgOrderByAggregateInput {
  Input$UserAvgOrderByAggregateInput({this.balance});

  @override
  factory Input$UserAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  Map<String, dynamic> toJson() =>
      _$Input$UserAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$balance = balance;
    return Object.hashAll([l$balance]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    return true;
  }

  Input$UserAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? balance}) =>
      Input$UserAvgOrderByAggregateInput(
          balance: balance == null ? this.balance : balance());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCountOrderByAggregateInput {
  Input$UserCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumber;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? profilePicturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nisn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nrg;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifykey;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifyType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isBimbel;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? role;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? emailVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bimbelApprovedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? identityNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? phoneNumber,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? profilePicturePath,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? nisn,
          Enum$SortOrder? Function()? nrg,
          Enum$SortOrder? Function()? verifykey,
          Enum$SortOrder? Function()? verifyType,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? isBimbel,
          Enum$SortOrder? Function()? role,
          Enum$SortOrder? Function()? balance,
          Enum$SortOrder? Function()? emailVerifiedAt,
          Enum$SortOrder? Function()? phoneNumberVerifiedAt,
          Enum$SortOrder? Function()? bimbelApprovedAt,
          Enum$SortOrder? Function()? identityNumberVerifiedAt,
          Enum$SortOrder? Function()? schoolId}) =>
      Input$UserCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateInput {
  Input$UserCreateInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserCreateInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() => _$Input$UserCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManyInput {
  Input$UserCreateManyInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserCreateManyInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final String? schoolId;

  Map<String, dynamic> toJson() => _$Input$UserCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserCreateManyInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          String? Function()? schoolId}) =>
      Input$UserCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManyProvinceInput {
  Input$UserCreateManyProvinceInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserCreateManyProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateManyProvinceInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateManyProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManyProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserCreateManyProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          String? Function()? schoolId}) =>
      Input$UserCreateManyProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManyProvinceInputEnvelope {
  Input$UserCreateManyProvinceInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$UserCreateManyProvinceInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateManyProvinceInputEnvelopeFromJson(json);

  final Input$UserCreateManyProvinceInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateManyProvinceInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManyProvinceInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$UserCreateManyProvinceInputEnvelope copyWith(
          {Input$UserCreateManyProvinceInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$UserCreateManyProvinceInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManyRegencyInput {
  Input$UserCreateManyRegencyInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserCreateManyRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateManyRegencyInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateManyRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManyRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserCreateManyRegencyInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          String? Function()? schoolId}) =>
      Input$UserCreateManyRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManyRegencyInputEnvelope {
  Input$UserCreateManyRegencyInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$UserCreateManyRegencyInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateManyRegencyInputEnvelopeFromJson(json);

  final Input$UserCreateManyRegencyInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateManyRegencyInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManyRegencyInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$UserCreateManyRegencyInputEnvelope copyWith(
          {Input$UserCreateManyRegencyInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$UserCreateManyRegencyInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManySchoolInput {
  Input$UserCreateManySchoolInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt});

  @override
  factory Input$UserCreateManySchoolInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserCreateManySchoolInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateManySchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManySchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    return true;
  }

  Input$UserCreateManySchoolInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt}) =>
      Input$UserCreateManySchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManySchoolInputEnvelope {
  Input$UserCreateManySchoolInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$UserCreateManySchoolInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateManySchoolInputEnvelopeFromJson(json);

  final Input$UserCreateManySchoolInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateManySchoolInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManySchoolInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$UserCreateManySchoolInputEnvelope copyWith(
          {Input$UserCreateManySchoolInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$UserCreateManySchoolInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedManyWithoutProvinceInput {
  Input$UserCreateNestedManyWithoutProvinceInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$UserCreateNestedManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedManyWithoutProvinceInputFromJson(json);

  final List<Input$UserCreateWithoutProvinceInput?>? create;

  final List<Input$UserCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final Input$UserCreateManyProvinceInputEnvelope? createMany;

  final List<Input$UserWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$UserCreateNestedManyWithoutProvinceInput copyWith(
          {List<Input$UserCreateWithoutProvinceInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          Input$UserCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? connect}) =>
      Input$UserCreateNestedManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedManyWithoutRegencyInput {
  Input$UserCreateNestedManyWithoutRegencyInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$UserCreateNestedManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedManyWithoutRegencyInputFromJson(json);

  final List<Input$UserCreateWithoutRegencyInput?>? create;

  final List<Input$UserCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final Input$UserCreateManyRegencyInputEnvelope? createMany;

  final List<Input$UserWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$UserCreateNestedManyWithoutRegencyInput copyWith(
          {List<Input$UserCreateWithoutRegencyInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          Input$UserCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? connect}) =>
      Input$UserCreateNestedManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedManyWithoutSchoolInput {
  Input$UserCreateNestedManyWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$UserCreateNestedManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedManyWithoutSchoolInputFromJson(json);

  final List<Input$UserCreateWithoutSchoolInput?>? create;

  final List<Input$UserCreateOrConnectWithoutSchoolInput?>? connectOrCreate;

  final Input$UserCreateManySchoolInputEnvelope? createMany;

  final List<Input$UserWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$UserCreateNestedManyWithoutSchoolInput copyWith(
          {List<Input$UserCreateWithoutSchoolInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          Input$UserCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? connect}) =>
      Input$UserCreateNestedManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutClassroomsInput {
  Input$UserCreateNestedOneWithoutClassroomsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutClassroomsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutClassroomsInput? create;

  final Input$UserCreateOrConnectWithoutClassroomsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutClassroomsInput copyWith(
          {Input$UserUncheckedCreateWithoutClassroomsInput? Function()? create,
          Input$UserCreateOrConnectWithoutClassroomsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutClassroomsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutClassroomStudentsInput {
  Input$UserCreateNestedOneWithoutClassroomStudentsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutClassroomStudentsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutClassroomStudentsInput? create;

  final Input$UserCreateOrConnectWithoutClassroomStudentsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutClassroomStudentsInput copyWith(
          {Input$UserUncheckedCreateWithoutClassroomStudentsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutClassroomStudentsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutClassroomStudentsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutExaminationsInput {
  Input$UserCreateNestedOneWithoutExaminationsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutExaminationsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutExaminationsInput? create;

  final Input$UserCreateOrConnectWithoutExaminationsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutExaminationsInput copyWith(
          {Input$UserUncheckedCreateWithoutExaminationsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutExaminationsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutExaminationsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutExamsessionsInput {
  Input$UserCreateNestedOneWithoutExamsessionsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutExamsessionsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutExamsessionsInput? create;

  final Input$UserCreateOrConnectWithoutExamsessionsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutExamsessionsInput copyWith(
          {Input$UserUncheckedCreateWithoutExamsessionsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutExamsessionsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutExamsessionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutIdentityFilesInput {
  Input$UserCreateNestedOneWithoutIdentityFilesInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutIdentityFilesInputFromJson(json);

  final Input$UserUncheckedCreateWithoutIdentityFilesInput? create;

  final Input$UserCreateOrConnectWithoutIdentityFilesInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutIdentityFilesInput copyWith(
          {Input$UserUncheckedCreateWithoutIdentityFilesInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutIdentityFilesInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutIdentityFilesInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutMyChatsInput {
  Input$UserCreateNestedOneWithoutMyChatsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutMyChatsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutMyChatsInput? create;

  final Input$UserCreateOrConnectWithoutMyChatsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutMyChatsInput copyWith(
          {Input$UserUncheckedCreateWithoutMyChatsInput? Function()? create,
          Input$UserCreateOrConnectWithoutMyChatsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutMyChatsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutNotificationsInput {
  Input$UserCreateNestedOneWithoutNotificationsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutNotificationsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutNotificationsInput? create;

  final Input$UserCreateOrConnectWithoutNotificationsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutNotificationsInput copyWith(
          {Input$UserUncheckedCreateWithoutNotificationsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutNotificationsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutNotificationsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutQuestionsInput {
  Input$UserCreateNestedOneWithoutQuestionsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutQuestionsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutQuestionsInput? create;

  final Input$UserCreateOrConnectWithoutQuestionsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutQuestionsInput copyWith(
          {Input$UserUncheckedCreateWithoutQuestionsInput? Function()? create,
          Input$UserCreateOrConnectWithoutQuestionsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutQuestionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutSchoolStaffsInput {
  Input$UserCreateNestedOneWithoutSchoolStaffsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutSchoolStaffsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutSchoolStaffsInput? create;

  final Input$UserCreateOrConnectWithoutSchoolStaffsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutSchoolStaffsInput copyWith(
          {Input$UserUncheckedCreateWithoutSchoolStaffsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutSchoolStaffsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutSchoolStaffsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutClassroomsInput {
  Input$UserCreateOrConnectWithoutClassroomsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutClassroomsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutClassroomsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutClassroomsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutClassroomsInput? create}) =>
      Input$UserCreateOrConnectWithoutClassroomsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutClassroomStudentsInput {
  Input$UserCreateOrConnectWithoutClassroomStudentsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutClassroomStudentsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutClassroomStudentsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutClassroomStudentsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutClassroomStudentsInput? create}) =>
      Input$UserCreateOrConnectWithoutClassroomStudentsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutExaminationsInput {
  Input$UserCreateOrConnectWithoutExaminationsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutExaminationsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutExaminationsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutExaminationsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutExaminationsInput? create}) =>
      Input$UserCreateOrConnectWithoutExaminationsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutExamsessionsInput {
  Input$UserCreateOrConnectWithoutExamsessionsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutExamsessionsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutExamsessionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutExamsessionsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutExamsessionsInput? create}) =>
      Input$UserCreateOrConnectWithoutExamsessionsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutIdentityFilesInput {
  Input$UserCreateOrConnectWithoutIdentityFilesInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutIdentityFilesInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutIdentityFilesInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutIdentityFilesInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutIdentityFilesInput? create}) =>
      Input$UserCreateOrConnectWithoutIdentityFilesInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutMyChatsInput {
  Input$UserCreateOrConnectWithoutMyChatsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutMyChatsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutMyChatsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutMyChatsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutMyChatsInput? create}) =>
      Input$UserCreateOrConnectWithoutMyChatsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutNotificationsInput {
  Input$UserCreateOrConnectWithoutNotificationsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutNotificationsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutNotificationsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutNotificationsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutNotificationsInput? create}) =>
      Input$UserCreateOrConnectWithoutNotificationsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutProvinceInput {
  Input$UserCreateOrConnectWithoutProvinceInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutProvinceInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutProvinceInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutProvinceInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutProvinceInput? create}) =>
      Input$UserCreateOrConnectWithoutProvinceInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutQuestionsInput {
  Input$UserCreateOrConnectWithoutQuestionsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutQuestionsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutQuestionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutQuestionsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutQuestionsInput? create}) =>
      Input$UserCreateOrConnectWithoutQuestionsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutRegencyInput {
  Input$UserCreateOrConnectWithoutRegencyInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutRegencyInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutRegencyInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutRegencyInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutRegencyInput? create}) =>
      Input$UserCreateOrConnectWithoutRegencyInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutSchoolInput {
  Input$UserCreateOrConnectWithoutSchoolInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutSchoolInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutSchoolInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutSchoolInput? create}) =>
      Input$UserCreateOrConnectWithoutSchoolInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutSchoolStaffsInput {
  Input$UserCreateOrConnectWithoutSchoolStaffsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutSchoolStaffsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutSchoolStaffsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutSchoolStaffsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutSchoolStaffsInput? create}) =>
      Input$UserCreateOrConnectWithoutSchoolStaffsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutClassroomsInput {
  Input$UserCreateWithoutClassroomsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutClassroomsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutClassroomsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutClassroomStudentsInput {
  Input$UserCreateWithoutClassroomStudentsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutClassroomStudentsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutClassroomStudentsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutClassroomStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutExaminationsInput {
  Input$UserCreateWithoutExaminationsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutExaminationsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutExaminationsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutExaminationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutExamsessionsInput {
  Input$UserCreateWithoutExamsessionsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutExamsessionsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutExamsessionsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutExamsessionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutIdentityFilesInput {
  Input$UserCreateWithoutIdentityFilesInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutIdentityFilesInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutIdentityFilesInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutIdentityFilesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutMyChatsInput {
  Input$UserCreateWithoutMyChatsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutMyChatsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutMyChatsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutMyChatsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutNotificationsInput {
  Input$UserCreateWithoutNotificationsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutNotificationsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutNotificationsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutNotificationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutProvinceInput {
  Input$UserCreateWithoutProvinceInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutProvinceInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutQuestionsInput {
  Input$UserCreateWithoutQuestionsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutQuestionsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutQuestionsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutQuestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutRegencyInput {
  Input$UserCreateWithoutRegencyInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserCreateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutRegencyInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutRegencyInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutSchoolInput {
  Input$UserCreateWithoutSchoolInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs});

  @override
  factory Input$UserCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolStaffCreateNestedManyWithoutUserInput? schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$UserCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs}) =>
      Input$UserCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutSchoolStaffsInput {
  Input$UserCreateWithoutSchoolStaffsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.province,
      required this.regency,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.school});

  @override
  factory Input$UserCreateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutSchoolStaffsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final Input$ProvinceCreateNestedOneWithoutUsersInput province;

  final Input$RegencyCreateNestedOneWithoutUsersInput regency;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileCreateNestedManyWithoutUserInput? identityFiles;

  final Input$QuestionCreateNestedManyWithoutUserInput? questions;

  final Input$ExamCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionCreateNestedManyWithoutUserInput? examsessions;

  final Input$ChatCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationCreateNestedManyWithoutUserInput? notifications;

  final Input$SchoolCreateNestedOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserCreateWithoutSchoolStaffsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          Input$ProvinceCreateNestedOneWithoutUsersInput? province,
          Input$RegencyCreateNestedOneWithoutUsersInput? regency,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionCreateNestedManyWithoutUserInput? Function()? questions,
          Input$ExamCreateNestedManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatCreateNestedManyWithoutFromInput? Function()? myChats,
          Input$ClassroomCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolCreateNestedOneWithoutStudentsInput? Function()?
              school}) =>
      Input$UserCreateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province,
          regency: regency == null ? this.regency : regency,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserListRelationFilter {
  Input$UserListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$UserListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$UserListRelationFilterFromJson(json);

  final Input$UserWhereInput? every;

  final Input$UserWhereInput? some;

  final Input$UserWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$UserListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$UserListRelationFilter copyWith(
          {Input$UserWhereInput? Function()? every,
          Input$UserWhereInput? Function()? some,
          Input$UserWhereInput? Function()? none}) =>
      Input$UserListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$UserMaxOrderByAggregateInput {
  Input$UserMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumber;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? profilePicturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nisn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nrg;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifykey;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifyType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isBimbel;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? role;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? emailVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bimbelApprovedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? identityNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? phoneNumber,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? profilePicturePath,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? nisn,
          Enum$SortOrder? Function()? nrg,
          Enum$SortOrder? Function()? verifykey,
          Enum$SortOrder? Function()? verifyType,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? isBimbel,
          Enum$SortOrder? Function()? role,
          Enum$SortOrder? Function()? balance,
          Enum$SortOrder? Function()? emailVerifiedAt,
          Enum$SortOrder? Function()? phoneNumberVerifiedAt,
          Enum$SortOrder? Function()? bimbelApprovedAt,
          Enum$SortOrder? Function()? identityNumberVerifiedAt,
          Enum$SortOrder? Function()? schoolId}) =>
      Input$UserMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserMinOrderByAggregateInput {
  Input$UserMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumber;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? profilePicturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nisn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nrg;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifykey;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifyType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isBimbel;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? role;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? emailVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bimbelApprovedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? identityNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? phoneNumber,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? profilePicturePath,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? nisn,
          Enum$SortOrder? Function()? nrg,
          Enum$SortOrder? Function()? verifykey,
          Enum$SortOrder? Function()? verifyType,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? isBimbel,
          Enum$SortOrder? Function()? role,
          Enum$SortOrder? Function()? balance,
          Enum$SortOrder? Function()? emailVerifiedAt,
          Enum$SortOrder? Function()? phoneNumberVerifiedAt,
          Enum$SortOrder? Function()? bimbelApprovedAt,
          Enum$SortOrder? Function()? identityNumberVerifiedAt,
          Enum$SortOrder? Function()? schoolId}) =>
      Input$UserMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserOrderByRelationAggregateInput {
  Input$UserOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$UserOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$UserOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$UserOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$UserOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$UserOrderByWithAggregationInput {
  Input$UserOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$UserOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumber;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? profilePicturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nisn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nrg;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifykey;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifyType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isBimbel;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? role;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? emailVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bimbelApprovedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? identityNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  @JsonKey(name: '_count')
  final Input$UserCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$UserAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$UserMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$UserMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$UserSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$UserOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$UserOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? phoneNumber,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? profilePicturePath,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? nisn,
          Enum$SortOrder? Function()? nrg,
          Enum$SortOrder? Function()? verifykey,
          Enum$SortOrder? Function()? verifyType,
          Enum$SortOrder? Function()? provinceId,
          Enum$SortOrder? Function()? regencyId,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? isBimbel,
          Enum$SortOrder? Function()? role,
          Enum$SortOrder? Function()? balance,
          Enum$SortOrder? Function()? emailVerifiedAt,
          Enum$SortOrder? Function()? phoneNumberVerifiedAt,
          Enum$SortOrder? Function()? bimbelApprovedAt,
          Enum$SortOrder? Function()? identityNumberVerifiedAt,
          Enum$SortOrder? Function()? schoolId,
          Input$UserCountOrderByAggregateInput? Function()? $_count,
          Input$UserAvgOrderByAggregateInput? Function()? $_avg,
          Input$UserMaxOrderByAggregateInput? Function()? $_max,
          Input$UserMinOrderByAggregateInput? Function()? $_min,
          Input$UserSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$UserOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$UserOrderByWithRelationInput {
  Input$UserOrderByWithRelationInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.province,
      this.regencyId,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId,
      this.school});

  @override
  factory Input$UserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumber;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? address;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? profilePicturePath;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nisn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? nrg;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifykey;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? verifyType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? provinceId;

  final Input$ProvinceOrderByWithRelationInput? province;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? regencyId;

  final Input$RegencyOrderByWithRelationInput? regency;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isBimbel;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? role;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? emailVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? phoneNumberVerifiedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? bimbelApprovedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? identityNumberVerifiedAt;

  final Input$IdentityFileOrderByRelationAggregateInput? identityFiles;

  final Input$QuestionOrderByRelationAggregateInput? questions;

  final Input$ExamOrderByRelationAggregateInput? examinations;

  final Input$ExamSessionOrderByRelationAggregateInput? examsessions;

  final Input$ChatOrderByRelationAggregateInput? myChats;

  final Input$ClassroomOrderByRelationAggregateInput? classrooms;

  final Input$ClassroomStudentOrderByRelationAggregateInput? classroomStudents;

  final Input$NotificationOrderByRelationAggregateInput? notifications;

  final Input$SchoolStaffOrderByRelationAggregateInput? schoolStaffs;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? schoolId;

  final Input$SchoolOrderByWithRelationInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$province = province;
    final l$regencyId = regencyId;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$province,
      l$regencyId,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? phoneNumber,
          Enum$SortOrder? Function()? address,
          Enum$SortOrder? Function()? profilePicturePath,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? nisn,
          Enum$SortOrder? Function()? nrg,
          Enum$SortOrder? Function()? verifykey,
          Enum$SortOrder? Function()? verifyType,
          Enum$SortOrder? Function()? provinceId,
          Input$ProvinceOrderByWithRelationInput? Function()? province,
          Enum$SortOrder? Function()? regencyId,
          Input$RegencyOrderByWithRelationInput? Function()? regency,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? isBimbel,
          Enum$SortOrder? Function()? role,
          Enum$SortOrder? Function()? balance,
          Enum$SortOrder? Function()? emailVerifiedAt,
          Enum$SortOrder? Function()? phoneNumberVerifiedAt,
          Enum$SortOrder? Function()? bimbelApprovedAt,
          Enum$SortOrder? Function()? identityNumberVerifiedAt,
          Input$IdentityFileOrderByRelationAggregateInput? Function()?
              identityFiles,
          Input$QuestionOrderByRelationAggregateInput? Function()? questions,
          Input$ExamOrderByRelationAggregateInput? Function()? examinations,
          Input$ExamSessionOrderByRelationAggregateInput? Function()?
              examsessions,
          Input$ChatOrderByRelationAggregateInput? Function()? myChats,
          Input$ClassroomOrderByRelationAggregateInput? Function()? classrooms,
          Input$ClassroomStudentOrderByRelationAggregateInput? Function()?
              classroomStudents,
          Input$NotificationOrderByRelationAggregateInput? Function()?
              notifications,
          Input$SchoolStaffOrderByRelationAggregateInput? Function()?
              schoolStaffs,
          Enum$SortOrder? Function()? schoolId,
          Input$SchoolOrderByWithRelationInput? Function()? school}) =>
      Input$UserOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          province: province == null ? this.province : province(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserRelationFilter {
  Input$UserRelationFilter({this.$is, this.isNot});

  @override
  factory Input$UserRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$UserRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$UserWhereInput? $is;

  final Input$UserWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$UserRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$UserRelationFilter copyWith(
          {Input$UserWhereInput? Function()? $is,
          Input$UserWhereInput? Function()? isNot}) =>
      Input$UserRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$UserScalarWhereInput {
  Input$UserScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserScalarWhereInputFromJson(json);

  final List<Input$UserScalarWhereInput?>? AND;

  final List<Input$UserScalarWhereInput?>? OR;

  final List<Input$UserScalarWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? email;

  final Input$StringFilter? phoneNumber;

  final Input$StringNullableFilter? address;

  final Input$StringNullableFilter? profilePicturePath;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$StringNullableFilter? nisn;

  final Input$StringNullableFilter? nrg;

  final Input$StringNullableFilter? verifykey;

  final Input$EnumVerifyTypeNullableFilter? verifyType;

  final Input$StringFilter? provinceId;

  final Input$StringFilter? regencyId;

  final Input$BoolFilter? isAdmin;

  final Input$BoolFilter? isBimbel;

  final Input$EnumRolesFilter? role;

  final Input$FloatFilter? balance;

  final Input$DateTimeNullableFilter? emailVerifiedAt;

  final Input$DateTimeNullableFilter? phoneNumberVerifiedAt;

  final Input$DateTimeNullableFilter? bimbelApprovedAt;

  final Input$DateTimeNullableFilter? identityNumberVerifiedAt;

  final Input$StringNullableFilter? schoolId;

  Map<String, dynamic> toJson() => _$Input$UserScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserScalarWhereInput copyWith(
          {List<Input$UserScalarWhereInput?>? Function()? AND,
          List<Input$UserScalarWhereInput?>? Function()? OR,
          List<Input$UserScalarWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? email,
          Input$StringFilter? Function()? phoneNumber,
          Input$StringNullableFilter? Function()? address,
          Input$StringNullableFilter? Function()? profilePicturePath,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$StringNullableFilter? Function()? nisn,
          Input$StringNullableFilter? Function()? nrg,
          Input$StringNullableFilter? Function()? verifykey,
          Input$EnumVerifyTypeNullableFilter? Function()? verifyType,
          Input$StringFilter? Function()? provinceId,
          Input$StringFilter? Function()? regencyId,
          Input$BoolFilter? Function()? isAdmin,
          Input$BoolFilter? Function()? isBimbel,
          Input$EnumRolesFilter? Function()? role,
          Input$FloatFilter? Function()? balance,
          Input$DateTimeNullableFilter? Function()? emailVerifiedAt,
          Input$DateTimeNullableFilter? Function()? phoneNumberVerifiedAt,
          Input$DateTimeNullableFilter? Function()? bimbelApprovedAt,
          Input$DateTimeNullableFilter? Function()? identityNumberVerifiedAt,
          Input$StringNullableFilter? Function()? schoolId}) =>
      Input$UserScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserScalarWhereWithAggregatesInput {
  Input$UserScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$UserScalarWhereWithAggregatesInput?>? AND;

  final List<Input$UserScalarWhereWithAggregatesInput?>? OR;

  final List<Input$UserScalarWhereWithAggregatesInput?>? NOT;

  final Input$StringWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? email;

  final Input$StringWithAggregatesFilter? phoneNumber;

  final Input$StringNullableWithAggregatesFilter? address;

  final Input$StringNullableWithAggregatesFilter? profilePicturePath;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  final Input$StringNullableWithAggregatesFilter? nisn;

  final Input$StringNullableWithAggregatesFilter? nrg;

  final Input$StringNullableWithAggregatesFilter? verifykey;

  final Input$EnumVerifyTypeNullableWithAggregatesFilter? verifyType;

  final Input$StringWithAggregatesFilter? provinceId;

  final Input$StringWithAggregatesFilter? regencyId;

  final Input$BoolWithAggregatesFilter? isAdmin;

  final Input$BoolWithAggregatesFilter? isBimbel;

  final Input$EnumRolesWithAggregatesFilter? role;

  final Input$FloatWithAggregatesFilter? balance;

  final Input$DateTimeNullableWithAggregatesFilter? emailVerifiedAt;

  final Input$DateTimeNullableWithAggregatesFilter? phoneNumberVerifiedAt;

  final Input$DateTimeNullableWithAggregatesFilter? bimbelApprovedAt;

  final Input$DateTimeNullableWithAggregatesFilter? identityNumberVerifiedAt;

  final Input$StringNullableWithAggregatesFilter? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserScalarWhereWithAggregatesInput copyWith(
          {List<Input$UserScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$UserScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$UserScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$StringWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? email,
          Input$StringWithAggregatesFilter? Function()? phoneNumber,
          Input$StringNullableWithAggregatesFilter? Function()? address,
          Input$StringNullableWithAggregatesFilter? Function()?
              profilePicturePath,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt,
          Input$StringNullableWithAggregatesFilter? Function()? nisn,
          Input$StringNullableWithAggregatesFilter? Function()? nrg,
          Input$StringNullableWithAggregatesFilter? Function()? verifykey,
          Input$EnumVerifyTypeNullableWithAggregatesFilter? Function()?
              verifyType,
          Input$StringWithAggregatesFilter? Function()? provinceId,
          Input$StringWithAggregatesFilter? Function()? regencyId,
          Input$BoolWithAggregatesFilter? Function()? isAdmin,
          Input$BoolWithAggregatesFilter? Function()? isBimbel,
          Input$EnumRolesWithAggregatesFilter? Function()? role,
          Input$FloatWithAggregatesFilter? Function()? balance,
          Input$DateTimeNullableWithAggregatesFilter? Function()?
              emailVerifiedAt,
          Input$DateTimeNullableWithAggregatesFilter? Function()?
              phoneNumberVerifiedAt,
          Input$DateTimeNullableWithAggregatesFilter? Function()?
              bimbelApprovedAt,
          Input$DateTimeNullableWithAggregatesFilter? Function()?
              identityNumberVerifiedAt,
          Input$StringNullableWithAggregatesFilter? Function()? schoolId}) =>
      Input$UserScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserSumOrderByAggregateInput {
  Input$UserSumOrderByAggregateInput({this.balance});

  @override
  factory Input$UserSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? balance;

  Map<String, dynamic> toJson() =>
      _$Input$UserSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$balance = balance;
    return Object.hashAll([l$balance]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    return true;
  }

  Input$UserSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? balance}) =>
      Input$UserSumOrderByAggregateInput(
          balance: balance == null ? this.balance : balance());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateInput {
  Input$UserUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() => _$Input$UserUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions: examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateNestedManyWithoutProvinceInput {
  Input$UserUncheckedCreateNestedManyWithoutProvinceInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$UserUncheckedCreateNestedManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateNestedManyWithoutProvinceInputFromJson(json);

  final List<Input$UserCreateWithoutProvinceInput?>? create;

  final List<Input$UserCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final Input$UserCreateManyProvinceInputEnvelope? createMany;

  final List<Input$UserWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateNestedManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateNestedManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$UserUncheckedCreateNestedManyWithoutProvinceInput copyWith(
          {List<Input$UserCreateWithoutProvinceInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          Input$UserCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? connect}) =>
      Input$UserUncheckedCreateNestedManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateNestedManyWithoutRegencyInput {
  Input$UserUncheckedCreateNestedManyWithoutRegencyInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$UserUncheckedCreateNestedManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateNestedManyWithoutRegencyInputFromJson(json);

  final List<Input$UserCreateWithoutRegencyInput?>? create;

  final List<Input$UserCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final Input$UserCreateManyRegencyInputEnvelope? createMany;

  final List<Input$UserWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateNestedManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateNestedManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$UserUncheckedCreateNestedManyWithoutRegencyInput copyWith(
          {List<Input$UserCreateWithoutRegencyInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          Input$UserCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? connect}) =>
      Input$UserUncheckedCreateNestedManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateNestedManyWithoutSchoolInput {
  Input$UserUncheckedCreateNestedManyWithoutSchoolInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$UserUncheckedCreateNestedManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateNestedManyWithoutSchoolInputFromJson(json);

  final List<Input$UserCreateWithoutSchoolInput?>? create;

  final List<Input$UserCreateOrConnectWithoutSchoolInput?>? connectOrCreate;

  final Input$UserCreateManySchoolInputEnvelope? createMany;

  final List<Input$UserWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateNestedManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateNestedManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$UserUncheckedCreateNestedManyWithoutSchoolInput copyWith(
          {List<Input$UserCreateWithoutSchoolInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          Input$UserCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? connect}) =>
      Input$UserUncheckedCreateNestedManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutClassroomsInput {
  Input$UserUncheckedCreateWithoutClassroomsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutClassroomsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutClassroomsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classroomStudents:
              classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutClassroomStudentsInput {
  Input$UserUncheckedCreateWithoutClassroomStudentsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutClassroomStudentsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutClassroomStudentsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutClassroomStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutExaminationsInput {
  Input$UserUncheckedCreateWithoutExaminationsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutExaminationsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutExaminationsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutExaminationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutExamsessionsInput {
  Input$UserUncheckedCreateWithoutExamsessionsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutExamsessionsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutExamsessionsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutExamsessionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutIdentityFilesInput {
  Input$UserUncheckedCreateWithoutIdentityFilesInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutIdentityFilesInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutIdentityFilesInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutIdentityFilesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutMyChatsInput {
  Input$UserUncheckedCreateWithoutMyChatsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutMyChatsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutMyChatsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutMyChatsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions: examsessions == null ? this.examsessions : examsessions(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutNotificationsInput {
  Input$UserUncheckedCreateWithoutNotificationsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutNotificationsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutNotificationsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutNotificationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutProvinceInput {
  Input$UserUncheckedCreateWithoutProvinceInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutProvinceInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutProvinceInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations: examinations == null ? this.examinations : examinations(),
          examsessions: examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutQuestionsInput {
  Input$UserUncheckedCreateWithoutQuestionsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutQuestionsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutQuestionsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutQuestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions: examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutRegencyInput {
  Input$UserUncheckedCreateWithoutRegencyInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutRegencyInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutRegencyInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              schoolStaffs,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations: examinations == null ? this.examinations : examinations(),
          examsessions: examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutSchoolInput {
  Input$UserUncheckedCreateWithoutSchoolInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs});

  @override
  factory Input$UserUncheckedCreateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutSchoolInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput?
      schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutSchoolInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              notifications,
          Input$SchoolStaffUncheckedCreateNestedManyWithoutUserInput? Function()?
              schoolStaffs}) =>
      Input$UserUncheckedCreateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations: examinations == null ? this.examinations : examinations(),
          examsessions: examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolStaffs: schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutSchoolStaffsInput {
  Input$UserUncheckedCreateWithoutSchoolStaffsInput(
      {this.id,
      required this.name,
      required this.email,
      required this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      required this.provinceId,
      required this.regencyId,
      this.isAdmin,
      this.isBimbel,
      required this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolId});

  @override
  factory Input$UserUncheckedCreateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutSchoolStaffsInputFromJson(json);

  final String? id;

  final String name;

  final String email;

  final String phoneNumber;

  final String? address;

  final String? profilePicturePath;

  final String? createdAt;

  final String? updatedAt;

  final String? nisn;

  final String? nrg;

  final String? verifykey;

  @JsonKey(unknownEnumValue: Enum$VerifyType.$unknown)
  final Enum$VerifyType? verifyType;

  final String provinceId;

  final String regencyId;

  final bool? isAdmin;

  final bool? isBimbel;

  @JsonKey(unknownEnumValue: Enum$Roles.$unknown)
  final Enum$Roles role;

  final double? balance;

  final String? emailVerifiedAt;

  final String? phoneNumberVerifiedAt;

  final String? bimbelApprovedAt;

  final String? identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput?
      identityFiles;

  final Input$QuestionUncheckedCreateNestedManyWithoutUserInput? questions;

  final Input$ExamUncheckedCreateNestedManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput?
      examsessions;

  final Input$ChatUncheckedCreateNestedManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedCreateNestedManyWithoutUserInput?
      notifications;

  final String? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutSchoolStaffsInput copyWith(
          {String? Function()? id,
          String? name,
          String? email,
          String? phoneNumber,
          String? Function()? address,
          String? Function()? profilePicturePath,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          String? Function()? nisn,
          String? Function()? nrg,
          String? Function()? verifykey,
          Enum$VerifyType? Function()? verifyType,
          String? provinceId,
          String? regencyId,
          bool? Function()? isAdmin,
          bool? Function()? isBimbel,
          Enum$Roles? role,
          double? Function()? balance,
          String? Function()? emailVerifiedAt,
          String? Function()? phoneNumberVerifiedAt,
          String? Function()? bimbelApprovedAt,
          String? Function()? identityNumberVerifiedAt,
          Input$IdentityFileUncheckedCreateNestedManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedCreateNestedManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedCreateNestedManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedCreateNestedManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedCreateNestedManyWithoutFromInput? Function()?
              myChats,
          Input$ClassroomUncheckedCreateNestedManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedCreateNestedManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedCreateNestedManyWithoutUserInput? Function()?
              notifications,
          String? Function()? schoolId}) =>
      Input$UserUncheckedCreateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          email: email == null ? this.email : email,
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber,
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId,
          regencyId: regencyId == null ? this.regencyId : regencyId,
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role,
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents:
              classroomStudents == null ? this.classroomStudents : classroomStudents(),
          notifications: notifications == null ? this.notifications : notifications(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateInput {
  Input$UserUncheckedUpdateInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() => _$Input$UserUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyInput {
  Input$UserUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateManyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyWithoutProvinceInput {
  Input$UserUncheckedUpdateManyWithoutProvinceInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$UserUncheckedUpdateManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyWithoutProvinceInputFromJson(json);

  final List<Input$UserCreateWithoutProvinceInput?>? create;

  final List<Input$UserCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final List<Input$UserUpsertWithWhereUniqueWithoutProvinceInput?>? upsert;

  final Input$UserCreateManyProvinceInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$UserWhereUniqueInput?>? $set;

  final List<Input$UserWhereUniqueInput?>? disconnect;

  final List<Input$UserWhereUniqueInput?>? delete;

  final List<Input$UserWhereUniqueInput?>? connect;

  final List<Input$UserUpdateWithWhereUniqueWithoutProvinceInput?>? update;

  final List<Input$UserUpdateManyWithWhereWithoutProvinceInput?>? updateMany;

  final List<Input$UserScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$UserUncheckedUpdateManyWithoutProvinceInput copyWith(
          {List<Input$UserCreateWithoutProvinceInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          List<Input$UserUpsertWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              upsert,
          Input$UserCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? $set,
          List<Input$UserWhereUniqueInput?>? Function()? disconnect,
          List<Input$UserWhereUniqueInput?>? Function()? delete,
          List<Input$UserWhereUniqueInput?>? Function()? connect,
          List<Input$UserUpdateWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              update,
          List<Input$UserUpdateManyWithWhereWithoutProvinceInput?>? Function()?
              updateMany,
          List<Input$UserScalarWhereInput?>? Function()? deleteMany}) =>
      Input$UserUncheckedUpdateManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyWithoutRegencyInput {
  Input$UserUncheckedUpdateManyWithoutRegencyInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$UserUncheckedUpdateManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyWithoutRegencyInputFromJson(json);

  final List<Input$UserCreateWithoutRegencyInput?>? create;

  final List<Input$UserCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final List<Input$UserUpsertWithWhereUniqueWithoutRegencyInput?>? upsert;

  final Input$UserCreateManyRegencyInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$UserWhereUniqueInput?>? $set;

  final List<Input$UserWhereUniqueInput?>? disconnect;

  final List<Input$UserWhereUniqueInput?>? delete;

  final List<Input$UserWhereUniqueInput?>? connect;

  final List<Input$UserUpdateWithWhereUniqueWithoutRegencyInput?>? update;

  final List<Input$UserUpdateManyWithWhereWithoutRegencyInput?>? updateMany;

  final List<Input$UserScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$UserUncheckedUpdateManyWithoutRegencyInput copyWith(
          {List<Input$UserCreateWithoutRegencyInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          List<Input$UserUpsertWithWhereUniqueWithoutRegencyInput?>? Function()?
              upsert,
          Input$UserCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? $set,
          List<Input$UserWhereUniqueInput?>? Function()? disconnect,
          List<Input$UserWhereUniqueInput?>? Function()? delete,
          List<Input$UserWhereUniqueInput?>? Function()? connect,
          List<Input$UserUpdateWithWhereUniqueWithoutRegencyInput?>? Function()?
              update,
          List<Input$UserUpdateManyWithWhereWithoutRegencyInput?>? Function()?
              updateMany,
          List<Input$UserScalarWhereInput?>? Function()? deleteMany}) =>
      Input$UserUncheckedUpdateManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyWithoutSchoolInput {
  Input$UserUncheckedUpdateManyWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$UserUncheckedUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyWithoutSchoolInputFromJson(json);

  final List<Input$UserCreateWithoutSchoolInput?>? create;

  final List<Input$UserCreateOrConnectWithoutSchoolInput?>? connectOrCreate;

  final List<Input$UserUpsertWithWhereUniqueWithoutSchoolInput?>? upsert;

  final Input$UserCreateManySchoolInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$UserWhereUniqueInput?>? $set;

  final List<Input$UserWhereUniqueInput?>? disconnect;

  final List<Input$UserWhereUniqueInput?>? delete;

  final List<Input$UserWhereUniqueInput?>? connect;

  final List<Input$UserUpdateWithWhereUniqueWithoutSchoolInput?>? update;

  final List<Input$UserUpdateManyWithWhereWithoutSchoolInput?>? updateMany;

  final List<Input$UserScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$UserUncheckedUpdateManyWithoutSchoolInput copyWith(
          {List<Input$UserCreateWithoutSchoolInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          List<Input$UserUpsertWithWhereUniqueWithoutSchoolInput?>? Function()?
              upsert,
          Input$UserCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? $set,
          List<Input$UserWhereUniqueInput?>? Function()? disconnect,
          List<Input$UserWhereUniqueInput?>? Function()? delete,
          List<Input$UserWhereUniqueInput?>? Function()? connect,
          List<Input$UserUpdateWithWhereUniqueWithoutSchoolInput?>? Function()?
              update,
          List<Input$UserUpdateManyWithWhereWithoutSchoolInput?>? Function()?
              updateMany,
          List<Input$UserScalarWhereInput?>? Function()? deleteMany}) =>
      Input$UserUncheckedUpdateManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyWithoutStudentsInput {
  Input$UserUncheckedUpdateManyWithoutStudentsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt});

  @override
  factory Input$UserUncheckedUpdateManyWithoutStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyWithoutStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyWithoutStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyWithoutStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    return true;
  }

  Input$UserUncheckedUpdateManyWithoutStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt}) =>
      Input$UserUncheckedUpdateManyWithoutStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyWithoutUsersInput {
  Input$UserUncheckedUpdateManyWithoutUsersInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateManyWithoutUsersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyWithoutUsersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyWithoutUsersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyWithoutUsersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateManyWithoutUsersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateManyWithoutUsersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutClassroomsInput {
  Input$UserUncheckedUpdateWithoutClassroomsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutClassroomsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutClassroomsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutClassroomStudentsInput {
  Input$UserUncheckedUpdateWithoutClassroomStudentsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutClassroomStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutClassroomStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutClassroomStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutExaminationsInput {
  Input$UserUncheckedUpdateWithoutExaminationsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutExaminationsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutExaminationsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutExaminationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutExamsessionsInput {
  Input$UserUncheckedUpdateWithoutExamsessionsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutExamsessionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutExamsessionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutExamsessionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutIdentityFilesInput {
  Input$UserUncheckedUpdateWithoutIdentityFilesInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutIdentityFilesInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutIdentityFilesInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutIdentityFilesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutMyChatsInput {
  Input$UserUncheckedUpdateWithoutMyChatsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutMyChatsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutMyChatsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutMyChatsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutNotificationsInput {
  Input$UserUncheckedUpdateWithoutNotificationsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutNotificationsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutNotificationsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutNotificationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutProvinceInput {
  Input$UserUncheckedUpdateWithoutProvinceInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutProvinceInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutProvinceInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutQuestionsInput {
  Input$UserUncheckedUpdateWithoutQuestionsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutQuestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutQuestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutQuestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutRegencyInput {
  Input$UserUncheckedUpdateWithoutRegencyInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutRegencyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutRegencyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutSchoolInput {
  Input$UserUncheckedUpdateWithoutSchoolInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs});

  @override
  factory Input$UserUncheckedUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUncheckedUpdateManyWithoutUserInput? Function()?
              schoolStaffs}) =>
      Input$UserUncheckedUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutSchoolStaffsInput {
  Input$UserUncheckedUpdateWithoutSchoolStaffsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.regencyId,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolId});

  @override
  factory Input$UserUncheckedUpdateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutSchoolStaffsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$StringFieldUpdateOperationsInput? provinceId;

  final Input$StringFieldUpdateOperationsInput? regencyId;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUncheckedUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUncheckedUpdateManyWithoutUserInput? questions;

  final Input$ExamUncheckedUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUncheckedUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUncheckedUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUncheckedUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput?
      classroomStudents;

  final Input$NotificationUncheckedUpdateManyWithoutUserInput? notifications;

  final Input$NullableStringFieldUpdateOperationsInput? schoolId;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$regencyId = regencyId;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolId = schoolId;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$regencyId,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutSchoolStaffsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$StringFieldUpdateOperationsInput? Function()? provinceId,
          Input$StringFieldUpdateOperationsInput? Function()? regencyId,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUncheckedUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUncheckedUpdateManyWithoutUserInput? Function()?
              questions,
          Input$ExamUncheckedUpdateManyWithoutUserInput? Function()?
              examinations,
          Input$ExamSessionUncheckedUpdateManyWithoutUserInput? Function()?
              examsessions,
          Input$ChatUncheckedUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUncheckedUpdateManyWithoutUserInput? Function()?
              classrooms,
          Input$ClassroomStudentUncheckedUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUncheckedUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              schoolId}) =>
      Input$UserUncheckedUpdateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolId: schoolId == null ? this.schoolId : schoolId());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateInput {
  Input$UserUpdateInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() => _$Input$UserUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyMutationInput {
  Input$UserUpdateManyMutationInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt});

  @override
  factory Input$UserUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    return true;
  }

  Input$UserUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt}) =>
      Input$UserUpdateManyMutationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyWithoutProvinceInput {
  Input$UserUpdateManyWithoutProvinceInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$UserUpdateManyWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyWithoutProvinceInputFromJson(json);

  final List<Input$UserCreateWithoutProvinceInput?>? create;

  final List<Input$UserCreateOrConnectWithoutProvinceInput?>? connectOrCreate;

  final List<Input$UserUpsertWithWhereUniqueWithoutProvinceInput?>? upsert;

  final Input$UserCreateManyProvinceInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$UserWhereUniqueInput?>? $set;

  final List<Input$UserWhereUniqueInput?>? disconnect;

  final List<Input$UserWhereUniqueInput?>? delete;

  final List<Input$UserWhereUniqueInput?>? connect;

  final List<Input$UserUpdateWithWhereUniqueWithoutProvinceInput?>? update;

  final List<Input$UserUpdateManyWithWhereWithoutProvinceInput?>? updateMany;

  final List<Input$UserScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$UserUpdateManyWithoutProvinceInput copyWith(
          {List<Input$UserCreateWithoutProvinceInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutProvinceInput?>? Function()?
              connectOrCreate,
          List<Input$UserUpsertWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              upsert,
          Input$UserCreateManyProvinceInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? $set,
          List<Input$UserWhereUniqueInput?>? Function()? disconnect,
          List<Input$UserWhereUniqueInput?>? Function()? delete,
          List<Input$UserWhereUniqueInput?>? Function()? connect,
          List<Input$UserUpdateWithWhereUniqueWithoutProvinceInput?>?
                  Function()?
              update,
          List<Input$UserUpdateManyWithWhereWithoutProvinceInput?>? Function()?
              updateMany,
          List<Input$UserScalarWhereInput?>? Function()? deleteMany}) =>
      Input$UserUpdateManyWithoutProvinceInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyWithoutRegencyInput {
  Input$UserUpdateManyWithoutRegencyInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$UserUpdateManyWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyWithoutRegencyInputFromJson(json);

  final List<Input$UserCreateWithoutRegencyInput?>? create;

  final List<Input$UserCreateOrConnectWithoutRegencyInput?>? connectOrCreate;

  final List<Input$UserUpsertWithWhereUniqueWithoutRegencyInput?>? upsert;

  final Input$UserCreateManyRegencyInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$UserWhereUniqueInput?>? $set;

  final List<Input$UserWhereUniqueInput?>? disconnect;

  final List<Input$UserWhereUniqueInput?>? delete;

  final List<Input$UserWhereUniqueInput?>? connect;

  final List<Input$UserUpdateWithWhereUniqueWithoutRegencyInput?>? update;

  final List<Input$UserUpdateManyWithWhereWithoutRegencyInput?>? updateMany;

  final List<Input$UserScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$UserUpdateManyWithoutRegencyInput copyWith(
          {List<Input$UserCreateWithoutRegencyInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutRegencyInput?>? Function()?
              connectOrCreate,
          List<Input$UserUpsertWithWhereUniqueWithoutRegencyInput?>? Function()?
              upsert,
          Input$UserCreateManyRegencyInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? $set,
          List<Input$UserWhereUniqueInput?>? Function()? disconnect,
          List<Input$UserWhereUniqueInput?>? Function()? delete,
          List<Input$UserWhereUniqueInput?>? Function()? connect,
          List<Input$UserUpdateWithWhereUniqueWithoutRegencyInput?>? Function()?
              update,
          List<Input$UserUpdateManyWithWhereWithoutRegencyInput?>? Function()?
              updateMany,
          List<Input$UserScalarWhereInput?>? Function()? deleteMany}) =>
      Input$UserUpdateManyWithoutRegencyInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyWithoutSchoolInput {
  Input$UserUpdateManyWithoutSchoolInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$UserUpdateManyWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyWithoutSchoolInputFromJson(json);

  final List<Input$UserCreateWithoutSchoolInput?>? create;

  final List<Input$UserCreateOrConnectWithoutSchoolInput?>? connectOrCreate;

  final List<Input$UserUpsertWithWhereUniqueWithoutSchoolInput?>? upsert;

  final Input$UserCreateManySchoolInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$UserWhereUniqueInput?>? $set;

  final List<Input$UserWhereUniqueInput?>? disconnect;

  final List<Input$UserWhereUniqueInput?>? delete;

  final List<Input$UserWhereUniqueInput?>? connect;

  final List<Input$UserUpdateWithWhereUniqueWithoutSchoolInput?>? update;

  final List<Input$UserUpdateManyWithWhereWithoutSchoolInput?>? updateMany;

  final List<Input$UserScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$UserUpdateManyWithoutSchoolInput copyWith(
          {List<Input$UserCreateWithoutSchoolInput?>? Function()? create,
          List<Input$UserCreateOrConnectWithoutSchoolInput?>? Function()?
              connectOrCreate,
          List<Input$UserUpsertWithWhereUniqueWithoutSchoolInput?>? Function()?
              upsert,
          Input$UserCreateManySchoolInputEnvelope? Function()? createMany,
          List<Input$UserWhereUniqueInput?>? Function()? $set,
          List<Input$UserWhereUniqueInput?>? Function()? disconnect,
          List<Input$UserWhereUniqueInput?>? Function()? delete,
          List<Input$UserWhereUniqueInput?>? Function()? connect,
          List<Input$UserUpdateWithWhereUniqueWithoutSchoolInput?>? Function()?
              update,
          List<Input$UserUpdateManyWithWhereWithoutSchoolInput?>? Function()?
              updateMany,
          List<Input$UserScalarWhereInput?>? Function()? deleteMany}) =>
      Input$UserUpdateManyWithoutSchoolInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyWithWhereWithoutProvinceInput {
  Input$UserUpdateManyWithWhereWithoutProvinceInput(
      {required this.where, required this.data});

  @override
  factory Input$UserUpdateManyWithWhereWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyWithWhereWithoutProvinceInputFromJson(json);

  final Input$UserScalarWhereInput where;

  final Input$UserUncheckedUpdateManyWithoutUsersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyWithWhereWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyWithWhereWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$UserUpdateManyWithWhereWithoutProvinceInput copyWith(
          {Input$UserScalarWhereInput? where,
          Input$UserUncheckedUpdateManyWithoutUsersInput? data}) =>
      Input$UserUpdateManyWithWhereWithoutProvinceInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyWithWhereWithoutRegencyInput {
  Input$UserUpdateManyWithWhereWithoutRegencyInput(
      {required this.where, required this.data});

  @override
  factory Input$UserUpdateManyWithWhereWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyWithWhereWithoutRegencyInputFromJson(json);

  final Input$UserScalarWhereInput where;

  final Input$UserUncheckedUpdateManyWithoutUsersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyWithWhereWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyWithWhereWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$UserUpdateManyWithWhereWithoutRegencyInput copyWith(
          {Input$UserScalarWhereInput? where,
          Input$UserUncheckedUpdateManyWithoutUsersInput? data}) =>
      Input$UserUpdateManyWithWhereWithoutRegencyInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyWithWhereWithoutSchoolInput {
  Input$UserUpdateManyWithWhereWithoutSchoolInput(
      {required this.where, required this.data});

  @override
  factory Input$UserUpdateManyWithWhereWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyWithWhereWithoutSchoolInputFromJson(json);

  final Input$UserScalarWhereInput where;

  final Input$UserUncheckedUpdateManyWithoutStudentsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyWithWhereWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyWithWhereWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$UserUpdateManyWithWhereWithoutSchoolInput copyWith(
          {Input$UserScalarWhereInput? where,
          Input$UserUncheckedUpdateManyWithoutStudentsInput? data}) =>
      Input$UserUpdateManyWithWhereWithoutSchoolInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutClassroomsInput {
  Input$UserUpdateOneRequiredWithoutClassroomsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutClassroomsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutClassroomsInput? create;

  final Input$UserCreateOrConnectWithoutClassroomsInput? connectOrCreate;

  final Input$UserUpsertWithoutClassroomsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutClassroomsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutClassroomsInput copyWith(
          {Input$UserUncheckedCreateWithoutClassroomsInput? Function()? create,
          Input$UserCreateOrConnectWithoutClassroomsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutClassroomsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutClassroomsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutClassroomsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutClassroomStudentsInput {
  Input$UserUpdateOneRequiredWithoutClassroomStudentsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutClassroomStudentsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutClassroomStudentsInput? create;

  final Input$UserCreateOrConnectWithoutClassroomStudentsInput? connectOrCreate;

  final Input$UserUpsertWithoutClassroomStudentsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutClassroomStudentsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutClassroomStudentsInput copyWith(
          {Input$UserUncheckedCreateWithoutClassroomStudentsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutClassroomStudentsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutClassroomStudentsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutClassroomStudentsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutClassroomStudentsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutExaminationsInput {
  Input$UserUpdateOneRequiredWithoutExaminationsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutExaminationsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutExaminationsInput? create;

  final Input$UserCreateOrConnectWithoutExaminationsInput? connectOrCreate;

  final Input$UserUpsertWithoutExaminationsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutExaminationsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutExaminationsInput copyWith(
          {Input$UserUncheckedCreateWithoutExaminationsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutExaminationsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutExaminationsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutExaminationsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutExaminationsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutExamsessionsInput {
  Input$UserUpdateOneRequiredWithoutExamsessionsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutExamsessionsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutExamsessionsInput? create;

  final Input$UserCreateOrConnectWithoutExamsessionsInput? connectOrCreate;

  final Input$UserUpsertWithoutExamsessionsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutExamsessionsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutExamsessionsInput copyWith(
          {Input$UserUncheckedCreateWithoutExamsessionsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutExamsessionsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutExamsessionsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutExamsessionsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutExamsessionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutIdentityFilesInput {
  Input$UserUpdateOneRequiredWithoutIdentityFilesInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutIdentityFilesInputFromJson(json);

  final Input$UserUncheckedCreateWithoutIdentityFilesInput? create;

  final Input$UserCreateOrConnectWithoutIdentityFilesInput? connectOrCreate;

  final Input$UserUpsertWithoutIdentityFilesInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutIdentityFilesInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutIdentityFilesInput copyWith(
          {Input$UserUncheckedCreateWithoutIdentityFilesInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutIdentityFilesInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutIdentityFilesInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutIdentityFilesInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutIdentityFilesInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutMyChatsInput {
  Input$UserUpdateOneRequiredWithoutMyChatsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutMyChatsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutMyChatsInput? create;

  final Input$UserCreateOrConnectWithoutMyChatsInput? connectOrCreate;

  final Input$UserUpsertWithoutMyChatsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutMyChatsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutMyChatsInput copyWith(
          {Input$UserUncheckedCreateWithoutMyChatsInput? Function()? create,
          Input$UserCreateOrConnectWithoutMyChatsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutMyChatsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutMyChatsInput? Function()? update}) =>
      Input$UserUpdateOneRequiredWithoutMyChatsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutNotificationsInput {
  Input$UserUpdateOneRequiredWithoutNotificationsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutNotificationsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutNotificationsInput? create;

  final Input$UserCreateOrConnectWithoutNotificationsInput? connectOrCreate;

  final Input$UserUpsertWithoutNotificationsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutNotificationsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutNotificationsInput copyWith(
          {Input$UserUncheckedCreateWithoutNotificationsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutNotificationsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutNotificationsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutNotificationsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutNotificationsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutQuestionsInput {
  Input$UserUpdateOneRequiredWithoutQuestionsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutQuestionsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutQuestionsInput? create;

  final Input$UserCreateOrConnectWithoutQuestionsInput? connectOrCreate;

  final Input$UserUpsertWithoutQuestionsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutQuestionsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutQuestionsInput copyWith(
          {Input$UserUncheckedCreateWithoutQuestionsInput? Function()? create,
          Input$UserCreateOrConnectWithoutQuestionsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutQuestionsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutQuestionsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutQuestionsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutSchoolStaffsInput {
  Input$UserUpdateOneRequiredWithoutSchoolStaffsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutSchoolStaffsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutSchoolStaffsInput? create;

  final Input$UserCreateOrConnectWithoutSchoolStaffsInput? connectOrCreate;

  final Input$UserUpsertWithoutSchoolStaffsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutSchoolStaffsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutSchoolStaffsInput copyWith(
          {Input$UserUncheckedCreateWithoutSchoolStaffsInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutSchoolStaffsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutSchoolStaffsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutSchoolStaffsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutSchoolStaffsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutClassroomsInput {
  Input$UserUpdateWithoutClassroomsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutClassroomsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutClassroomsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutClassroomsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutClassroomStudentsInput {
  Input$UserUpdateWithoutClassroomStudentsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutClassroomStudentsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutClassroomStudentsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutClassroomStudentsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutExaminationsInput {
  Input$UserUpdateWithoutExaminationsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutExaminationsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutExaminationsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutExaminationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutExamsessionsInput {
  Input$UserUpdateWithoutExamsessionsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutExamsessionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutExamsessionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutExamsessionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutIdentityFilesInput {
  Input$UserUpdateWithoutIdentityFilesInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutIdentityFilesInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutIdentityFilesInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutIdentityFilesInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutMyChatsInput {
  Input$UserUpdateWithoutMyChatsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutMyChatsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutMyChatsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutMyChatsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutNotificationsInput {
  Input$UserUpdateWithoutNotificationsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutNotificationsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutNotificationsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutNotificationsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutProvinceInput {
  Input$UserUpdateWithoutProvinceInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutProvinceInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutProvinceInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutProvinceInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutQuestionsInput {
  Input$UserUpdateWithoutQuestionsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutQuestionsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutQuestionsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutQuestionsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutRegencyInput {
  Input$UserUpdateWithoutRegencyInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.school});

  @override
  factory Input$UserUpdateWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutRegencyInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutRegencyInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()? schoolStaffs,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutRegencyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutSchoolInput {
  Input$UserUpdateWithoutSchoolInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs});

  @override
  factory Input$UserUpdateWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutSchoolInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolStaffUpdateManyWithoutUserInput? schoolStaffs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    return true;
  }

  Input$UserUpdateWithoutSchoolInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolStaffUpdateManyWithoutUserInput? Function()?
              schoolStaffs}) =>
      Input$UserUpdateWithoutSchoolInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutSchoolStaffsInput {
  Input$UserUpdateWithoutSchoolStaffsInput(
      {this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.province,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.school});

  @override
  factory Input$UserUpdateWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutSchoolStaffsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$StringFieldUpdateOperationsInput? phoneNumber;

  final Input$NullableStringFieldUpdateOperationsInput? address;

  final Input$NullableStringFieldUpdateOperationsInput? profilePicturePath;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$NullableStringFieldUpdateOperationsInput? nisn;

  final Input$NullableStringFieldUpdateOperationsInput? nrg;

  final Input$NullableStringFieldUpdateOperationsInput? verifykey;

  final Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? verifyType;

  final Input$ProvinceUpdateOneRequiredWithoutUsersInput? province;

  final Input$RegencyUpdateOneRequiredWithoutUsersInput? regency;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? isBimbel;

  final Input$EnumRolesFieldUpdateOperationsInput? role;

  final Input$FloatFieldUpdateOperationsInput? balance;

  final Input$NullableDateTimeFieldUpdateOperationsInput? emailVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? phoneNumberVerifiedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput? bimbelApprovedAt;

  final Input$NullableDateTimeFieldUpdateOperationsInput?
      identityNumberVerifiedAt;

  final Input$IdentityFileUpdateManyWithoutUserInput? identityFiles;

  final Input$QuestionUpdateManyWithoutUserInput? questions;

  final Input$ExamUpdateManyWithoutUserInput? examinations;

  final Input$ExamSessionUpdateManyWithoutUserInput? examsessions;

  final Input$ChatUpdateManyWithoutFromInput? myChats;

  final Input$ClassroomUpdateManyWithoutUserInput? classrooms;

  final Input$ClassroomStudentUpdateManyWithoutUserInput? classroomStudents;

  final Input$NotificationUpdateManyWithoutUserInput? notifications;

  final Input$SchoolUpdateOneWithoutStudentsInput? school;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$province = province;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$school = school;
    return Object.hashAll([
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$province,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserUpdateWithoutSchoolStaffsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$StringFieldUpdateOperationsInput? Function()? phoneNumber,
          Input$NullableStringFieldUpdateOperationsInput? Function()? address,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              profilePicturePath,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nisn,
          Input$NullableStringFieldUpdateOperationsInput? Function()? nrg,
          Input$NullableStringFieldUpdateOperationsInput? Function()? verifykey,
          Input$NullableEnumVerifyTypeFieldUpdateOperationsInput? Function()?
              verifyType,
          Input$ProvinceUpdateOneRequiredWithoutUsersInput? Function()?
              province,
          Input$RegencyUpdateOneRequiredWithoutUsersInput? Function()? regency,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? isBimbel,
          Input$EnumRolesFieldUpdateOperationsInput? Function()? role,
          Input$FloatFieldUpdateOperationsInput? Function()? balance,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              emailVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              phoneNumberVerifiedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              bimbelApprovedAt,
          Input$NullableDateTimeFieldUpdateOperationsInput? Function()?
              identityNumberVerifiedAt,
          Input$IdentityFileUpdateManyWithoutUserInput? Function()?
              identityFiles,
          Input$QuestionUpdateManyWithoutUserInput? Function()? questions,
          Input$ExamUpdateManyWithoutUserInput? Function()? examinations,
          Input$ExamSessionUpdateManyWithoutUserInput? Function()? examsessions,
          Input$ChatUpdateManyWithoutFromInput? Function()? myChats,
          Input$ClassroomUpdateManyWithoutUserInput? Function()? classrooms,
          Input$ClassroomStudentUpdateManyWithoutUserInput? Function()?
              classroomStudents,
          Input$NotificationUpdateManyWithoutUserInput? Function()?
              notifications,
          Input$SchoolUpdateOneWithoutStudentsInput? Function()? school}) =>
      Input$UserUpdateWithoutSchoolStaffsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          province: province == null ? this.province : province(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithWhereUniqueWithoutProvinceInput {
  Input$UserUpdateWithWhereUniqueWithoutProvinceInput(
      {required this.where, required this.data});

  @override
  factory Input$UserUpdateWithWhereUniqueWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithWhereUniqueWithoutProvinceInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedUpdateWithoutProvinceInput data;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithWhereUniqueWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithWhereUniqueWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$UserUpdateWithWhereUniqueWithoutProvinceInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedUpdateWithoutProvinceInput? data}) =>
      Input$UserUpdateWithWhereUniqueWithoutProvinceInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithWhereUniqueWithoutRegencyInput {
  Input$UserUpdateWithWhereUniqueWithoutRegencyInput(
      {required this.where, required this.data});

  @override
  factory Input$UserUpdateWithWhereUniqueWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithWhereUniqueWithoutRegencyInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedUpdateWithoutRegencyInput data;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithWhereUniqueWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithWhereUniqueWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$UserUpdateWithWhereUniqueWithoutRegencyInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedUpdateWithoutRegencyInput? data}) =>
      Input$UserUpdateWithWhereUniqueWithoutRegencyInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithWhereUniqueWithoutSchoolInput {
  Input$UserUpdateWithWhereUniqueWithoutSchoolInput(
      {required this.where, required this.data});

  @override
  factory Input$UserUpdateWithWhereUniqueWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithWhereUniqueWithoutSchoolInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedUpdateWithoutSchoolInput data;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithWhereUniqueWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithWhereUniqueWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$UserUpdateWithWhereUniqueWithoutSchoolInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedUpdateWithoutSchoolInput? data}) =>
      Input$UserUpdateWithWhereUniqueWithoutSchoolInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutClassroomsInput {
  Input$UserUpsertWithoutClassroomsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutClassroomsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutClassroomsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutClassroomsInput update;

  final Input$UserUncheckedCreateWithoutClassroomsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutClassroomsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutClassroomsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutClassroomsInput copyWith(
          {Input$UserUncheckedUpdateWithoutClassroomsInput? update,
          Input$UserUncheckedCreateWithoutClassroomsInput? create}) =>
      Input$UserUpsertWithoutClassroomsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutClassroomStudentsInput {
  Input$UserUpsertWithoutClassroomStudentsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutClassroomStudentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutClassroomStudentsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutClassroomStudentsInput update;

  final Input$UserUncheckedCreateWithoutClassroomStudentsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutClassroomStudentsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutClassroomStudentsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutClassroomStudentsInput copyWith(
          {Input$UserUncheckedUpdateWithoutClassroomStudentsInput? update,
          Input$UserUncheckedCreateWithoutClassroomStudentsInput? create}) =>
      Input$UserUpsertWithoutClassroomStudentsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutExaminationsInput {
  Input$UserUpsertWithoutExaminationsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutExaminationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutExaminationsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutExaminationsInput update;

  final Input$UserUncheckedCreateWithoutExaminationsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutExaminationsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutExaminationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutExaminationsInput copyWith(
          {Input$UserUncheckedUpdateWithoutExaminationsInput? update,
          Input$UserUncheckedCreateWithoutExaminationsInput? create}) =>
      Input$UserUpsertWithoutExaminationsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutExamsessionsInput {
  Input$UserUpsertWithoutExamsessionsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutExamsessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutExamsessionsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutExamsessionsInput update;

  final Input$UserUncheckedCreateWithoutExamsessionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutExamsessionsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutExamsessionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutExamsessionsInput copyWith(
          {Input$UserUncheckedUpdateWithoutExamsessionsInput? update,
          Input$UserUncheckedCreateWithoutExamsessionsInput? create}) =>
      Input$UserUpsertWithoutExamsessionsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutIdentityFilesInput {
  Input$UserUpsertWithoutIdentityFilesInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutIdentityFilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutIdentityFilesInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutIdentityFilesInput update;

  final Input$UserUncheckedCreateWithoutIdentityFilesInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutIdentityFilesInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutIdentityFilesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutIdentityFilesInput copyWith(
          {Input$UserUncheckedUpdateWithoutIdentityFilesInput? update,
          Input$UserUncheckedCreateWithoutIdentityFilesInput? create}) =>
      Input$UserUpsertWithoutIdentityFilesInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutMyChatsInput {
  Input$UserUpsertWithoutMyChatsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutMyChatsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutMyChatsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutMyChatsInput update;

  final Input$UserUncheckedCreateWithoutMyChatsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutMyChatsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutMyChatsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutMyChatsInput copyWith(
          {Input$UserUncheckedUpdateWithoutMyChatsInput? update,
          Input$UserUncheckedCreateWithoutMyChatsInput? create}) =>
      Input$UserUpsertWithoutMyChatsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutNotificationsInput {
  Input$UserUpsertWithoutNotificationsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutNotificationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutNotificationsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutNotificationsInput update;

  final Input$UserUncheckedCreateWithoutNotificationsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutNotificationsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutNotificationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutNotificationsInput copyWith(
          {Input$UserUncheckedUpdateWithoutNotificationsInput? update,
          Input$UserUncheckedCreateWithoutNotificationsInput? create}) =>
      Input$UserUpsertWithoutNotificationsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutQuestionsInput {
  Input$UserUpsertWithoutQuestionsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutQuestionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutQuestionsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutQuestionsInput update;

  final Input$UserUncheckedCreateWithoutQuestionsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutQuestionsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutQuestionsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutQuestionsInput copyWith(
          {Input$UserUncheckedUpdateWithoutQuestionsInput? update,
          Input$UserUncheckedCreateWithoutQuestionsInput? create}) =>
      Input$UserUpsertWithoutQuestionsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutSchoolStaffsInput {
  Input$UserUpsertWithoutSchoolStaffsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutSchoolStaffsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutSchoolStaffsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutSchoolStaffsInput update;

  final Input$UserUncheckedCreateWithoutSchoolStaffsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutSchoolStaffsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutSchoolStaffsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutSchoolStaffsInput copyWith(
          {Input$UserUncheckedUpdateWithoutSchoolStaffsInput? update,
          Input$UserUncheckedCreateWithoutSchoolStaffsInput? create}) =>
      Input$UserUpsertWithoutSchoolStaffsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithWhereUniqueWithoutProvinceInput {
  Input$UserUpsertWithWhereUniqueWithoutProvinceInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$UserUpsertWithWhereUniqueWithoutProvinceInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithWhereUniqueWithoutProvinceInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedUpdateWithoutProvinceInput update;

  final Input$UserUncheckedCreateWithoutProvinceInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithWhereUniqueWithoutProvinceInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithWhereUniqueWithoutProvinceInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithWhereUniqueWithoutProvinceInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedUpdateWithoutProvinceInput? update,
          Input$UserUncheckedCreateWithoutProvinceInput? create}) =>
      Input$UserUpsertWithWhereUniqueWithoutProvinceInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithWhereUniqueWithoutRegencyInput {
  Input$UserUpsertWithWhereUniqueWithoutRegencyInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$UserUpsertWithWhereUniqueWithoutRegencyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithWhereUniqueWithoutRegencyInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedUpdateWithoutRegencyInput update;

  final Input$UserUncheckedCreateWithoutRegencyInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithWhereUniqueWithoutRegencyInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithWhereUniqueWithoutRegencyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithWhereUniqueWithoutRegencyInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedUpdateWithoutRegencyInput? update,
          Input$UserUncheckedCreateWithoutRegencyInput? create}) =>
      Input$UserUpsertWithWhereUniqueWithoutRegencyInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithWhereUniqueWithoutSchoolInput {
  Input$UserUpsertWithWhereUniqueWithoutSchoolInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$UserUpsertWithWhereUniqueWithoutSchoolInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithWhereUniqueWithoutSchoolInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedUpdateWithoutSchoolInput update;

  final Input$UserUncheckedCreateWithoutSchoolInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithWhereUniqueWithoutSchoolInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithWhereUniqueWithoutSchoolInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithWhereUniqueWithoutSchoolInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedUpdateWithoutSchoolInput? update,
          Input$UserUncheckedCreateWithoutSchoolInput? create}) =>
      Input$UserUpsertWithWhereUniqueWithoutSchoolInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserWhereInput {
  Input$UserWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.email,
      this.phoneNumber,
      this.address,
      this.profilePicturePath,
      this.createdAt,
      this.updatedAt,
      this.nisn,
      this.nrg,
      this.verifykey,
      this.verifyType,
      this.provinceId,
      this.province,
      this.regencyId,
      this.regency,
      this.isAdmin,
      this.isBimbel,
      this.role,
      this.balance,
      this.emailVerifiedAt,
      this.phoneNumberVerifiedAt,
      this.bimbelApprovedAt,
      this.identityNumberVerifiedAt,
      this.identityFiles,
      this.questions,
      this.examinations,
      this.examsessions,
      this.myChats,
      this.classrooms,
      this.classroomStudents,
      this.notifications,
      this.schoolStaffs,
      this.schoolId,
      this.school});

  @override
  factory Input$UserWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserWhereInputFromJson(json);

  final List<Input$UserWhereInput?>? AND;

  final List<Input$UserWhereInput?>? OR;

  final List<Input$UserWhereInput?>? NOT;

  final Input$StringFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? email;

  final Input$StringFilter? phoneNumber;

  final Input$StringNullableFilter? address;

  final Input$StringNullableFilter? profilePicturePath;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$StringNullableFilter? nisn;

  final Input$StringNullableFilter? nrg;

  final Input$StringNullableFilter? verifykey;

  final Input$EnumVerifyTypeNullableFilter? verifyType;

  final Input$StringFilter? provinceId;

  final Input$ProvinceWhereInput? province;

  final Input$StringFilter? regencyId;

  final Input$RegencyWhereInput? regency;

  final Input$BoolFilter? isAdmin;

  final Input$BoolFilter? isBimbel;

  final Input$EnumRolesFilter? role;

  final Input$FloatFilter? balance;

  final Input$DateTimeNullableFilter? emailVerifiedAt;

  final Input$DateTimeNullableFilter? phoneNumberVerifiedAt;

  final Input$DateTimeNullableFilter? bimbelApprovedAt;

  final Input$DateTimeNullableFilter? identityNumberVerifiedAt;

  final Input$IdentityFileListRelationFilter? identityFiles;

  final Input$QuestionListRelationFilter? questions;

  final Input$ExamListRelationFilter? examinations;

  final Input$ExamSessionListRelationFilter? examsessions;

  final Input$ChatListRelationFilter? myChats;

  final Input$ClassroomListRelationFilter? classrooms;

  final Input$ClassroomStudentListRelationFilter? classroomStudents;

  final Input$NotificationListRelationFilter? notifications;

  final Input$SchoolStaffListRelationFilter? schoolStaffs;

  final Input$StringNullableFilter? schoolId;

  final Input$SchoolWhereInput? school;

  Map<String, dynamic> toJson() => _$Input$UserWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$address = address;
    final l$profilePicturePath = profilePicturePath;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$nisn = nisn;
    final l$nrg = nrg;
    final l$verifykey = verifykey;
    final l$verifyType = verifyType;
    final l$provinceId = provinceId;
    final l$province = province;
    final l$regencyId = regencyId;
    final l$regency = regency;
    final l$isAdmin = isAdmin;
    final l$isBimbel = isBimbel;
    final l$role = role;
    final l$balance = balance;
    final l$emailVerifiedAt = emailVerifiedAt;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final l$identityFiles = identityFiles;
    final l$questions = questions;
    final l$examinations = examinations;
    final l$examsessions = examsessions;
    final l$myChats = myChats;
    final l$classrooms = classrooms;
    final l$classroomStudents = classroomStudents;
    final l$notifications = notifications;
    final l$schoolStaffs = schoolStaffs;
    final l$schoolId = schoolId;
    final l$school = school;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$email,
      l$phoneNumber,
      l$address,
      l$profilePicturePath,
      l$createdAt,
      l$updatedAt,
      l$nisn,
      l$nrg,
      l$verifykey,
      l$verifyType,
      l$provinceId,
      l$province,
      l$regencyId,
      l$regency,
      l$isAdmin,
      l$isBimbel,
      l$role,
      l$balance,
      l$emailVerifiedAt,
      l$phoneNumberVerifiedAt,
      l$bimbelApprovedAt,
      l$identityNumberVerifiedAt,
      l$identityFiles,
      l$questions,
      l$examinations,
      l$examsessions,
      l$myChats,
      l$classrooms,
      l$classroomStudents,
      l$notifications,
      l$schoolStaffs,
      l$schoolId,
      l$school
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (l$phoneNumber != lOther$phoneNumber) return false;
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) return false;
    final l$profilePicturePath = profilePicturePath;
    final lOther$profilePicturePath = other.profilePicturePath;
    if (l$profilePicturePath != lOther$profilePicturePath) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$nisn = nisn;
    final lOther$nisn = other.nisn;
    if (l$nisn != lOther$nisn) return false;
    final l$nrg = nrg;
    final lOther$nrg = other.nrg;
    if (l$nrg != lOther$nrg) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    final l$verifyType = verifyType;
    final lOther$verifyType = other.verifyType;
    if (l$verifyType != lOther$verifyType) return false;
    final l$provinceId = provinceId;
    final lOther$provinceId = other.provinceId;
    if (l$provinceId != lOther$provinceId) return false;
    final l$province = province;
    final lOther$province = other.province;
    if (l$province != lOther$province) return false;
    final l$regencyId = regencyId;
    final lOther$regencyId = other.regencyId;
    if (l$regencyId != lOther$regencyId) return false;
    final l$regency = regency;
    final lOther$regency = other.regency;
    if (l$regency != lOther$regency) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$isBimbel = isBimbel;
    final lOther$isBimbel = other.isBimbel;
    if (l$isBimbel != lOther$isBimbel) return false;
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) return false;
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) return false;
    final l$emailVerifiedAt = emailVerifiedAt;
    final lOther$emailVerifiedAt = other.emailVerifiedAt;
    if (l$emailVerifiedAt != lOther$emailVerifiedAt) return false;
    final l$phoneNumberVerifiedAt = phoneNumberVerifiedAt;
    final lOther$phoneNumberVerifiedAt = other.phoneNumberVerifiedAt;
    if (l$phoneNumberVerifiedAt != lOther$phoneNumberVerifiedAt) return false;
    final l$bimbelApprovedAt = bimbelApprovedAt;
    final lOther$bimbelApprovedAt = other.bimbelApprovedAt;
    if (l$bimbelApprovedAt != lOther$bimbelApprovedAt) return false;
    final l$identityNumberVerifiedAt = identityNumberVerifiedAt;
    final lOther$identityNumberVerifiedAt = other.identityNumberVerifiedAt;
    if (l$identityNumberVerifiedAt != lOther$identityNumberVerifiedAt)
      return false;
    final l$identityFiles = identityFiles;
    final lOther$identityFiles = other.identityFiles;
    if (l$identityFiles != lOther$identityFiles) return false;
    final l$questions = questions;
    final lOther$questions = other.questions;
    if (l$questions != lOther$questions) return false;
    final l$examinations = examinations;
    final lOther$examinations = other.examinations;
    if (l$examinations != lOther$examinations) return false;
    final l$examsessions = examsessions;
    final lOther$examsessions = other.examsessions;
    if (l$examsessions != lOther$examsessions) return false;
    final l$myChats = myChats;
    final lOther$myChats = other.myChats;
    if (l$myChats != lOther$myChats) return false;
    final l$classrooms = classrooms;
    final lOther$classrooms = other.classrooms;
    if (l$classrooms != lOther$classrooms) return false;
    final l$classroomStudents = classroomStudents;
    final lOther$classroomStudents = other.classroomStudents;
    if (l$classroomStudents != lOther$classroomStudents) return false;
    final l$notifications = notifications;
    final lOther$notifications = other.notifications;
    if (l$notifications != lOther$notifications) return false;
    final l$schoolStaffs = schoolStaffs;
    final lOther$schoolStaffs = other.schoolStaffs;
    if (l$schoolStaffs != lOther$schoolStaffs) return false;
    final l$schoolId = schoolId;
    final lOther$schoolId = other.schoolId;
    if (l$schoolId != lOther$schoolId) return false;
    final l$school = school;
    final lOther$school = other.school;
    if (l$school != lOther$school) return false;
    return true;
  }

  Input$UserWhereInput copyWith(
          {List<Input$UserWhereInput?>? Function()? AND,
          List<Input$UserWhereInput?>? Function()? OR,
          List<Input$UserWhereInput?>? Function()? NOT,
          Input$StringFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? email,
          Input$StringFilter? Function()? phoneNumber,
          Input$StringNullableFilter? Function()? address,
          Input$StringNullableFilter? Function()? profilePicturePath,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$StringNullableFilter? Function()? nisn,
          Input$StringNullableFilter? Function()? nrg,
          Input$StringNullableFilter? Function()? verifykey,
          Input$EnumVerifyTypeNullableFilter? Function()? verifyType,
          Input$StringFilter? Function()? provinceId,
          Input$ProvinceWhereInput? Function()? province,
          Input$StringFilter? Function()? regencyId,
          Input$RegencyWhereInput? Function()? regency,
          Input$BoolFilter? Function()? isAdmin,
          Input$BoolFilter? Function()? isBimbel,
          Input$EnumRolesFilter? Function()? role,
          Input$FloatFilter? Function()? balance,
          Input$DateTimeNullableFilter? Function()? emailVerifiedAt,
          Input$DateTimeNullableFilter? Function()? phoneNumberVerifiedAt,
          Input$DateTimeNullableFilter? Function()? bimbelApprovedAt,
          Input$DateTimeNullableFilter? Function()? identityNumberVerifiedAt,
          Input$IdentityFileListRelationFilter? Function()? identityFiles,
          Input$QuestionListRelationFilter? Function()? questions,
          Input$ExamListRelationFilter? Function()? examinations,
          Input$ExamSessionListRelationFilter? Function()? examsessions,
          Input$ChatListRelationFilter? Function()? myChats,
          Input$ClassroomListRelationFilter? Function()? classrooms,
          Input$ClassroomStudentListRelationFilter? Function()?
              classroomStudents,
          Input$NotificationListRelationFilter? Function()? notifications,
          Input$SchoolStaffListRelationFilter? Function()? schoolStaffs,
          Input$StringNullableFilter? Function()? schoolId,
          Input$SchoolWhereInput? Function()? school}) =>
      Input$UserWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          email: email == null ? this.email : email(),
          phoneNumber: phoneNumber == null ? this.phoneNumber : phoneNumber(),
          address: address == null ? this.address : address(),
          profilePicturePath: profilePicturePath == null
              ? this.profilePicturePath
              : profilePicturePath(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          nisn: nisn == null ? this.nisn : nisn(),
          nrg: nrg == null ? this.nrg : nrg(),
          verifykey: verifykey == null ? this.verifykey : verifykey(),
          verifyType: verifyType == null ? this.verifyType : verifyType(),
          provinceId: provinceId == null ? this.provinceId : provinceId(),
          province: province == null ? this.province : province(),
          regencyId: regencyId == null ? this.regencyId : regencyId(),
          regency: regency == null ? this.regency : regency(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          isBimbel: isBimbel == null ? this.isBimbel : isBimbel(),
          role: role == null ? this.role : role(),
          balance: balance == null ? this.balance : balance(),
          emailVerifiedAt: emailVerifiedAt == null
              ? this.emailVerifiedAt
              : emailVerifiedAt(),
          phoneNumberVerifiedAt: phoneNumberVerifiedAt == null
              ? this.phoneNumberVerifiedAt
              : phoneNumberVerifiedAt(),
          bimbelApprovedAt: bimbelApprovedAt == null
              ? this.bimbelApprovedAt
              : bimbelApprovedAt(),
          identityNumberVerifiedAt: identityNumberVerifiedAt == null
              ? this.identityNumberVerifiedAt
              : identityNumberVerifiedAt(),
          identityFiles:
              identityFiles == null ? this.identityFiles : identityFiles(),
          questions: questions == null ? this.questions : questions(),
          examinations:
              examinations == null ? this.examinations : examinations(),
          examsessions:
              examsessions == null ? this.examsessions : examsessions(),
          myChats: myChats == null ? this.myChats : myChats(),
          classrooms: classrooms == null ? this.classrooms : classrooms(),
          classroomStudents: classroomStudents == null
              ? this.classroomStudents
              : classroomStudents(),
          notifications:
              notifications == null ? this.notifications : notifications(),
          schoolStaffs:
              schoolStaffs == null ? this.schoolStaffs : schoolStaffs(),
          schoolId: schoolId == null ? this.schoolId : schoolId(),
          school: school == null ? this.school : school());
}

@JsonSerializable(explicitToJson: true)
class Input$UserWhereUniqueInput {
  Input$UserWhereUniqueInput({this.id, this.verifykey});

  @override
  factory Input$UserWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserWhereUniqueInputFromJson(json);

  final String? id;

  final String? verifykey;

  Map<String, dynamic> toJson() => _$Input$UserWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$verifykey = verifykey;
    return Object.hashAll([l$id, l$verifykey]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$verifykey = verifykey;
    final lOther$verifykey = other.verifykey;
    if (l$verifykey != lOther$verifykey) return false;
    return true;
  }

  Input$UserWhereUniqueInput copyWith(
          {String? Function()? id, String? Function()? verifykey}) =>
      Input$UserWhereUniqueInput(
          id: id == null ? this.id : id(),
          verifykey: verifykey == null ? this.verifykey : verifykey());
}

enum Enum$ChatScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('fromId')
  fromId,
  @JsonValue('contentType')
  contentType,
  @JsonValue('content')
  content,
  @JsonValue('readAt')
  readAt,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  @JsonValue('chatSessionId')
  chatSessionId,
  $unknown
}

enum Enum$ChatSessionScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('participantsIds')
  participantsIds,
  @JsonValue('lastReadAt')
  lastReadAt,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ClassroomScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('schoolId')
  schoolId,
  @JsonValue('userId')
  userId,
  @JsonValue('level')
  level,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ClassroomStudentScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('userId')
  userId,
  @JsonValue('classroomId')
  classroomId,
  @JsonValue('status')
  status,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ClassroomStudentStatus {
  @JsonValue('ACTIVE')
  ACTIVE,
  @JsonValue('BANNED')
  BANNED,
  $unknown
}

enum Enum$ContentType {
  @JsonValue('TEXT')
  TEXT,
  @JsonValue('IMAGE')
  IMAGE,
  @JsonValue('VIDEO')
  VIDEO,
  @JsonValue('AUDIO')
  AUDIO,
  $unknown
}

enum Enum$ExamAnswerScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('examId')
  examId,
  @JsonValue('grade')
  grade,
  @JsonValue('finishCalculation')
  finishCalculation,
  @JsonValue('examSessionId')
  examSessionId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ExamQuestionScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('questionId')
  questionId,
  @JsonValue('examId')
  examId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ExamScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('userId')
  userId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ExamSessionScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('openAt')
  openAt,
  @JsonValue('closeAt')
  closeAt,
  @JsonValue('maxPlayer')
  maxPlayer,
  @JsonValue('password')
  password,
  @JsonValue('userId')
  userId,
  $unknown
}

enum Enum$IdentityFileScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('url')
  url,
  @JsonValue('type')
  type,
  @JsonValue('number')
  number,
  @JsonValue('userId')
  userId,
  $unknown
}

enum Enum$IdentityFileType {
  @JsonValue('KTP')
  KTP,
  @JsonValue('KK')
  KK,
  @JsonValue('SIM')
  SIM,
  @JsonValue('PASSPORT')
  PASSPORT,
  @JsonValue('OTHER')
  OTHER,
  $unknown
}

enum Enum$NotificationScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('picturePath')
  picturePath,
  @JsonValue('title')
  title,
  @JsonValue('message')
  message,
  @JsonValue('isRead')
  isRead,
  @JsonValue('followUpContext')
  followUpContext,
  @JsonValue('followUpData')
  followUpData,
  @JsonValue('userId')
  userId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ProvinceScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$QueryMode {
  @JsonValue('default')
  $default,
  @JsonValue('insensitive')
  insensitive,
  $unknown
}

enum Enum$QuestionScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('type')
  type,
  @JsonValue('contentType')
  contentType,
  @JsonValue('content')
  content,
  @JsonValue('answerType')
  answerType,
  @JsonValue('answers')
  answers,
  @JsonValue('userId')
  userId,
  @JsonValue('originalQuestionId')
  originalQuestionId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$QuestionType {
  @JsonValue('MULTIPLE_CHOICE')
  MULTIPLE_CHOICE,
  @JsonValue('TRUE_OR_FALSE')
  TRUE_OR_FALSE,
  @JsonValue('FILL_IN_THE_BLANK')
  FILL_IN_THE_BLANK,
  @JsonValue('MULTIPLE_ANSWER')
  MULTIPLE_ANSWER,
  $unknown
}

enum Enum$RegencyScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('provinceId')
  provinceId,
  $unknown
}

enum Enum$Roles {
  @JsonValue('STUDENT')
  STUDENT,
  @JsonValue('TEACHER')
  TEACHER,
  @JsonValue('PARENT')
  PARENT,
  $unknown
}

enum Enum$SchoolScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('npsn')
  npsn,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  @JsonValue('levels')
  levels,
  @JsonValue('type')
  type,
  @JsonValue('address')
  address,
  @JsonValue('logoPath')
  logoPath,
  @JsonValue('bannerPath')
  bannerPath,
  @JsonValue('provinceId')
  provinceId,
  @JsonValue('regencyId')
  regencyId,
  $unknown
}

enum Enum$SchoolStaffRoles {
  @JsonValue('TEACHER')
  TEACHER,
  @JsonValue('HEADMASTER')
  HEADMASTER,
  $unknown
}

enum Enum$SchoolStaffScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('schoolId')
  schoolId,
  @JsonValue('userId')
  userId,
  @JsonValue('roles')
  roles,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$SortOrder {
  @JsonValue('asc')
  asc,
  @JsonValue('desc')
  desc,
  $unknown
}

enum Enum$UserScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('email')
  email,
  @JsonValue('password')
  password,
  @JsonValue('phoneNumber')
  phoneNumber,
  @JsonValue('address')
  address,
  @JsonValue('profilePicturePath')
  profilePicturePath,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  @JsonValue('nisn')
  nisn,
  @JsonValue('nrg')
  nrg,
  @JsonValue('verifykey')
  verifykey,
  @JsonValue('verifyType')
  verifyType,
  @JsonValue('provinceId')
  provinceId,
  @JsonValue('regencyId')
  regencyId,
  @JsonValue('isAdmin')
  isAdmin,
  @JsonValue('isBimbel')
  isBimbel,
  @JsonValue('role')
  role,
  @JsonValue('balance')
  balance,
  @JsonValue('emailVerifiedAt')
  emailVerifiedAt,
  @JsonValue('phoneNumberVerifiedAt')
  phoneNumberVerifiedAt,
  @JsonValue('bimbelApprovedAt')
  bimbelApprovedAt,
  @JsonValue('identityNumberVerifiedAt')
  identityNumberVerifiedAt,
  @JsonValue('schoolId')
  schoolId,
  $unknown
}

enum Enum$VerifyType {
  @JsonValue('EMAIL')
  EMAIL,
  @JsonValue('PHONE')
  PHONE,
  @JsonValue('OTP')
  OTP,
  @JsonValue('IDENTITY')
  IDENTITY,
  $unknown
}

const possibleTypesMap = {};
