import 'package:json_annotation/json_annotation.dart';
part 'schema.graphql.g.dart';

@JsonSerializable(explicitToJson: true)
class Input$AdsAvgOrderByAggregateInput {
  Input$AdsAvgOrderByAggregateInput({this.id, this.index});

  @override
  factory Input$AdsAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  Map<String, dynamic> toJson() =>
      _$Input$AdsAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$index = index;
    return Object.hashAll([l$id, l$index]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    return true;
  }

  Input$AdsAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? index}) =>
      Input$AdsAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          index: index == null ? this.index : index());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsCountOrderByAggregateInput {
  Input$AdsCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? position;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? image;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$position,
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? position,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? image,
          Enum$SortOrder? Function()? index,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AdsCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsCreateInput {
  Input$AdsCreateInput(
      {required this.name,
      this.position,
      required this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsCreateInputFromJson(json);

  final String name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final String url;

  final String? image;

  final int? index;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AdsCreateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsCreateInput copyWith(
          {String? name,
          List<Enum$AdsPosition?>? Function()? position,
          String? url,
          String? Function()? image,
          int? Function()? index,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$AdsCreateInput(
          name: name == null ? this.name : name,
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url,
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsCreateManyInput {
  Input$AdsCreateManyInput(
      {this.id,
      required this.name,
      this.position,
      required this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsCreateManyInputFromJson(json);

  final int? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final String url;

  final String? image;

  final int? index;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AdsCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsCreateManyInput copyWith(
          {int? Function()? id,
          String? name,
          List<Enum$AdsPosition?>? Function()? position,
          String? url,
          String? Function()? image,
          int? Function()? index,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$AdsCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url,
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsCreatepositionInput {
  Input$AdsCreatepositionInput({required this.$set});

  @override
  factory Input$AdsCreatepositionInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsCreatepositionInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$AdsPosition.$unknown)
  final Enum$AdsPosition $set;

  Map<String, dynamic> toJson() => _$Input$AdsCreatepositionInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsCreatepositionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$AdsCreatepositionInput copyWith({Enum$AdsPosition? $set}) =>
      Input$AdsCreatepositionInput($set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$AdsMaxOrderByAggregateInput {
  Input$AdsMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? image;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$url, l$image, l$index, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? image,
          Enum$SortOrder? Function()? index,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AdsMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsMinOrderByAggregateInput {
  Input$AdsMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? image;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$name, l$url, l$image, l$index, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? image,
          Enum$SortOrder? Function()? index,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AdsMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsOrderByWithAggregationInput {
  Input$AdsOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$AdsOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? position;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? image;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$AdsCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$AdsAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$AdsMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$AdsMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$AdsSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$AdsOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$position,
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$AdsOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? position,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? image,
          Enum$SortOrder? Function()? index,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$AdsCountOrderByAggregateInput? Function()? $_count,
          Input$AdsAvgOrderByAggregateInput? Function()? $_avg,
          Input$AdsMaxOrderByAggregateInput? Function()? $_max,
          Input$AdsMinOrderByAggregateInput? Function()? $_min,
          Input$AdsSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$AdsOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsOrderByWithRelationInput {
  Input$AdsOrderByWithRelationInput(
      {this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? position;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? url;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? image;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$position,
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? position,
          Enum$SortOrder? Function()? url,
          Enum$SortOrder? Function()? image,
          Enum$SortOrder? Function()? index,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AdsOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsScalarWhereWithAggregatesInput {
  Input$AdsScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$AdsScalarWhereWithAggregatesInput?>? AND;

  final List<Input$AdsScalarWhereWithAggregatesInput?>? OR;

  final List<Input$AdsScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$EnumAdsPositionNullableListFilter? position;

  final Input$StringWithAggregatesFilter? url;

  final Input$StringNullableWithAggregatesFilter? image;

  final Input$IntWithAggregatesFilter? index;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$position,
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsScalarWhereWithAggregatesInput copyWith(
          {List<Input$AdsScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$AdsScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$AdsScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$EnumAdsPositionNullableListFilter? Function()? position,
          Input$StringWithAggregatesFilter? Function()? url,
          Input$StringNullableWithAggregatesFilter? Function()? image,
          Input$IntWithAggregatesFilter? Function()? index,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$AdsScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsSumOrderByAggregateInput {
  Input$AdsSumOrderByAggregateInput({this.id, this.index});

  @override
  factory Input$AdsSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? index;

  Map<String, dynamic> toJson() =>
      _$Input$AdsSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$index = index;
    return Object.hashAll([l$id, l$index]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    return true;
  }

  Input$AdsSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? index}) =>
      Input$AdsSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          index: index == null ? this.index : index());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsUncheckedCreateInput {
  Input$AdsUncheckedCreateInput(
      {this.id,
      required this.name,
      this.position,
      required this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsUncheckedCreateInputFromJson(json);

  final int? id;

  final String name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final String url;

  final String? image;

  final int? index;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AdsUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? name,
          List<Enum$AdsPosition?>? Function()? position,
          String? url,
          String? Function()? image,
          int? Function()? index,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$AdsUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url,
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsUncheckedUpdateInput {
  Input$AdsUncheckedUpdateInput(
      {this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$NullableStringFieldUpdateOperationsInput? image;

  final Input$IntFieldUpdateOperationsInput? index;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AdsUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          List<Enum$AdsPosition?>? Function()? position,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$NullableStringFieldUpdateOperationsInput? Function()? image,
          Input$IntFieldUpdateOperationsInput? Function()? index,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AdsUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsUncheckedUpdateManyInput {
  Input$AdsUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$NullableStringFieldUpdateOperationsInput? image;

  final Input$IntFieldUpdateOperationsInput? index;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          List<Enum$AdsPosition?>? Function()? position,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$NullableStringFieldUpdateOperationsInput? Function()? image,
          Input$IntFieldUpdateOperationsInput? Function()? index,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AdsUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsUpdateInput {
  Input$AdsUpdateInput(
      {this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$NullableStringFieldUpdateOperationsInput? image;

  final Input$IntFieldUpdateOperationsInput? index;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AdsUpdateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          List<Enum$AdsPosition?>? Function()? position,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$NullableStringFieldUpdateOperationsInput? Function()? image,
          Input$IntFieldUpdateOperationsInput? Function()? index,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AdsUpdateInput(
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsUpdateManyMutationInput {
  Input$AdsUpdateManyMutationInput(
      {this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AdsUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? position;

  final Input$StringFieldUpdateOperationsInput? url;

  final Input$NullableStringFieldUpdateOperationsInput? image;

  final Input$IntFieldUpdateOperationsInput? index;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AdsUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$position == null ? null : Object.hashAll(l$position.map((v) => v)),
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != null && lOther$position != null) {
      if (l$position.length != lOther$position.length) return false;
      for (int i = 0; i < l$position.length; i++) {
        final l$position$entry = l$position[i];
        final lOther$position$entry = lOther$position[i];
        if (l$position$entry != lOther$position$entry) return false;
      }
    } else if (l$position != lOther$position) {
      return false;
    }

    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          List<Enum$AdsPosition?>? Function()? position,
          Input$StringFieldUpdateOperationsInput? Function()? url,
          Input$NullableStringFieldUpdateOperationsInput? Function()? image,
          Input$IntFieldUpdateOperationsInput? Function()? index,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AdsUpdateManyMutationInput(
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsUpdatepositionInput {
  Input$AdsUpdatepositionInput({this.$set, this.push});

  @override
  factory Input$AdsUpdatepositionInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsUpdatepositionInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? $set;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? push;

  Map<String, dynamic> toJson() => _$Input$AdsUpdatepositionInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsUpdatepositionInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$AdsUpdatepositionInput copyWith(
          {List<Enum$AdsPosition?>? Function()? $set,
          List<Enum$AdsPosition?>? Function()? push}) =>
      Input$AdsUpdatepositionInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsWhereInput {
  Input$AdsWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.position,
      this.url,
      this.image,
      this.index,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AdsWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsWhereInputFromJson(json);

  final List<Input$AdsWhereInput?>? AND;

  final List<Input$AdsWhereInput?>? OR;

  final List<Input$AdsWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? name;

  final Input$EnumAdsPositionNullableListFilter? position;

  final Input$StringFilter? url;

  final Input$StringNullableFilter? image;

  final Input$IntFilter? index;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AdsWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$position = position;
    final l$url = url;
    final l$image = image;
    final l$index = index;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$position,
      l$url,
      l$image,
      l$index,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) return false;
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) return false;
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) return false;
    final l$index = index;
    final lOther$index = other.index;
    if (l$index != lOther$index) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AdsWhereInput copyWith(
          {List<Input$AdsWhereInput?>? Function()? AND,
          List<Input$AdsWhereInput?>? Function()? OR,
          List<Input$AdsWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$EnumAdsPositionNullableListFilter? Function()? position,
          Input$StringFilter? Function()? url,
          Input$StringNullableFilter? Function()? image,
          Input$IntFilter? Function()? index,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$AdsWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          position: position == null ? this.position : position(),
          url: url == null ? this.url : url(),
          image: image == null ? this.image : image(),
          index: index == null ? this.index : index(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AdsWhereUniqueInput {
  Input$AdsWhereUniqueInput({this.id, this.name});

  @override
  factory Input$AdsWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AdsWhereUniqueInputFromJson(json);

  final int? id;

  final String? name;

  Map<String, dynamic> toJson() => _$Input$AdsWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([l$id, l$name]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AdsWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    return true;
  }

  Input$AdsWhereUniqueInput copyWith(
          {int? Function()? id, String? Function()? name}) =>
      Input$AdsWhereUniqueInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorAvgOrderByAggregateInput {
  Input$AuthorAvgOrderByAggregateInput({this.id});

  @override
  factory Input$AuthorAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$AuthorAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$AuthorAvgOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorCountOrderByAggregateInput {
  Input$AuthorCountOrderByAggregateInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AuthorCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorCreateInput {
  Input$AuthorCreateInput(
      {required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$AuthorCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AuthorCreateInputFromJson(json);

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  final Input$ComicCreateNestedManyWithoutAuthorInput? comics;

  Map<String, dynamic> toJson() => _$Input$AuthorCreateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$AuthorCreateInput copyWith(
          {String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ComicCreateNestedManyWithoutAuthorInput? Function()? comics}) =>
      Input$AuthorCreateInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorCreateManyInput {
  Input$AuthorCreateManyInput(
      {this.id,
      required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AuthorCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AuthorCreateManyInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$AuthorCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorCreateManyInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$AuthorCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorCreateNestedOneWithoutComicsInput {
  Input$AuthorCreateNestedOneWithoutComicsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$AuthorCreateNestedOneWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorCreateNestedOneWithoutComicsInputFromJson(json);

  final Input$AuthorUncheckedCreateWithoutComicsInput? create;

  final Input$AuthorCreateOrConnectWithoutComicsInput? connectOrCreate;

  final Input$AuthorWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorCreateNestedOneWithoutComicsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorCreateNestedOneWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$AuthorCreateNestedOneWithoutComicsInput copyWith(
          {Input$AuthorUncheckedCreateWithoutComicsInput? Function()? create,
          Input$AuthorCreateOrConnectWithoutComicsInput? Function()?
              connectOrCreate,
          Input$AuthorWhereUniqueInput? Function()? connect}) =>
      Input$AuthorCreateNestedOneWithoutComicsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorCreateOrConnectWithoutComicsInput {
  Input$AuthorCreateOrConnectWithoutComicsInput(
      {required this.where, required this.create});

  @override
  factory Input$AuthorCreateOrConnectWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorCreateOrConnectWithoutComicsInputFromJson(json);

  final Input$AuthorWhereUniqueInput where;

  final Input$AuthorUncheckedCreateWithoutComicsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorCreateOrConnectWithoutComicsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorCreateOrConnectWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$AuthorCreateOrConnectWithoutComicsInput copyWith(
          {Input$AuthorWhereUniqueInput? where,
          Input$AuthorUncheckedCreateWithoutComicsInput? create}) =>
      Input$AuthorCreateOrConnectWithoutComicsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorCreateWithoutComicsInput {
  Input$AuthorCreateWithoutComicsInput(
      {required this.name, required this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorCreateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorCreateWithoutComicsInputFromJson(json);

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorCreateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorCreateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorCreateWithoutComicsInput copyWith(
          {String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$AuthorCreateWithoutComicsInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorMaxOrderByAggregateInput {
  Input$AuthorMaxOrderByAggregateInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AuthorMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorMinOrderByAggregateInput {
  Input$AuthorMinOrderByAggregateInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$AuthorMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorOrderByWithAggregationInput {
  Input$AuthorOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$AuthorOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$AuthorCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$AuthorAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$AuthorMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$AuthorMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$AuthorSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$AuthorOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$AuthorCountOrderByAggregateInput? Function()? $_count,
          Input$AuthorAvgOrderByAggregateInput? Function()? $_avg,
          Input$AuthorMaxOrderByAggregateInput? Function()? $_max,
          Input$AuthorMinOrderByAggregateInput? Function()? $_min,
          Input$AuthorSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$AuthorOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorOrderByWithRelationInput {
  Input$AuthorOrderByWithRelationInput(
      {this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$AuthorOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ComicOrderByRelationAggregateInput? comics;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll(
        [l$id, l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$AuthorOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ComicOrderByRelationAggregateInput? Function()? comics}) =>
      Input$AuthorOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorRelationFilter {
  Input$AuthorRelationFilter({this.$is, this.isNot});

  @override
  factory Input$AuthorRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$AuthorRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$AuthorWhereInput? $is;

  final Input$AuthorWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$AuthorRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$AuthorRelationFilter copyWith(
          {Input$AuthorWhereInput? Function()? $is,
          Input$AuthorWhereInput? Function()? isNot}) =>
      Input$AuthorRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorScalarWhereWithAggregatesInput {
  Input$AuthorScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AuthorScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$AuthorScalarWhereWithAggregatesInput?>? AND;

  final List<Input$AuthorScalarWhereWithAggregatesInput?>? OR;

  final List<Input$AuthorScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? slug;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorScalarWhereWithAggregatesInput copyWith(
          {List<Input$AuthorScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$AuthorScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$AuthorScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? slug,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$AuthorScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorSumOrderByAggregateInput {
  Input$AuthorSumOrderByAggregateInput({this.id});

  @override
  factory Input$AuthorSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$AuthorSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$AuthorSumOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUncheckedCreateInput {
  Input$AuthorUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$AuthorUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUncheckedCreateInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  final Input$ComicUncheckedCreateNestedManyWithoutAuthorInput? comics;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll(
        [l$id, l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$AuthorUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ComicUncheckedCreateNestedManyWithoutAuthorInput? Function()?
              comics}) =>
      Input$AuthorUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUncheckedCreateWithoutComicsInput {
  Input$AuthorUncheckedCreateWithoutComicsInput(
      {this.id,
      required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$AuthorUncheckedCreateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUncheckedCreateWithoutComicsInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUncheckedCreateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUncheckedCreateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorUncheckedCreateWithoutComicsInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$AuthorUncheckedCreateWithoutComicsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUncheckedUpdateInput {
  Input$AuthorUncheckedUpdateInput(
      {this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$AuthorUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ComicUncheckedUpdateManyWithoutAuthorInput? comics;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll(
        [l$id, l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$AuthorUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ComicUncheckedUpdateManyWithoutAuthorInput? Function()?
              comics}) =>
      Input$AuthorUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUncheckedUpdateManyInput {
  Input$AuthorUncheckedUpdateManyInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AuthorUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUncheckedUpdateWithoutComicsInput {
  Input$AuthorUncheckedUpdateWithoutComicsInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorUncheckedUpdateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUncheckedUpdateWithoutComicsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUncheckedUpdateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUncheckedUpdateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorUncheckedUpdateWithoutComicsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AuthorUncheckedUpdateWithoutComicsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUpdateInput {
  Input$AuthorUpdateInput(
      {this.name, this.slug, this.createdAt, this.updatedAt, this.comics});

  @override
  factory Input$AuthorUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AuthorUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ComicUpdateManyWithoutAuthorInput? comics;

  Map<String, dynamic> toJson() => _$Input$AuthorUpdateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$AuthorUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ComicUpdateManyWithoutAuthorInput? Function()? comics}) =>
      Input$AuthorUpdateInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUpdateManyMutationInput {
  Input$AuthorUpdateManyMutationInput(
      {this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AuthorUpdateManyMutationInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUpdateOneRequiredWithoutComicsInput {
  Input$AuthorUpdateOneRequiredWithoutComicsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$AuthorUpdateOneRequiredWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUpdateOneRequiredWithoutComicsInputFromJson(json);

  final Input$AuthorUncheckedCreateWithoutComicsInput? create;

  final Input$AuthorCreateOrConnectWithoutComicsInput? connectOrCreate;

  final Input$AuthorUpsertWithoutComicsInput? upsert;

  final Input$AuthorWhereUniqueInput? connect;

  final Input$AuthorUncheckedUpdateWithoutComicsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUpdateOneRequiredWithoutComicsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUpdateOneRequiredWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$AuthorUpdateOneRequiredWithoutComicsInput copyWith(
          {Input$AuthorUncheckedCreateWithoutComicsInput? Function()? create,
          Input$AuthorCreateOrConnectWithoutComicsInput? Function()?
              connectOrCreate,
          Input$AuthorUpsertWithoutComicsInput? Function()? upsert,
          Input$AuthorWhereUniqueInput? Function()? connect,
          Input$AuthorUncheckedUpdateWithoutComicsInput? Function()? update}) =>
      Input$AuthorUpdateOneRequiredWithoutComicsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUpdateWithoutComicsInput {
  Input$AuthorUpdateWithoutComicsInput(
      {this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$AuthorUpdateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUpdateWithoutComicsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUpdateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUpdateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$AuthorUpdateWithoutComicsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$AuthorUpdateWithoutComicsInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorUpsertWithoutComicsInput {
  Input$AuthorUpsertWithoutComicsInput(
      {required this.update, required this.create});

  @override
  factory Input$AuthorUpsertWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$AuthorUpsertWithoutComicsInputFromJson(json);

  final Input$AuthorUncheckedUpdateWithoutComicsInput update;

  final Input$AuthorUncheckedCreateWithoutComicsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$AuthorUpsertWithoutComicsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorUpsertWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$AuthorUpsertWithoutComicsInput copyWith(
          {Input$AuthorUncheckedUpdateWithoutComicsInput? update,
          Input$AuthorUncheckedCreateWithoutComicsInput? create}) =>
      Input$AuthorUpsertWithoutComicsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorWhereInput {
  Input$AuthorWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$AuthorWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AuthorWhereInputFromJson(json);

  final List<Input$AuthorWhereInput?>? AND;

  final List<Input$AuthorWhereInput?>? OR;

  final List<Input$AuthorWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? slug;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ComicListRelationFilter? comics;

  Map<String, dynamic> toJson() => _$Input$AuthorWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt,
      l$comics
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$AuthorWhereInput copyWith(
          {List<Input$AuthorWhereInput?>? Function()? AND,
          List<Input$AuthorWhereInput?>? Function()? OR,
          List<Input$AuthorWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? slug,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ComicListRelationFilter? Function()? comics}) =>
      Input$AuthorWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$AuthorWhereUniqueInput {
  Input$AuthorWhereUniqueInput({this.id, this.name, this.slug});

  @override
  factory Input$AuthorWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$AuthorWhereUniqueInputFromJson(json);

  final int? id;

  final String? name;

  final String? slug;

  Map<String, dynamic> toJson() => _$Input$AuthorWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    return Object.hashAll([l$id, l$name, l$slug]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$AuthorWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    return true;
  }

  Input$AuthorWhereUniqueInput copyWith(
          {int? Function()? id,
          String? Function()? name,
          String? Function()? slug}) =>
      Input$AuthorWhereUniqueInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug());
}

@JsonSerializable(explicitToJson: true)
class Input$BoolFieldUpdateOperationsInput {
  Input$BoolFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$BoolFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$BoolFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final bool? $set;

  Map<String, dynamic> toJson() =>
      _$Input$BoolFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$BoolFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$BoolFieldUpdateOperationsInput copyWith({bool? Function()? $set}) =>
      Input$BoolFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$BoolFilter {
  Input$BoolFilter({this.equals, this.not});

  @override
  factory Input$BoolFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$BoolFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolFilter? not;

  Map<String, dynamic> toJson() => _$Input$BoolFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([l$equals, l$not]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$BoolFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$BoolFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolFilter? Function()? not}) =>
      Input$BoolFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$BoolWithAggregatesFilter {
  Input$BoolWithAggregatesFilter(
      {this.equals, this.not, this.$_count, this.$_min, this.$_max});

  @override
  factory Input$BoolWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$BoolWithAggregatesFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedBoolFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedBoolFilter? $_max;

  Map<String, dynamic> toJson() => _$Input$BoolWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([l$equals, l$not, l$$_count, l$$_min, l$$_max]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$BoolWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$BoolWithAggregatesFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedBoolFilter? Function()? $_min,
          Input$NestedBoolFilter? Function()? $_max}) =>
      Input$BoolWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogAvgOrderByAggregateInput {
  Input$ChangelogAvgOrderByAggregateInput({this.id, this.userId});

  @override
  factory Input$ChangelogAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    return Object.hashAll([l$id, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ChangelogAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId}) =>
      Input$ChangelogAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCountOrderByAggregateInput {
  Input$ChangelogCountOrderByAggregateInput(
      {this.id,
      this.version,
      this.features,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? version;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? features;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$version, l$features, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != lOther$features) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? version,
          Enum$SortOrder? Function()? features,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChangelogCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreatefeaturesInput {
  Input$ChangelogCreatefeaturesInput({required this.$set});

  @override
  factory Input$ChangelogCreatefeaturesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCreatefeaturesInputFromJson(json);

  @JsonKey(name: 'set')
  final String $set;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCreatefeaturesInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreatefeaturesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$ChangelogCreatefeaturesInput copyWith({String? $set}) =>
      Input$ChangelogCreatefeaturesInput($set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateInput {
  Input$ChangelogCreateInput(
      {required this.version,
      this.features,
      required this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChangelogCreateInputFromJson(json);

  final String version;

  final List<String?>? features;

  final Input$UserCreateNestedOneWithoutChangelogsInput user;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ChangelogCreateInputToJson(this);
  int get hashCode {
    final l$version = version;
    final l$features = features;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogCreateInput copyWith(
          {String? version,
          List<String?>? Function()? features,
          Input$UserCreateNestedOneWithoutChangelogsInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChangelogCreateInput(
          version: version == null ? this.version : version,
          features: features == null ? this.features : features(),
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateManyInput {
  Input$ChangelogCreateManyInput(
      {this.id,
      required this.version,
      this.features,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChangelogCreateManyInputFromJson(json);

  final int? id;

  final String version;

  final List<String?>? features;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ChangelogCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogCreateManyInput copyWith(
          {int? Function()? id,
          String? version,
          List<String?>? Function()? features,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChangelogCreateManyInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version,
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateManyUserInput {
  Input$ChangelogCreateManyUserInput(
      {this.id,
      required this.version,
      this.features,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCreateManyUserInputFromJson(json);

  final int? id;

  final String version;

  final List<String?>? features;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogCreateManyUserInput copyWith(
          {int? Function()? id,
          String? version,
          List<String?>? Function()? features,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChangelogCreateManyUserInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version,
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateManyUserInputEnvelope {
  Input$ChangelogCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ChangelogCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCreateManyUserInputEnvelopeFromJson(json);

  final Input$ChangelogCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ChangelogCreateManyUserInputEnvelope copyWith(
          {Input$ChangelogCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ChangelogCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateNestedManyWithoutUserInput {
  Input$ChangelogCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChangelogCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ChangelogCreateWithoutUserInput?>? create;

  final List<Input$ChangelogCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ChangelogCreateManyUserInputEnvelope? createMany;

  final List<Input$ChangelogWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChangelogCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ChangelogCreateWithoutUserInput?>? Function()? create,
          List<Input$ChangelogCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ChangelogCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ChangelogWhereUniqueInput?>? Function()? connect}) =>
      Input$ChangelogCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateOrConnectWithoutUserInput {
  Input$ChangelogCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ChangelogCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ChangelogWhereUniqueInput where;

  final Input$ChangelogUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChangelogCreateOrConnectWithoutUserInput copyWith(
          {Input$ChangelogWhereUniqueInput? where,
          Input$ChangelogUncheckedCreateWithoutUserInput? create}) =>
      Input$ChangelogCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogCreateWithoutUserInput {
  Input$ChangelogCreateWithoutUserInput(
      {required this.version, this.features, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogCreateWithoutUserInputFromJson(json);

  final String version;

  final List<String?>? features;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogCreateWithoutUserInput copyWith(
          {String? version,
          List<String?>? Function()? features,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChangelogCreateWithoutUserInput(
          version: version == null ? this.version : version,
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogListRelationFilter {
  Input$ChangelogListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ChangelogListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogListRelationFilterFromJson(json);

  final Input$ChangelogWhereInput? every;

  final Input$ChangelogWhereInput? some;

  final Input$ChangelogWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ChangelogListRelationFilter copyWith(
          {Input$ChangelogWhereInput? Function()? every,
          Input$ChangelogWhereInput? Function()? some,
          Input$ChangelogWhereInput? Function()? none}) =>
      Input$ChangelogListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogMaxOrderByAggregateInput {
  Input$ChangelogMaxOrderByAggregateInput(
      {this.id, this.version, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? version;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$version, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? version,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChangelogMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogMinOrderByAggregateInput {
  Input$ChangelogMinOrderByAggregateInput(
      {this.id, this.version, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? version;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$version, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? version,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChangelogMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogOrderByRelationAggregateInput {
  Input$ChangelogOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ChangelogOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ChangelogOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ChangelogOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogOrderByWithAggregationInput {
  Input$ChangelogOrderByWithAggregationInput(
      {this.id,
      this.version,
      this.features,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ChangelogOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? version;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? features;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ChangelogCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ChangelogAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ChangelogMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ChangelogMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ChangelogSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$version,
      l$features,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != lOther$features) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ChangelogOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? version,
          Enum$SortOrder? Function()? features,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ChangelogCountOrderByAggregateInput? Function()? $_count,
          Input$ChangelogAvgOrderByAggregateInput? Function()? $_avg,
          Input$ChangelogMaxOrderByAggregateInput? Function()? $_max,
          Input$ChangelogMinOrderByAggregateInput? Function()? $_min,
          Input$ChangelogSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ChangelogOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogOrderByWithRelationInput {
  Input$ChangelogOrderByWithRelationInput(
      {this.id,
      this.version,
      this.features,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? version;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? features;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != lOther$features) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? version,
          Enum$SortOrder? Function()? features,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ChangelogOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogScalarWhereInput {
  Input$ChangelogScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.version,
      this.features,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChangelogScalarWhereInputFromJson(json);

  final List<Input$ChangelogScalarWhereInput?>? AND;

  final List<Input$ChangelogScalarWhereInput?>? OR;

  final List<Input$ChangelogScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? version;

  final Input$StringNullableListFilter? features;

  final Input$IntFilter? userId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$version,
      l$features,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != lOther$features) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogScalarWhereInput copyWith(
          {List<Input$ChangelogScalarWhereInput?>? Function()? AND,
          List<Input$ChangelogScalarWhereInput?>? Function()? OR,
          List<Input$ChangelogScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? version,
          Input$StringNullableListFilter? Function()? features,
          Input$IntFilter? Function()? userId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ChangelogScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogScalarWhereWithAggregatesInput {
  Input$ChangelogScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.version,
      this.features,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ChangelogScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ChangelogScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ChangelogScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? version;

  final Input$StringNullableListFilter? features;

  final Input$IntWithAggregatesFilter? userId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$version,
      l$features,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != lOther$features) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogScalarWhereWithAggregatesInput copyWith(
          {List<Input$ChangelogScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ChangelogScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ChangelogScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? version,
          Input$StringNullableListFilter? Function()? features,
          Input$IntWithAggregatesFilter? Function()? userId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ChangelogScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogSumOrderByAggregateInput {
  Input$ChangelogSumOrderByAggregateInput({this.id, this.userId});

  @override
  factory Input$ChangelogSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    return Object.hashAll([l$id, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ChangelogSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId}) =>
      Input$ChangelogSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedCreateInput {
  Input$ChangelogUncheckedCreateInput(
      {this.id,
      required this.version,
      this.features,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedCreateInputFromJson(json);

  final int? id;

  final String version;

  final List<String?>? features;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? version,
          List<String?>? Function()? features,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChangelogUncheckedCreateInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version,
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedCreateNestedManyWithoutUserInput {
  Input$ChangelogUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChangelogUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ChangelogCreateWithoutUserInput?>? create;

  final List<Input$ChangelogCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ChangelogCreateManyUserInputEnvelope? createMany;

  final List<Input$ChangelogWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChangelogUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ChangelogCreateWithoutUserInput?>? Function()? create,
          List<Input$ChangelogCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ChangelogCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ChangelogWhereUniqueInput?>? Function()? connect}) =>
      Input$ChangelogUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedCreateWithoutUserInput {
  Input$ChangelogUncheckedCreateWithoutUserInput(
      {this.id,
      required this.version,
      this.features,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedCreateWithoutUserInputFromJson(json);

  final int? id;

  final String version;

  final List<String?>? features;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUncheckedCreateWithoutUserInput copyWith(
          {int? Function()? id,
          String? version,
          List<String?>? Function()? features,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChangelogUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version,
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedUpdateInput {
  Input$ChangelogUncheckedUpdateInput(
      {this.id,
      this.version,
      this.features,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedUpdateManyInput {
  Input$ChangelogUncheckedUpdateManyInput(
      {this.id,
      this.version,
      this.features,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput {
  Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput(
      {this.id, this.version, this.features, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedUpdateManyWithoutChangelogsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedUpdateManyWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedUpdateManyWithoutUserInput {
  Input$ChangelogUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChangelogUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ChangelogCreateWithoutUserInput?>? create;

  final List<Input$ChangelogCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ChangelogUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ChangelogCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChangelogWhereUniqueInput?>? $set;

  final List<Input$ChangelogWhereUniqueInput?>? disconnect;

  final List<Input$ChangelogWhereUniqueInput?>? delete;

  final List<Input$ChangelogWhereUniqueInput?>? connect;

  final List<Input$ChangelogUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ChangelogUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ChangelogScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChangelogUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ChangelogCreateWithoutUserInput?>? Function()? create,
          List<Input$ChangelogCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ChangelogUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ChangelogCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ChangelogWhereUniqueInput?>? Function()? $set,
          List<Input$ChangelogWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChangelogWhereUniqueInput?>? Function()? delete,
          List<Input$ChangelogWhereUniqueInput?>? Function()? connect,
          List<Input$ChangelogUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ChangelogUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ChangelogScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChangelogUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUncheckedUpdateWithoutUserInput {
  Input$ChangelogUncheckedUpdateWithoutUserInput(
      {this.id, this.version, this.features, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUncheckedUpdateWithoutUserInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdatefeaturesInput {
  Input$ChangelogUpdatefeaturesInput({this.$set, this.push});

  @override
  factory Input$ChangelogUpdatefeaturesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpdatefeaturesInputFromJson(json);

  @JsonKey(name: 'set')
  final List<String?>? $set;

  final List<String?>? push;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpdatefeaturesInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdatefeaturesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$ChangelogUpdatefeaturesInput copyWith(
          {List<String?>? Function()? $set, List<String?>? Function()? push}) =>
      Input$ChangelogUpdatefeaturesInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdateInput {
  Input$ChangelogUpdateInput(
      {this.version, this.features, this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChangelogUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$UserUpdateOneRequiredWithoutChangelogsInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ChangelogUpdateInputToJson(this);
  int get hashCode {
    final l$version = version;
    final l$features = features;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$UserUpdateOneRequiredWithoutChangelogsInput? Function()? user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUpdateInput(
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdateManyMutationInput {
  Input$ChangelogUpdateManyMutationInput(
      {this.version, this.features, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUpdateManyMutationInput(
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdateManyWithoutUserInput {
  Input$ChangelogUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChangelogUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ChangelogCreateWithoutUserInput?>? create;

  final List<Input$ChangelogCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ChangelogUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ChangelogCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChangelogWhereUniqueInput?>? $set;

  final List<Input$ChangelogWhereUniqueInput?>? disconnect;

  final List<Input$ChangelogWhereUniqueInput?>? delete;

  final List<Input$ChangelogWhereUniqueInput?>? connect;

  final List<Input$ChangelogUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ChangelogUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ChangelogScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChangelogUpdateManyWithoutUserInput copyWith(
          {List<Input$ChangelogCreateWithoutUserInput?>? Function()? create,
          List<Input$ChangelogCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ChangelogUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ChangelogCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ChangelogWhereUniqueInput?>? Function()? $set,
          List<Input$ChangelogWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChangelogWhereUniqueInput?>? Function()? delete,
          List<Input$ChangelogWhereUniqueInput?>? Function()? connect,
          List<Input$ChangelogUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ChangelogUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ChangelogScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChangelogUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdateManyWithWhereWithoutUserInput {
  Input$ChangelogUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ChangelogUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ChangelogScalarWhereInput where;

  final Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChangelogUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ChangelogScalarWhereInput? where,
          Input$ChangelogUncheckedUpdateManyWithoutChangelogsInput? data}) =>
      Input$ChangelogUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdateWithoutUserInput {
  Input$ChangelogUpdateWithoutUserInput(
      {this.version, this.features, this.createdAt, this.updatedAt});

  @override
  factory Input$ChangelogUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? version;

  final List<String?>? features;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$version = version;
    final l$features = features;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$version,
      l$features == null ? null : Object.hashAll(l$features.map((v) => v)),
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != null && lOther$features != null) {
      if (l$features.length != lOther$features.length) return false;
      for (int i = 0; i < l$features.length; i++) {
        final l$features$entry = l$features[i];
        final lOther$features$entry = lOther$features[i];
        if (l$features$entry != lOther$features$entry) return false;
      }
    } else if (l$features != lOther$features) {
      return false;
    }

    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? version,
          List<String?>? Function()? features,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChangelogUpdateWithoutUserInput(
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpdateWithWhereUniqueWithoutUserInput {
  Input$ChangelogUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ChangelogUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ChangelogWhereUniqueInput where;

  final Input$ChangelogUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChangelogUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ChangelogWhereUniqueInput? where,
          Input$ChangelogUncheckedUpdateWithoutUserInput? data}) =>
      Input$ChangelogUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogUpsertWithWhereUniqueWithoutUserInput {
  Input$ChangelogUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ChangelogUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChangelogUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ChangelogWhereUniqueInput where;

  final Input$ChangelogUncheckedUpdateWithoutUserInput update;

  final Input$ChangelogUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChangelogUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ChangelogWhereUniqueInput? where,
          Input$ChangelogUncheckedUpdateWithoutUserInput? update,
          Input$ChangelogUncheckedCreateWithoutUserInput? create}) =>
      Input$ChangelogUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogWhereInput {
  Input$ChangelogWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.version,
      this.features,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChangelogWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChangelogWhereInputFromJson(json);

  final List<Input$ChangelogWhereInput?>? AND;

  final List<Input$ChangelogWhereInput?>? OR;

  final List<Input$ChangelogWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? version;

  final Input$StringNullableListFilter? features;

  final Input$IntFilter? userId;

  final Input$UserWhereInput? user;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ChangelogWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$version = version;
    final l$features = features;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$version,
      l$features,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) return false;
    final l$features = features;
    final lOther$features = other.features;
    if (l$features != lOther$features) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChangelogWhereInput copyWith(
          {List<Input$ChangelogWhereInput?>? Function()? AND,
          List<Input$ChangelogWhereInput?>? Function()? OR,
          List<Input$ChangelogWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? version,
          Input$StringNullableListFilter? Function()? features,
          Input$IntFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ChangelogWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          version: version == null ? this.version : version(),
          features: features == null ? this.features : features(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChangelogWhereUniqueInput {
  Input$ChangelogWhereUniqueInput({this.id});

  @override
  factory Input$ChangelogWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChangelogWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() =>
      _$Input$ChangelogWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChangelogWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ChangelogWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$ChangelogWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterAvgOrderByAggregateInput {
  Input$ChapterAvgOrderByAggregateInput(
      {this.id,
      this.name,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.comicId});

  @override
  factory Input$ChapterAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$comicId = comicId;
    return Object.hashAll(
        [l$id, l$name, l$views, l$imageCount, l$originalImageCount, l$comicId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? comicId}) =>
      Input$ChapterAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCountOrderByAggregateInput {
  Input$ChapterCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? cdn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? quality;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? processed;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? needOptimize;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? missing;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? batchs;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageUrls;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageDetails;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls,
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != lOther$imageUrls) return false;
    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? cdn,
          Enum$SortOrder? Function()? quality,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? processed,
          Enum$SortOrder? Function()? needOptimize,
          Enum$SortOrder? Function()? missing,
          Enum$SortOrder? Function()? batchs,
          Enum$SortOrder? Function()? imageUrls,
          Enum$SortOrder? Function()? imageDetails,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? comicId}) =>
      Input$ChapterCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateimageUrlsInput {
  Input$ChapterCreateimageUrlsInput({required this.$set});

  @override
  factory Input$ChapterCreateimageUrlsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateimageUrlsInputFromJson(json);

  @JsonKey(name: 'set')
  final String $set;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateimageUrlsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateimageUrlsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$ChapterCreateimageUrlsInput copyWith({String? $set}) =>
      Input$ChapterCreateimageUrlsInput($set: $set == null ? this.$set : $set);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateInput {
  Input$ChapterCreateInput(
      {required this.name,
      this.title,
      this.cdn,
      required this.comic,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.userviewers});

  @override
  factory Input$ChapterCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterCreateInputFromJson(json);

  final double name;

  final String? title;

  final String? cdn;

  final Input$ComicCreateNestedOneWithoutChaptersInput comic;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  final Input$ViewedChapterCreateNestedManyWithoutChapterInput? userviewers;

  Map<String, dynamic> toJson() => _$Input$ChapterCreateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$comic = comic;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$comic,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterCreateInput copyWith(
          {double? name,
          String? Function()? title,
          String? Function()? cdn,
          Input$ComicCreateNestedOneWithoutChaptersInput? comic,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ViewedChapterCreateNestedManyWithoutChapterInput? Function()?
              userviewers}) =>
      Input$ChapterCreateInput(
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          comic: comic == null ? this.comic : comic,
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateManyComicInput {
  Input$ChapterCreateManyComicInput(
      {this.id,
      required this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChapterCreateManyComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateManyComicInputFromJson(json);

  final int? id;

  final double name;

  final String? title;

  final String? cdn;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateManyComicInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateManyComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChapterCreateManyComicInput copyWith(
          {int? Function()? id,
          double? name,
          String? Function()? title,
          String? Function()? cdn,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChapterCreateManyComicInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateManyComicInputEnvelope {
  Input$ChapterCreateManyComicInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ChapterCreateManyComicInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateManyComicInputEnvelopeFromJson(json);

  final Input$ChapterCreateManyComicInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateManyComicInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateManyComicInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ChapterCreateManyComicInputEnvelope copyWith(
          {Input$ChapterCreateManyComicInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ChapterCreateManyComicInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateManyInput {
  Input$ChapterCreateManyInput(
      {this.id,
      required this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      required this.comicId});

  @override
  factory Input$ChapterCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterCreateManyInputFromJson(json);

  final int? id;

  final double name;

  final String? title;

  final String? cdn;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  final int comicId;

  Map<String, dynamic> toJson() => _$Input$ChapterCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterCreateManyInput copyWith(
          {int? Function()? id,
          double? name,
          String? Function()? title,
          String? Function()? cdn,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? comicId}) =>
      Input$ChapterCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateNestedManyWithoutComicInput {
  Input$ChapterCreateNestedManyWithoutComicInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChapterCreateNestedManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateNestedManyWithoutComicInputFromJson(json);

  final List<Input$ChapterCreateWithoutComicInput?>? create;

  final List<Input$ChapterCreateOrConnectWithoutComicInput?>? connectOrCreate;

  final Input$ChapterCreateManyComicInputEnvelope? createMany;

  final List<Input$ChapterWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateNestedManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateNestedManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChapterCreateNestedManyWithoutComicInput copyWith(
          {List<Input$ChapterCreateWithoutComicInput?>? Function()? create,
          List<Input$ChapterCreateOrConnectWithoutComicInput?>? Function()?
              connectOrCreate,
          Input$ChapterCreateManyComicInputEnvelope? Function()? createMany,
          List<Input$ChapterWhereUniqueInput?>? Function()? connect}) =>
      Input$ChapterCreateNestedManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateNestedOneWithoutUserviewersInput {
  Input$ChapterCreateNestedOneWithoutUserviewersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ChapterCreateNestedOneWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateNestedOneWithoutUserviewersInputFromJson(json);

  final Input$ChapterUncheckedCreateWithoutUserviewersInput? create;

  final Input$ChapterCreateOrConnectWithoutUserviewersInput? connectOrCreate;

  final Input$ChapterWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateNestedOneWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateNestedOneWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ChapterCreateNestedOneWithoutUserviewersInput copyWith(
          {Input$ChapterUncheckedCreateWithoutUserviewersInput? Function()?
              create,
          Input$ChapterCreateOrConnectWithoutUserviewersInput? Function()?
              connectOrCreate,
          Input$ChapterWhereUniqueInput? Function()? connect}) =>
      Input$ChapterCreateNestedOneWithoutUserviewersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateOrConnectWithoutComicInput {
  Input$ChapterCreateOrConnectWithoutComicInput(
      {required this.where, required this.create});

  @override
  factory Input$ChapterCreateOrConnectWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateOrConnectWithoutComicInputFromJson(json);

  final Input$ChapterWhereUniqueInput where;

  final Input$ChapterUncheckedCreateWithoutComicInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateOrConnectWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateOrConnectWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChapterCreateOrConnectWithoutComicInput copyWith(
          {Input$ChapterWhereUniqueInput? where,
          Input$ChapterUncheckedCreateWithoutComicInput? create}) =>
      Input$ChapterCreateOrConnectWithoutComicInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateOrConnectWithoutUserviewersInput {
  Input$ChapterCreateOrConnectWithoutUserviewersInput(
      {required this.where, required this.create});

  @override
  factory Input$ChapterCreateOrConnectWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateOrConnectWithoutUserviewersInputFromJson(json);

  final Input$ChapterWhereUniqueInput where;

  final Input$ChapterUncheckedCreateWithoutUserviewersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateOrConnectWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateOrConnectWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChapterCreateOrConnectWithoutUserviewersInput copyWith(
          {Input$ChapterWhereUniqueInput? where,
          Input$ChapterUncheckedCreateWithoutUserviewersInput? create}) =>
      Input$ChapterCreateOrConnectWithoutUserviewersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateWithoutComicInput {
  Input$ChapterCreateWithoutComicInput(
      {required this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.userviewers});

  @override
  factory Input$ChapterCreateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateWithoutComicInputFromJson(json);

  final double name;

  final String? title;

  final String? cdn;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  final Input$ViewedChapterCreateNestedManyWithoutChapterInput? userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateWithoutComicInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterCreateWithoutComicInput copyWith(
          {double? name,
          String? Function()? title,
          String? Function()? cdn,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ViewedChapterCreateNestedManyWithoutChapterInput? Function()?
              userviewers}) =>
      Input$ChapterCreateWithoutComicInput(
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterCreateWithoutUserviewersInput {
  Input$ChapterCreateWithoutUserviewersInput(
      {required this.name,
      this.title,
      this.cdn,
      required this.comic,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChapterCreateWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterCreateWithoutUserviewersInputFromJson(json);

  final double name;

  final String? title;

  final String? cdn;

  final Input$ComicCreateNestedOneWithoutChaptersInput comic;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterCreateWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$comic = comic;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$comic,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterCreateWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChapterCreateWithoutUserviewersInput copyWith(
          {double? name,
          String? Function()? title,
          String? Function()? cdn,
          Input$ComicCreateNestedOneWithoutChaptersInput? comic,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ChapterCreateWithoutUserviewersInput(
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          comic: comic == null ? this.comic : comic,
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterListRelationFilter {
  Input$ChapterListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ChapterListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterListRelationFilterFromJson(json);

  final Input$ChapterWhereInput? every;

  final Input$ChapterWhereInput? some;

  final Input$ChapterWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ChapterListRelationFilter copyWith(
          {Input$ChapterWhereInput? Function()? every,
          Input$ChapterWhereInput? Function()? some,
          Input$ChapterWhereInput? Function()? none}) =>
      Input$ChapterListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterMaxOrderByAggregateInput {
  Input$ChapterMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? cdn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? quality;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? processed;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? needOptimize;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? missing;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? batchs;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? cdn,
          Enum$SortOrder? Function()? quality,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? processed,
          Enum$SortOrder? Function()? needOptimize,
          Enum$SortOrder? Function()? missing,
          Enum$SortOrder? Function()? batchs,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? comicId}) =>
      Input$ChapterMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterMinOrderByAggregateInput {
  Input$ChapterMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? cdn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? quality;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? processed;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? needOptimize;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? missing;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? batchs;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? cdn,
          Enum$SortOrder? Function()? quality,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? processed,
          Enum$SortOrder? Function()? needOptimize,
          Enum$SortOrder? Function()? missing,
          Enum$SortOrder? Function()? batchs,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? comicId}) =>
      Input$ChapterMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterOrderByRelationAggregateInput {
  Input$ChapterOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ChapterOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ChapterOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ChapterOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterOrderByWithAggregationInput {
  Input$ChapterOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ChapterOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? cdn;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? quality;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? processed;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? needOptimize;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? missing;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? batchs;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageUrls;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageDetails;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(name: '_count')
  final Input$ChapterCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ChapterAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ChapterMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ChapterMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ChapterSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls,
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != lOther$imageUrls) return false;
    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ChapterOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? cdn,
          Enum$SortOrder? Function()? quality,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? processed,
          Enum$SortOrder? Function()? needOptimize,
          Enum$SortOrder? Function()? missing,
          Enum$SortOrder? Function()? batchs,
          Enum$SortOrder? Function()? imageUrls,
          Enum$SortOrder? Function()? imageDetails,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? comicId,
          Input$ChapterCountOrderByAggregateInput? Function()? $_count,
          Input$ChapterAvgOrderByAggregateInput? Function()? $_avg,
          Input$ChapterMaxOrderByAggregateInput? Function()? $_max,
          Input$ChapterMinOrderByAggregateInput? Function()? $_min,
          Input$ChapterSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ChapterOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterOrderByWithRelationInput {
  Input$ChapterOrderByWithRelationInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.comic,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId,
      this.userviewers});

  @override
  factory Input$ChapterOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? title;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? cdn;

  final Input$ComicOrderByWithRelationInput? comic;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? quality;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? processed;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? needOptimize;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? missing;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? batchs;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageUrls;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageDetails;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  final Input$ViewedChapterOrderByRelationAggregateInput? userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$comic = comic;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$comic,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls,
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != lOther$imageUrls) return false;
    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? title,
          Enum$SortOrder? Function()? cdn,
          Input$ComicOrderByWithRelationInput? Function()? comic,
          Enum$SortOrder? Function()? quality,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? processed,
          Enum$SortOrder? Function()? needOptimize,
          Enum$SortOrder? Function()? missing,
          Enum$SortOrder? Function()? batchs,
          Enum$SortOrder? Function()? imageUrls,
          Enum$SortOrder? Function()? imageDetails,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? comicId,
          Input$ViewedChapterOrderByRelationAggregateInput? Function()?
              userviewers}) =>
      Input$ChapterOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          comic: comic == null ? this.comic : comic(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterRelationFilter {
  Input$ChapterRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ChapterRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ChapterWhereInput? $is;

  final Input$ChapterWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$ChapterRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ChapterRelationFilter copyWith(
          {Input$ChapterWhereInput? Function()? $is,
          Input$ChapterWhereInput? Function()? isNot}) =>
      Input$ChapterRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterScalarWhereInput {
  Input$ChapterScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterScalarWhereInputFromJson(json);

  final List<Input$ChapterScalarWhereInput?>? AND;

  final List<Input$ChapterScalarWhereInput?>? OR;

  final List<Input$ChapterScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$FloatFilter? name;

  final Input$StringNullableFilter? title;

  final Input$StringNullableFilter? cdn;

  final Input$EnumChapterQualityFilter? quality;

  final Input$IntFilter? views;

  final Input$IntFilter? imageCount;

  final Input$IntFilter? originalImageCount;

  final Input$BoolFilter? processed;

  final Input$BoolFilter? needOptimize;

  final Input$BoolFilter? missing;

  final Input$StringNullableFilter? batchs;

  final Input$StringNullableListFilter? imageUrls;

  final Input$JsonNullableFilter? imageDetails;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$IntFilter? comicId;

  Map<String, dynamic> toJson() => _$Input$ChapterScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls,
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != lOther$imageUrls) return false;
    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterScalarWhereInput copyWith(
          {List<Input$ChapterScalarWhereInput?>? Function()? AND,
          List<Input$ChapterScalarWhereInput?>? Function()? OR,
          List<Input$ChapterScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$FloatFilter? Function()? name,
          Input$StringNullableFilter? Function()? title,
          Input$StringNullableFilter? Function()? cdn,
          Input$EnumChapterQualityFilter? Function()? quality,
          Input$IntFilter? Function()? views,
          Input$IntFilter? Function()? imageCount,
          Input$IntFilter? Function()? originalImageCount,
          Input$BoolFilter? Function()? processed,
          Input$BoolFilter? Function()? needOptimize,
          Input$BoolFilter? Function()? missing,
          Input$StringNullableFilter? Function()? batchs,
          Input$StringNullableListFilter? Function()? imageUrls,
          Input$JsonNullableFilter? Function()? imageDetails,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$IntFilter? Function()? comicId}) =>
      Input$ChapterScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterScalarWhereWithAggregatesInput {
  Input$ChapterScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ChapterScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ChapterScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ChapterScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$FloatWithAggregatesFilter? name;

  final Input$StringNullableWithAggregatesFilter? title;

  final Input$StringNullableWithAggregatesFilter? cdn;

  final Input$EnumChapterQualityWithAggregatesFilter? quality;

  final Input$IntWithAggregatesFilter? views;

  final Input$IntWithAggregatesFilter? imageCount;

  final Input$IntWithAggregatesFilter? originalImageCount;

  final Input$BoolWithAggregatesFilter? processed;

  final Input$BoolWithAggregatesFilter? needOptimize;

  final Input$BoolWithAggregatesFilter? missing;

  final Input$StringNullableWithAggregatesFilter? batchs;

  final Input$StringNullableListFilter? imageUrls;

  final Input$JsonNullableWithAggregatesFilter? imageDetails;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  final Input$IntWithAggregatesFilter? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls,
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != lOther$imageUrls) return false;
    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterScalarWhereWithAggregatesInput copyWith(
          {List<Input$ChapterScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$ChapterScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ChapterScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$FloatWithAggregatesFilter? Function()? name,
          Input$StringNullableWithAggregatesFilter? Function()? title,
          Input$StringNullableWithAggregatesFilter? Function()? cdn,
          Input$EnumChapterQualityWithAggregatesFilter? Function()? quality,
          Input$IntWithAggregatesFilter? Function()? views,
          Input$IntWithAggregatesFilter? Function()? imageCount,
          Input$IntWithAggregatesFilter? Function()? originalImageCount,
          Input$BoolWithAggregatesFilter? Function()? processed,
          Input$BoolWithAggregatesFilter? Function()? needOptimize,
          Input$BoolWithAggregatesFilter? Function()? missing,
          Input$StringNullableWithAggregatesFilter? Function()? batchs,
          Input$StringNullableListFilter? Function()? imageUrls,
          Input$JsonNullableWithAggregatesFilter? Function()? imageDetails,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt,
          Input$IntWithAggregatesFilter? Function()? comicId}) =>
      Input$ChapterScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterSumOrderByAggregateInput {
  Input$ChapterSumOrderByAggregateInput(
      {this.id,
      this.name,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.comicId});

  @override
  factory Input$ChapterSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? imageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? originalImageCount;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$comicId = comicId;
    return Object.hashAll(
        [l$id, l$name, l$views, l$imageCount, l$originalImageCount, l$comicId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? imageCount,
          Enum$SortOrder? Function()? originalImageCount,
          Enum$SortOrder? Function()? comicId}) =>
      Input$ChapterSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedCreateInput {
  Input$ChapterUncheckedCreateInput(
      {this.id,
      required this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      required this.comicId,
      this.userviewers});

  @override
  factory Input$ChapterUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedCreateInputFromJson(json);

  final int? id;

  final double name;

  final String? title;

  final String? cdn;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  final int comicId;

  final Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput?
      userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterUncheckedCreateInput copyWith(
          {int? Function()? id,
          double? name,
          String? Function()? title,
          String? Function()? cdn,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? comicId,
          Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput?
                  Function()?
              userviewers}) =>
      Input$ChapterUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId,
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedCreateNestedManyWithoutComicInput {
  Input$ChapterUncheckedCreateNestedManyWithoutComicInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ChapterUncheckedCreateNestedManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedCreateNestedManyWithoutComicInputFromJson(json);

  final List<Input$ChapterCreateWithoutComicInput?>? create;

  final List<Input$ChapterCreateOrConnectWithoutComicInput?>? connectOrCreate;

  final Input$ChapterCreateManyComicInputEnvelope? createMany;

  final List<Input$ChapterWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedCreateNestedManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedCreateNestedManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ChapterUncheckedCreateNestedManyWithoutComicInput copyWith(
          {List<Input$ChapterCreateWithoutComicInput?>? Function()? create,
          List<Input$ChapterCreateOrConnectWithoutComicInput?>? Function()?
              connectOrCreate,
          Input$ChapterCreateManyComicInputEnvelope? Function()? createMany,
          List<Input$ChapterWhereUniqueInput?>? Function()? connect}) =>
      Input$ChapterUncheckedCreateNestedManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedCreateWithoutComicInput {
  Input$ChapterUncheckedCreateWithoutComicInput(
      {this.id,
      required this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.userviewers});

  @override
  factory Input$ChapterUncheckedCreateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedCreateWithoutComicInputFromJson(json);

  final int? id;

  final double name;

  final String? title;

  final String? cdn;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  final Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput?
      userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedCreateWithoutComicInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedCreateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterUncheckedCreateWithoutComicInput copyWith(
          {int? Function()? id,
          double? name,
          String? Function()? title,
          String? Function()? cdn,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput?
                  Function()?
              userviewers}) =>
      Input$ChapterUncheckedCreateWithoutComicInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedCreateWithoutUserviewersInput {
  Input$ChapterUncheckedCreateWithoutUserviewersInput(
      {this.id,
      required this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      required this.comicId});

  @override
  factory Input$ChapterUncheckedCreateWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedCreateWithoutUserviewersInputFromJson(json);

  final int? id;

  final double name;

  final String? title;

  final String? cdn;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? quality;

  final int? views;

  final int? imageCount;

  final int? originalImageCount;

  final bool? processed;

  final bool? needOptimize;

  final bool? missing;

  final String? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final String? createdAt;

  final String? updatedAt;

  final int comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedCreateWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedCreateWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterUncheckedCreateWithoutUserviewersInput copyWith(
          {int? Function()? id,
          double? name,
          String? Function()? title,
          String? Function()? cdn,
          Enum$ChapterQuality? Function()? quality,
          int? Function()? views,
          int? Function()? imageCount,
          int? Function()? originalImageCount,
          bool? Function()? processed,
          bool? Function()? needOptimize,
          bool? Function()? missing,
          String? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? comicId}) =>
      Input$ChapterUncheckedCreateWithoutUserviewersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedUpdateInput {
  Input$ChapterUncheckedUpdateInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId,
      this.userviewers});

  @override
  factory Input$ChapterUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? comicId;

  final Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput? userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? comicId,
          Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput? Function()?
              userviewers}) =>
      Input$ChapterUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedUpdateManyInput {
  Input$ChapterUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? comicId}) =>
      Input$ChapterUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedUpdateManyWithoutChaptersInput {
  Input$ChapterUncheckedUpdateManyWithoutChaptersInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChapterUncheckedUpdateManyWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedUpdateManyWithoutChaptersInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedUpdateManyWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedUpdateManyWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChapterUncheckedUpdateManyWithoutChaptersInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChapterUncheckedUpdateManyWithoutChaptersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedUpdateManyWithoutComicInput {
  Input$ChapterUncheckedUpdateManyWithoutComicInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChapterUncheckedUpdateManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedUpdateManyWithoutComicInputFromJson(json);

  final List<Input$ChapterCreateWithoutComicInput?>? create;

  final List<Input$ChapterCreateOrConnectWithoutComicInput?>? connectOrCreate;

  final List<Input$ChapterUpsertWithWhereUniqueWithoutComicInput?>? upsert;

  final Input$ChapterCreateManyComicInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChapterWhereUniqueInput?>? $set;

  final List<Input$ChapterWhereUniqueInput?>? disconnect;

  final List<Input$ChapterWhereUniqueInput?>? delete;

  final List<Input$ChapterWhereUniqueInput?>? connect;

  final List<Input$ChapterUpdateWithWhereUniqueWithoutComicInput?>? update;

  final List<Input$ChapterUpdateManyWithWhereWithoutComicInput?>? updateMany;

  final List<Input$ChapterScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedUpdateManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedUpdateManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChapterUncheckedUpdateManyWithoutComicInput copyWith(
          {List<Input$ChapterCreateWithoutComicInput?>? Function()? create,
          List<Input$ChapterCreateOrConnectWithoutComicInput?>? Function()?
              connectOrCreate,
          List<Input$ChapterUpsertWithWhereUniqueWithoutComicInput?>?
                  Function()?
              upsert,
          Input$ChapterCreateManyComicInputEnvelope? Function()? createMany,
          List<Input$ChapterWhereUniqueInput?>? Function()? $set,
          List<Input$ChapterWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChapterWhereUniqueInput?>? Function()? delete,
          List<Input$ChapterWhereUniqueInput?>? Function()? connect,
          List<Input$ChapterUpdateWithWhereUniqueWithoutComicInput?>?
                  Function()?
              update,
          List<Input$ChapterUpdateManyWithWhereWithoutComicInput?>? Function()?
              updateMany,
          List<Input$ChapterScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChapterUncheckedUpdateManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedUpdateWithoutComicInput {
  Input$ChapterUncheckedUpdateWithoutComicInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.userviewers});

  @override
  factory Input$ChapterUncheckedUpdateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedUpdateWithoutComicInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput? userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedUpdateWithoutComicInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedUpdateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterUncheckedUpdateWithoutComicInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput? Function()?
              userviewers}) =>
      Input$ChapterUncheckedUpdateWithoutComicInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUncheckedUpdateWithoutUserviewersInput {
  Input$ChapterUncheckedUpdateWithoutUserviewersInput(
      {this.id,
      this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId});

  @override
  factory Input$ChapterUncheckedUpdateWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUncheckedUpdateWithoutUserviewersInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? comicId;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUncheckedUpdateWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    return Object.hashAll([
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUncheckedUpdateWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    return true;
  }

  Input$ChapterUncheckedUpdateWithoutUserviewersInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? comicId}) =>
      Input$ChapterUncheckedUpdateWithoutUserviewersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateimageUrlsInput {
  Input$ChapterUpdateimageUrlsInput({this.$set, this.push});

  @override
  factory Input$ChapterUpdateimageUrlsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateimageUrlsInputFromJson(json);

  @JsonKey(name: 'set')
  final List<String?>? $set;

  final List<String?>? push;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateimageUrlsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$push = push;
    return Object.hashAll([
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$push == null ? null : Object.hashAll(l$push.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateimageUrlsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$push = push;
    final lOther$push = other.push;
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) return false;
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) return false;
      }
    } else if (l$push != lOther$push) {
      return false;
    }

    return true;
  }

  Input$ChapterUpdateimageUrlsInput copyWith(
          {List<String?>? Function()? $set, List<String?>? Function()? push}) =>
      Input$ChapterUpdateimageUrlsInput(
          $set: $set == null ? this.$set : $set(),
          push: push == null ? this.push : push());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateInput {
  Input$ChapterUpdateInput(
      {this.name,
      this.title,
      this.cdn,
      this.comic,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.userviewers});

  @override
  factory Input$ChapterUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterUpdateInputFromJson(json);

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$ComicUpdateOneRequiredWithoutChaptersInput? comic;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ViewedChapterUpdateManyWithoutChapterInput? userviewers;

  Map<String, dynamic> toJson() => _$Input$ChapterUpdateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$comic = comic;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$comic,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterUpdateInput copyWith(
          {Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$ComicUpdateOneRequiredWithoutChaptersInput? Function()? comic,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ViewedChapterUpdateManyWithoutChapterInput? Function()?
              userviewers}) =>
      Input$ChapterUpdateInput(
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          comic: comic == null ? this.comic : comic(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateManyMutationInput {
  Input$ChapterUpdateManyMutationInput(
      {this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChapterUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateManyMutationInputFromJson(json);

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChapterUpdateManyMutationInput copyWith(
          {Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChapterUpdateManyMutationInput(
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateManyWithoutComicInput {
  Input$ChapterUpdateManyWithoutComicInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ChapterUpdateManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateManyWithoutComicInputFromJson(json);

  final List<Input$ChapterCreateWithoutComicInput?>? create;

  final List<Input$ChapterCreateOrConnectWithoutComicInput?>? connectOrCreate;

  final List<Input$ChapterUpsertWithWhereUniqueWithoutComicInput?>? upsert;

  final Input$ChapterCreateManyComicInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ChapterWhereUniqueInput?>? $set;

  final List<Input$ChapterWhereUniqueInput?>? disconnect;

  final List<Input$ChapterWhereUniqueInput?>? delete;

  final List<Input$ChapterWhereUniqueInput?>? connect;

  final List<Input$ChapterUpdateWithWhereUniqueWithoutComicInput?>? update;

  final List<Input$ChapterUpdateManyWithWhereWithoutComicInput?>? updateMany;

  final List<Input$ChapterScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ChapterUpdateManyWithoutComicInput copyWith(
          {List<Input$ChapterCreateWithoutComicInput?>? Function()? create,
          List<Input$ChapterCreateOrConnectWithoutComicInput?>? Function()?
              connectOrCreate,
          List<Input$ChapterUpsertWithWhereUniqueWithoutComicInput?>?
                  Function()?
              upsert,
          Input$ChapterCreateManyComicInputEnvelope? Function()? createMany,
          List<Input$ChapterWhereUniqueInput?>? Function()? $set,
          List<Input$ChapterWhereUniqueInput?>? Function()? disconnect,
          List<Input$ChapterWhereUniqueInput?>? Function()? delete,
          List<Input$ChapterWhereUniqueInput?>? Function()? connect,
          List<Input$ChapterUpdateWithWhereUniqueWithoutComicInput?>?
                  Function()?
              update,
          List<Input$ChapterUpdateManyWithWhereWithoutComicInput?>? Function()?
              updateMany,
          List<Input$ChapterScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ChapterUpdateManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateManyWithWhereWithoutComicInput {
  Input$ChapterUpdateManyWithWhereWithoutComicInput(
      {required this.where, required this.data});

  @override
  factory Input$ChapterUpdateManyWithWhereWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateManyWithWhereWithoutComicInputFromJson(json);

  final Input$ChapterScalarWhereInput where;

  final Input$ChapterUncheckedUpdateManyWithoutChaptersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateManyWithWhereWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateManyWithWhereWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChapterUpdateManyWithWhereWithoutComicInput copyWith(
          {Input$ChapterScalarWhereInput? where,
          Input$ChapterUncheckedUpdateManyWithoutChaptersInput? data}) =>
      Input$ChapterUpdateManyWithWhereWithoutComicInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateOneRequiredWithoutUserviewersInput {
  Input$ChapterUpdateOneRequiredWithoutUserviewersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ChapterUpdateOneRequiredWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateOneRequiredWithoutUserviewersInputFromJson(json);

  final Input$ChapterUncheckedCreateWithoutUserviewersInput? create;

  final Input$ChapterCreateOrConnectWithoutUserviewersInput? connectOrCreate;

  final Input$ChapterUpsertWithoutUserviewersInput? upsert;

  final Input$ChapterWhereUniqueInput? connect;

  final Input$ChapterUncheckedUpdateWithoutUserviewersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateOneRequiredWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateOneRequiredWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ChapterUpdateOneRequiredWithoutUserviewersInput copyWith(
          {Input$ChapterUncheckedCreateWithoutUserviewersInput? Function()?
              create,
          Input$ChapterCreateOrConnectWithoutUserviewersInput? Function()?
              connectOrCreate,
          Input$ChapterUpsertWithoutUserviewersInput? Function()? upsert,
          Input$ChapterWhereUniqueInput? Function()? connect,
          Input$ChapterUncheckedUpdateWithoutUserviewersInput? Function()?
              update}) =>
      Input$ChapterUpdateOneRequiredWithoutUserviewersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateWithoutComicInput {
  Input$ChapterUpdateWithoutComicInput(
      {this.name,
      this.title,
      this.cdn,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.userviewers});

  @override
  factory Input$ChapterUpdateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateWithoutComicInputFromJson(json);

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ViewedChapterUpdateManyWithoutChapterInput? userviewers;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateWithoutComicInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterUpdateWithoutComicInput copyWith(
          {Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ViewedChapterUpdateManyWithoutChapterInput? Function()?
              userviewers}) =>
      Input$ChapterUpdateWithoutComicInput(
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateWithoutUserviewersInput {
  Input$ChapterUpdateWithoutUserviewersInput(
      {this.name,
      this.title,
      this.cdn,
      this.comic,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ChapterUpdateWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateWithoutUserviewersInputFromJson(json);

  final Input$FloatFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? title;

  final Input$NullableStringFieldUpdateOperationsInput? cdn;

  final Input$ComicUpdateOneRequiredWithoutChaptersInput? comic;

  final Input$EnumChapterQualityFieldUpdateOperationsInput? quality;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? imageCount;

  final Input$IntFieldUpdateOperationsInput? originalImageCount;

  final Input$BoolFieldUpdateOperationsInput? processed;

  final Input$BoolFieldUpdateOperationsInput? needOptimize;

  final Input$BoolFieldUpdateOperationsInput? missing;

  final Input$NullableStringFieldUpdateOperationsInput? batchs;

  final List<String?>? imageUrls;

  final String? imageDetails;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$comic = comic;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$title,
      l$cdn,
      l$comic,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls == null ? null : Object.hashAll(l$imageUrls.map((v) => v)),
      l$imageDetails,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != null && lOther$imageUrls != null) {
      if (l$imageUrls.length != lOther$imageUrls.length) return false;
      for (int i = 0; i < l$imageUrls.length; i++) {
        final l$imageUrls$entry = l$imageUrls[i];
        final lOther$imageUrls$entry = lOther$imageUrls[i];
        if (l$imageUrls$entry != lOther$imageUrls$entry) return false;
      }
    } else if (l$imageUrls != lOther$imageUrls) {
      return false;
    }

    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ChapterUpdateWithoutUserviewersInput copyWith(
          {Input$FloatFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? title,
          Input$NullableStringFieldUpdateOperationsInput? Function()? cdn,
          Input$ComicUpdateOneRequiredWithoutChaptersInput? Function()? comic,
          Input$EnumChapterQualityFieldUpdateOperationsInput? Function()?
              quality,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? imageCount,
          Input$IntFieldUpdateOperationsInput? Function()? originalImageCount,
          Input$BoolFieldUpdateOperationsInput? Function()? processed,
          Input$BoolFieldUpdateOperationsInput? Function()? needOptimize,
          Input$BoolFieldUpdateOperationsInput? Function()? missing,
          Input$NullableStringFieldUpdateOperationsInput? Function()? batchs,
          List<String?>? Function()? imageUrls,
          String? Function()? imageDetails,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ChapterUpdateWithoutUserviewersInput(
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          comic: comic == null ? this.comic : comic(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpdateWithWhereUniqueWithoutComicInput {
  Input$ChapterUpdateWithWhereUniqueWithoutComicInput(
      {required this.where, required this.data});

  @override
  factory Input$ChapterUpdateWithWhereUniqueWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpdateWithWhereUniqueWithoutComicInputFromJson(json);

  final Input$ChapterWhereUniqueInput where;

  final Input$ChapterUncheckedUpdateWithoutComicInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpdateWithWhereUniqueWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpdateWithWhereUniqueWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ChapterUpdateWithWhereUniqueWithoutComicInput copyWith(
          {Input$ChapterWhereUniqueInput? where,
          Input$ChapterUncheckedUpdateWithoutComicInput? data}) =>
      Input$ChapterUpdateWithWhereUniqueWithoutComicInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpsertWithoutUserviewersInput {
  Input$ChapterUpsertWithoutUserviewersInput(
      {required this.update, required this.create});

  @override
  factory Input$ChapterUpsertWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpsertWithoutUserviewersInputFromJson(json);

  final Input$ChapterUncheckedUpdateWithoutUserviewersInput update;

  final Input$ChapterUncheckedCreateWithoutUserviewersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpsertWithoutUserviewersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpsertWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChapterUpsertWithoutUserviewersInput copyWith(
          {Input$ChapterUncheckedUpdateWithoutUserviewersInput? update,
          Input$ChapterUncheckedCreateWithoutUserviewersInput? create}) =>
      Input$ChapterUpsertWithoutUserviewersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterUpsertWithWhereUniqueWithoutComicInput {
  Input$ChapterUpsertWithWhereUniqueWithoutComicInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ChapterUpsertWithWhereUniqueWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ChapterUpsertWithWhereUniqueWithoutComicInputFromJson(json);

  final Input$ChapterWhereUniqueInput where;

  final Input$ChapterUncheckedUpdateWithoutComicInput update;

  final Input$ChapterUncheckedCreateWithoutComicInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ChapterUpsertWithWhereUniqueWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterUpsertWithWhereUniqueWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ChapterUpsertWithWhereUniqueWithoutComicInput copyWith(
          {Input$ChapterWhereUniqueInput? where,
          Input$ChapterUncheckedUpdateWithoutComicInput? update,
          Input$ChapterUncheckedCreateWithoutComicInput? create}) =>
      Input$ChapterUpsertWithWhereUniqueWithoutComicInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterWhereInput {
  Input$ChapterWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.title,
      this.cdn,
      this.comic,
      this.quality,
      this.views,
      this.imageCount,
      this.originalImageCount,
      this.processed,
      this.needOptimize,
      this.missing,
      this.batchs,
      this.imageUrls,
      this.imageDetails,
      this.createdAt,
      this.updatedAt,
      this.comicId,
      this.userviewers});

  @override
  factory Input$ChapterWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterWhereInputFromJson(json);

  final List<Input$ChapterWhereInput?>? AND;

  final List<Input$ChapterWhereInput?>? OR;

  final List<Input$ChapterWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$FloatFilter? name;

  final Input$StringNullableFilter? title;

  final Input$StringNullableFilter? cdn;

  final Input$ComicWhereInput? comic;

  final Input$EnumChapterQualityFilter? quality;

  final Input$IntFilter? views;

  final Input$IntFilter? imageCount;

  final Input$IntFilter? originalImageCount;

  final Input$BoolFilter? processed;

  final Input$BoolFilter? needOptimize;

  final Input$BoolFilter? missing;

  final Input$StringNullableFilter? batchs;

  final Input$StringNullableListFilter? imageUrls;

  final Input$JsonNullableFilter? imageDetails;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$IntFilter? comicId;

  final Input$ViewedChapterListRelationFilter? userviewers;

  Map<String, dynamic> toJson() => _$Input$ChapterWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$title = title;
    final l$cdn = cdn;
    final l$comic = comic;
    final l$quality = quality;
    final l$views = views;
    final l$imageCount = imageCount;
    final l$originalImageCount = originalImageCount;
    final l$processed = processed;
    final l$needOptimize = needOptimize;
    final l$missing = missing;
    final l$batchs = batchs;
    final l$imageUrls = imageUrls;
    final l$imageDetails = imageDetails;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicId = comicId;
    final l$userviewers = userviewers;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$title,
      l$cdn,
      l$comic,
      l$quality,
      l$views,
      l$imageCount,
      l$originalImageCount,
      l$processed,
      l$needOptimize,
      l$missing,
      l$batchs,
      l$imageUrls,
      l$imageDetails,
      l$createdAt,
      l$updatedAt,
      l$comicId,
      l$userviewers
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) return false;
    final l$cdn = cdn;
    final lOther$cdn = other.cdn;
    if (l$cdn != lOther$cdn) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$quality = quality;
    final lOther$quality = other.quality;
    if (l$quality != lOther$quality) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$imageCount = imageCount;
    final lOther$imageCount = other.imageCount;
    if (l$imageCount != lOther$imageCount) return false;
    final l$originalImageCount = originalImageCount;
    final lOther$originalImageCount = other.originalImageCount;
    if (l$originalImageCount != lOther$originalImageCount) return false;
    final l$processed = processed;
    final lOther$processed = other.processed;
    if (l$processed != lOther$processed) return false;
    final l$needOptimize = needOptimize;
    final lOther$needOptimize = other.needOptimize;
    if (l$needOptimize != lOther$needOptimize) return false;
    final l$missing = missing;
    final lOther$missing = other.missing;
    if (l$missing != lOther$missing) return false;
    final l$batchs = batchs;
    final lOther$batchs = other.batchs;
    if (l$batchs != lOther$batchs) return false;
    final l$imageUrls = imageUrls;
    final lOther$imageUrls = other.imageUrls;
    if (l$imageUrls != lOther$imageUrls) return false;
    final l$imageDetails = imageDetails;
    final lOther$imageDetails = other.imageDetails;
    if (l$imageDetails != lOther$imageDetails) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userviewers = userviewers;
    final lOther$userviewers = other.userviewers;
    if (l$userviewers != lOther$userviewers) return false;
    return true;
  }

  Input$ChapterWhereInput copyWith(
          {List<Input$ChapterWhereInput?>? Function()? AND,
          List<Input$ChapterWhereInput?>? Function()? OR,
          List<Input$ChapterWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$FloatFilter? Function()? name,
          Input$StringNullableFilter? Function()? title,
          Input$StringNullableFilter? Function()? cdn,
          Input$ComicWhereInput? Function()? comic,
          Input$EnumChapterQualityFilter? Function()? quality,
          Input$IntFilter? Function()? views,
          Input$IntFilter? Function()? imageCount,
          Input$IntFilter? Function()? originalImageCount,
          Input$BoolFilter? Function()? processed,
          Input$BoolFilter? Function()? needOptimize,
          Input$BoolFilter? Function()? missing,
          Input$StringNullableFilter? Function()? batchs,
          Input$StringNullableListFilter? Function()? imageUrls,
          Input$JsonNullableFilter? Function()? imageDetails,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$IntFilter? Function()? comicId,
          Input$ViewedChapterListRelationFilter? Function()? userviewers}) =>
      Input$ChapterWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          title: title == null ? this.title : title(),
          cdn: cdn == null ? this.cdn : cdn(),
          comic: comic == null ? this.comic : comic(),
          quality: quality == null ? this.quality : quality(),
          views: views == null ? this.views : views(),
          imageCount: imageCount == null ? this.imageCount : imageCount(),
          originalImageCount: originalImageCount == null
              ? this.originalImageCount
              : originalImageCount(),
          processed: processed == null ? this.processed : processed(),
          needOptimize:
              needOptimize == null ? this.needOptimize : needOptimize(),
          missing: missing == null ? this.missing : missing(),
          batchs: batchs == null ? this.batchs : batchs(),
          imageUrls: imageUrls == null ? this.imageUrls : imageUrls(),
          imageDetails:
              imageDetails == null ? this.imageDetails : imageDetails(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicId: comicId == null ? this.comicId : comicId(),
          userviewers: userviewers == null ? this.userviewers : userviewers());
}

@JsonSerializable(explicitToJson: true)
class Input$ChapterWhereUniqueInput {
  Input$ChapterWhereUniqueInput({this.id});

  @override
  factory Input$ChapterWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ChapterWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() => _$Input$ChapterWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ChapterWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ChapterWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$ChapterWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicAvgOrderByAggregateInput {
  Input$ComicAvgOrderByAggregateInput(
      {this.id,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.authorId});

  @override
  factory Input$ComicAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? authorId}) =>
      Input$ComicAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkAvgOrderByAggregateInput {
  Input$ComicBookmarkAvgOrderByAggregateInput(
      {this.id, this.comicId, this.userId});

  @override
  factory Input$ComicBookmarkAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    return Object.hashAll([l$id, l$comicId, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ComicBookmarkAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Enum$SortOrder? Function()? userId}) =>
      Input$ComicBookmarkAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCountOrderByAggregateInput {
  Input$ComicBookmarkCountOrderByAggregateInput(
      {this.id, this.comicId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ComicBookmarkCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateInput {
  Input$ComicBookmarkCreateInput(
      {required this.comic,
      required this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateInputFromJson(json);

  final Input$ComicCreateNestedOneWithoutUserbookmarksInput comic;

  final Input$UserCreateNestedOneWithoutComicbookmarksInput user;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ComicBookmarkCreateInputToJson(this);
  int get hashCode {
    final l$comic = comic;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$comic, l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCreateInput copyWith(
          {Input$ComicCreateNestedOneWithoutUserbookmarksInput? comic,
          Input$UserCreateNestedOneWithoutComicbookmarksInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkCreateInput(
          comic: comic == null ? this.comic : comic,
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateManyComicInput {
  Input$ComicBookmarkCreateManyComicInput(
      {this.id, required this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkCreateManyComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateManyComicInputFromJson(json);

  final int? id;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateManyComicInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateManyComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCreateManyComicInput copyWith(
          {int? Function()? id,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkCreateManyComicInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateManyComicInputEnvelope {
  Input$ComicBookmarkCreateManyComicInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ComicBookmarkCreateManyComicInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateManyComicInputEnvelopeFromJson(json);

  final Input$ComicBookmarkCreateManyComicInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateManyComicInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateManyComicInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ComicBookmarkCreateManyComicInputEnvelope copyWith(
          {Input$ComicBookmarkCreateManyComicInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ComicBookmarkCreateManyComicInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateManyInput {
  Input$ComicBookmarkCreateManyInput(
      {this.id,
      required this.comicId,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateManyInputFromJson(json);

  final int? id;

  final int comicId;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCreateManyInput copyWith(
          {int? Function()? id,
          int? comicId,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkCreateManyInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateManyUserInput {
  Input$ComicBookmarkCreateManyUserInput(
      {this.id, required this.comicId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateManyUserInputFromJson(json);

  final int? id;

  final int comicId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$comicId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCreateManyUserInput copyWith(
          {int? Function()? id,
          int? comicId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkCreateManyUserInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateManyUserInputEnvelope {
  Input$ComicBookmarkCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ComicBookmarkCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateManyUserInputEnvelopeFromJson(json);

  final Input$ComicBookmarkCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ComicBookmarkCreateManyUserInputEnvelope copyWith(
          {Input$ComicBookmarkCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ComicBookmarkCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateNestedManyWithoutComicInput {
  Input$ComicBookmarkCreateNestedManyWithoutComicInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ComicBookmarkCreateNestedManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateNestedManyWithoutComicInputFromJson(json);

  final List<Input$ComicBookmarkCreateWithoutComicInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
      connectOrCreate;

  final Input$ComicBookmarkCreateManyComicInputEnvelope? createMany;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateNestedManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateNestedManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkCreateNestedManyWithoutComicInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutComicInput?>? Function()?
              create,
          List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
                  Function()?
              connectOrCreate,
          Input$ComicBookmarkCreateManyComicInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicBookmarkCreateNestedManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateNestedManyWithoutUserInput {
  Input$ComicBookmarkCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ComicBookmarkCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ComicBookmarkCreateWithoutUserInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ComicBookmarkCreateManyUserInputEnvelope? createMany;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutUserInput?>? Function()? create,
          List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ComicBookmarkCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicBookmarkCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateOrConnectWithoutComicInput {
  Input$ComicBookmarkCreateOrConnectWithoutComicInput(
      {required this.where, required this.create});

  @override
  factory Input$ComicBookmarkCreateOrConnectWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateOrConnectWithoutComicInputFromJson(json);

  final Input$ComicBookmarkWhereUniqueInput where;

  final Input$ComicBookmarkUncheckedCreateWithoutComicInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateOrConnectWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateOrConnectWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicBookmarkCreateOrConnectWithoutComicInput copyWith(
          {Input$ComicBookmarkWhereUniqueInput? where,
          Input$ComicBookmarkUncheckedCreateWithoutComicInput? create}) =>
      Input$ComicBookmarkCreateOrConnectWithoutComicInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateOrConnectWithoutUserInput {
  Input$ComicBookmarkCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ComicBookmarkCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ComicBookmarkWhereUniqueInput where;

  final Input$ComicBookmarkUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicBookmarkCreateOrConnectWithoutUserInput copyWith(
          {Input$ComicBookmarkWhereUniqueInput? where,
          Input$ComicBookmarkUncheckedCreateWithoutUserInput? create}) =>
      Input$ComicBookmarkCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateWithoutComicInput {
  Input$ComicBookmarkCreateWithoutComicInput(
      {required this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkCreateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateWithoutComicInputFromJson(json);

  final Input$UserCreateNestedOneWithoutComicbookmarksInput user;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateWithoutComicInputToJson(this);
  int get hashCode {
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCreateWithoutComicInput copyWith(
          {Input$UserCreateNestedOneWithoutComicbookmarksInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkCreateWithoutComicInput(
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkCreateWithoutUserInput {
  Input$ComicBookmarkCreateWithoutUserInput(
      {required this.comic, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkCreateWithoutUserInputFromJson(json);

  final Input$ComicCreateNestedOneWithoutUserbookmarksInput comic;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$comic = comic;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$comic, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkCreateWithoutUserInput copyWith(
          {Input$ComicCreateNestedOneWithoutUserbookmarksInput? comic,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkCreateWithoutUserInput(
          comic: comic == null ? this.comic : comic,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkListRelationFilter {
  Input$ComicBookmarkListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ComicBookmarkListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkListRelationFilterFromJson(json);

  final Input$ComicBookmarkWhereInput? every;

  final Input$ComicBookmarkWhereInput? some;

  final Input$ComicBookmarkWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ComicBookmarkListRelationFilter copyWith(
          {Input$ComicBookmarkWhereInput? Function()? every,
          Input$ComicBookmarkWhereInput? Function()? some,
          Input$ComicBookmarkWhereInput? Function()? none}) =>
      Input$ComicBookmarkListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkMaxOrderByAggregateInput {
  Input$ComicBookmarkMaxOrderByAggregateInput(
      {this.id, this.comicId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ComicBookmarkMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkMinOrderByAggregateInput {
  Input$ComicBookmarkMinOrderByAggregateInput(
      {this.id, this.comicId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ComicBookmarkMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkOrderByRelationAggregateInput {
  Input$ComicBookmarkOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ComicBookmarkOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ComicBookmarkOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ComicBookmarkOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkOrderByWithAggregationInput {
  Input$ComicBookmarkOrderByWithAggregationInput(
      {this.id,
      this.comicId,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ComicBookmarkOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ComicBookmarkCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ComicBookmarkAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ComicBookmarkMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ComicBookmarkMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ComicBookmarkSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$comicId,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ComicBookmarkOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ComicBookmarkCountOrderByAggregateInput? Function()? $_count,
          Input$ComicBookmarkAvgOrderByAggregateInput? Function()? $_avg,
          Input$ComicBookmarkMaxOrderByAggregateInput? Function()? $_max,
          Input$ComicBookmarkMinOrderByAggregateInput? Function()? $_min,
          Input$ComicBookmarkSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ComicBookmarkOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkOrderByWithRelationInput {
  Input$ComicBookmarkOrderByWithRelationInput(
      {this.id,
      this.comicId,
      this.comic,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  final Input$ComicOrderByWithRelationInput? comic;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$comic = comic;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$comic, l$userId, l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Input$ComicOrderByWithRelationInput? Function()? comic,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ComicBookmarkOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          comic: comic == null ? this.comic : comic(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkScalarWhereInput {
  Input$ComicBookmarkScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.comicId,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkScalarWhereInputFromJson(json);

  final List<Input$ComicBookmarkScalarWhereInput?>? AND;

  final List<Input$ComicBookmarkScalarWhereInput?>? OR;

  final List<Input$ComicBookmarkScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$IntFilter? comicId;

  final Input$IntFilter? userId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$comicId,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkScalarWhereInput copyWith(
          {List<Input$ComicBookmarkScalarWhereInput?>? Function()? AND,
          List<Input$ComicBookmarkScalarWhereInput?>? Function()? OR,
          List<Input$ComicBookmarkScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$IntFilter? Function()? comicId,
          Input$IntFilter? Function()? userId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ComicBookmarkScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkScalarWhereWithAggregatesInput {
  Input$ComicBookmarkScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.comicId,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ComicBookmarkScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ComicBookmarkScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ComicBookmarkScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$IntWithAggregatesFilter? comicId;

  final Input$IntWithAggregatesFilter? userId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$comicId,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkScalarWhereWithAggregatesInput copyWith(
          {List<Input$ComicBookmarkScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ComicBookmarkScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$ComicBookmarkScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$IntWithAggregatesFilter? Function()? comicId,
          Input$IntWithAggregatesFilter? Function()? userId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ComicBookmarkScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkSumOrderByAggregateInput {
  Input$ComicBookmarkSumOrderByAggregateInput(
      {this.id, this.comicId, this.userId});

  @override
  factory Input$ComicBookmarkSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? comicId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    return Object.hashAll([l$id, l$comicId, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ComicBookmarkSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? comicId,
          Enum$SortOrder? Function()? userId}) =>
      Input$ComicBookmarkSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedCreateInput {
  Input$ComicBookmarkUncheckedCreateInput(
      {this.id,
      required this.comicId,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedCreateInputFromJson(json);

  final int? id;

  final int comicId;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedCreateInput copyWith(
          {int? Function()? id,
          int? comicId,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedCreateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput {
  Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInputFromJson(
          json);

  final List<Input$ComicBookmarkCreateWithoutComicInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
      connectOrCreate;

  final Input$ComicBookmarkCreateManyComicInputEnvelope? createMany;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutComicInput?>? Function()?
              create,
          List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
                  Function()?
              connectOrCreate,
          Input$ComicBookmarkCreateManyComicInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput {
  Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$ComicBookmarkCreateWithoutUserInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ComicBookmarkCreateManyUserInputEnvelope? createMany;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutUserInput?>? Function()? create,
          List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ComicBookmarkCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedCreateWithoutComicInput {
  Input$ComicBookmarkUncheckedCreateWithoutComicInput(
      {this.id, required this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedCreateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedCreateWithoutComicInputFromJson(json);

  final int? id;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedCreateWithoutComicInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedCreateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedCreateWithoutComicInput copyWith(
          {int? Function()? id,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedCreateWithoutComicInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedCreateWithoutUserInput {
  Input$ComicBookmarkUncheckedCreateWithoutUserInput(
      {this.id, required this.comicId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedCreateWithoutUserInputFromJson(json);

  final int? id;

  final int comicId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$comicId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedCreateWithoutUserInput copyWith(
          {int? Function()? id,
          int? comicId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateInput {
  Input$ComicBookmarkUncheckedUpdateInput(
      {this.id, this.comicId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? comicId;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? comicId,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateManyInput {
  Input$ComicBookmarkUncheckedUpdateManyInput(
      {this.id, this.comicId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? comicId;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$comicId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? comicId,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput {
  Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput(
      {this.id, this.comicId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInputFromJson(
          json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? comicId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$comicId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? comicId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput {
  Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutComicInputFromJson(json);

  final List<Input$ComicBookmarkCreateWithoutComicInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
      connectOrCreate;

  final List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput?>?
      upsert;

  final Input$ComicBookmarkCreateManyComicInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ComicBookmarkWhereUniqueInput?>? $set;

  final List<Input$ComicBookmarkWhereUniqueInput?>? disconnect;

  final List<Input$ComicBookmarkWhereUniqueInput?>? delete;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  final List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput?>?
      update;

  final List<Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput?>?
      updateMany;

  final List<Input$ComicBookmarkScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutComicInput?>? Function()?
              create,
          List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput?>?
                  Function()?
              upsert,
          Input$ComicBookmarkCreateManyComicInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? $set,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? delete,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect,
          List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput?>?
                  Function()?
              update,
          List<Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput?>?
                  Function()?
              updateMany,
          List<Input$ComicBookmarkScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput {
  Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput(
      {this.id, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInputFromJson(
          json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput {
  Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ComicBookmarkCreateWithoutUserInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ComicBookmarkCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ComicBookmarkWhereUniqueInput?>? $set;

  final List<Input$ComicBookmarkWhereUniqueInput?>? disconnect;

  final List<Input$ComicBookmarkWhereUniqueInput?>? delete;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  final List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$ComicBookmarkScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutUserInput?>? Function()? create,
          List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ComicBookmarkCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? $set,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? delete,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect,
          List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ComicBookmarkScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateWithoutComicInput {
  Input$ComicBookmarkUncheckedUpdateWithoutComicInput(
      {this.id, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedUpdateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateWithoutComicInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateWithoutComicInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedUpdateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedUpdateWithoutComicInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedUpdateWithoutComicInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUncheckedUpdateWithoutUserInput {
  Input$ComicBookmarkUncheckedUpdateWithoutUserInput(
      {this.id, this.comicId, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? comicId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$comicId = comicId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$comicId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUncheckedUpdateWithoutUserInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? comicId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateInput {
  Input$ComicBookmarkUpdateInput(
      {this.comic, this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateInputFromJson(json);

  final Input$ComicUpdateOneRequiredWithoutUserbookmarksInput? comic;

  final Input$UserUpdateOneRequiredWithoutComicbookmarksInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ComicBookmarkUpdateInputToJson(this);
  int get hashCode {
    final l$comic = comic;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$comic, l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUpdateInput copyWith(
          {Input$ComicUpdateOneRequiredWithoutUserbookmarksInput? Function()?
              comic,
          Input$UserUpdateOneRequiredWithoutComicbookmarksInput? Function()?
              user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUpdateInput(
          comic: comic == null ? this.comic : comic(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateManyMutationInput {
  Input$ComicBookmarkUpdateManyMutationInput({this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateManyMutationInputFromJson(json);

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUpdateManyMutationInput copyWith(
          {Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUpdateManyMutationInput(
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateManyWithoutComicInput {
  Input$ComicBookmarkUpdateManyWithoutComicInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicBookmarkUpdateManyWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateManyWithoutComicInputFromJson(json);

  final List<Input$ComicBookmarkCreateWithoutComicInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
      connectOrCreate;

  final List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput?>?
      upsert;

  final Input$ComicBookmarkCreateManyComicInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ComicBookmarkWhereUniqueInput?>? $set;

  final List<Input$ComicBookmarkWhereUniqueInput?>? disconnect;

  final List<Input$ComicBookmarkWhereUniqueInput?>? delete;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  final List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput?>?
      update;

  final List<Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput?>?
      updateMany;

  final List<Input$ComicBookmarkScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateManyWithoutComicInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateManyWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkUpdateManyWithoutComicInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutComicInput?>? Function()?
              create,
          List<Input$ComicBookmarkCreateOrConnectWithoutComicInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput?>?
                  Function()?
              upsert,
          Input$ComicBookmarkCreateManyComicInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? $set,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? delete,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect,
          List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput?>?
                  Function()?
              update,
          List<Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput?>?
                  Function()?
              updateMany,
          List<Input$ComicBookmarkScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ComicBookmarkUpdateManyWithoutComicInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateManyWithoutUserInput {
  Input$ComicBookmarkUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicBookmarkUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ComicBookmarkCreateWithoutUserInput?>? create;

  final List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ComicBookmarkCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ComicBookmarkWhereUniqueInput?>? $set;

  final List<Input$ComicBookmarkWhereUniqueInput?>? disconnect;

  final List<Input$ComicBookmarkWhereUniqueInput?>? delete;

  final List<Input$ComicBookmarkWhereUniqueInput?>? connect;

  final List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$ComicBookmarkScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicBookmarkUpdateManyWithoutUserInput copyWith(
          {List<Input$ComicBookmarkCreateWithoutUserInput?>? Function()? create,
          List<Input$ComicBookmarkCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ComicBookmarkCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? $set,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? delete,
          List<Input$ComicBookmarkWhereUniqueInput?>? Function()? connect,
          List<Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ComicBookmarkScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ComicBookmarkUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput {
  Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateManyWithWhereWithoutComicInputFromJson(json);

  final Input$ComicBookmarkScalarWhereInput where;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateManyWithWhereWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput copyWith(
          {Input$ComicBookmarkScalarWhereInput? where,
          Input$ComicBookmarkUncheckedUpdateManyWithoutUserbookmarksInput?
              data}) =>
      Input$ComicBookmarkUpdateManyWithWhereWithoutComicInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput {
  Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ComicBookmarkScalarWhereInput where;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ComicBookmarkScalarWhereInput? where,
          Input$ComicBookmarkUncheckedUpdateManyWithoutComicbookmarksInput?
              data}) =>
      Input$ComicBookmarkUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateWithoutComicInput {
  Input$ComicBookmarkUpdateWithoutComicInput(
      {this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUpdateWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateWithoutComicInputFromJson(json);

  final Input$UserUpdateOneRequiredWithoutComicbookmarksInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateWithoutComicInputToJson(this);
  int get hashCode {
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUpdateWithoutComicInput copyWith(
          {Input$UserUpdateOneRequiredWithoutComicbookmarksInput? Function()?
              user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUpdateWithoutComicInput(
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateWithoutUserInput {
  Input$ComicBookmarkUpdateWithoutUserInput(
      {this.comic, this.createdAt, this.updatedAt});

  @override
  factory Input$ComicBookmarkUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateWithoutUserInputFromJson(json);

  final Input$ComicUpdateOneRequiredWithoutUserbookmarksInput? comic;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$comic = comic;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$comic, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkUpdateWithoutUserInput copyWith(
          {Input$ComicUpdateOneRequiredWithoutUserbookmarksInput? Function()?
              comic,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicBookmarkUpdateWithoutUserInput(
          comic: comic == null ? this.comic : comic(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput {
  Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInputFromJson(json);

  final Input$ComicBookmarkWhereUniqueInput where;

  final Input$ComicBookmarkUncheckedUpdateWithoutComicInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput copyWith(
          {Input$ComicBookmarkWhereUniqueInput? where,
          Input$ComicBookmarkUncheckedUpdateWithoutComicInput? data}) =>
      Input$ComicBookmarkUpdateWithWhereUniqueWithoutComicInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput {
  Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ComicBookmarkWhereUniqueInput where;

  final Input$ComicBookmarkUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ComicBookmarkWhereUniqueInput? where,
          Input$ComicBookmarkUncheckedUpdateWithoutUserInput? data}) =>
      Input$ComicBookmarkUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput {
  Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInputFromJson(json);

  final Input$ComicBookmarkWhereUniqueInput where;

  final Input$ComicBookmarkUncheckedUpdateWithoutComicInput update;

  final Input$ComicBookmarkUncheckedCreateWithoutComicInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput copyWith(
          {Input$ComicBookmarkWhereUniqueInput? where,
          Input$ComicBookmarkUncheckedUpdateWithoutComicInput? update,
          Input$ComicBookmarkUncheckedCreateWithoutComicInput? create}) =>
      Input$ComicBookmarkUpsertWithWhereUniqueWithoutComicInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput {
  Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ComicBookmarkWhereUniqueInput where;

  final Input$ComicBookmarkUncheckedUpdateWithoutUserInput update;

  final Input$ComicBookmarkUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ComicBookmarkWhereUniqueInput? where,
          Input$ComicBookmarkUncheckedUpdateWithoutUserInput? update,
          Input$ComicBookmarkUncheckedCreateWithoutUserInput? create}) =>
      Input$ComicBookmarkUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkWhereInput {
  Input$ComicBookmarkWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.comicId,
      this.comic,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicBookmarkWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicBookmarkWhereInputFromJson(json);

  final List<Input$ComicBookmarkWhereInput?>? AND;

  final List<Input$ComicBookmarkWhereInput?>? OR;

  final List<Input$ComicBookmarkWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$IntFilter? comicId;

  final Input$ComicWhereInput? comic;

  final Input$IntFilter? userId;

  final Input$UserWhereInput? user;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ComicBookmarkWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$comicId = comicId;
    final l$comic = comic;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$comicId,
      l$comic,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$comicId = comicId;
    final lOther$comicId = other.comicId;
    if (l$comicId != lOther$comicId) return false;
    final l$comic = comic;
    final lOther$comic = other.comic;
    if (l$comic != lOther$comic) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicBookmarkWhereInput copyWith(
          {List<Input$ComicBookmarkWhereInput?>? Function()? AND,
          List<Input$ComicBookmarkWhereInput?>? Function()? OR,
          List<Input$ComicBookmarkWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$IntFilter? Function()? comicId,
          Input$ComicWhereInput? Function()? comic,
          Input$IntFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ComicBookmarkWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          comicId: comicId == null ? this.comicId : comicId(),
          comic: comic == null ? this.comic : comic(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicBookmarkWhereUniqueInput {
  Input$ComicBookmarkWhereUniqueInput({this.id});

  @override
  factory Input$ComicBookmarkWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicBookmarkWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() =>
      _$Input$ComicBookmarkWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicBookmarkWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ComicBookmarkWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$ComicBookmarkWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCountOrderByAggregateInput {
  Input$ComicCountOrderByAggregateInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId});

  @override
  factory Input$ComicCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumb;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumbWide;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? altName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? released;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? description;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? age;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? concept;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastChapterUpdateAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? thumb,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? thumbWide,
          Enum$SortOrder? Function()? altName,
          Enum$SortOrder? Function()? isHentai,
          Enum$SortOrder? Function()? released,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? description,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? age,
          Enum$SortOrder? Function()? concept,
          Enum$SortOrder? Function()? lastChapterUpdateAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? authorId}) =>
      Input$ComicCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateInput {
  Input$ComicCreateInput(
      {required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      required this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicCreateInputFromJson(json);

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final Input$AuthorCreateNestedOneWithoutComicsInput author;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChapterCreateNestedManyWithoutComicInput? chapters;

  final Input$GenreCreateNestedManyWithoutComicsInput? genres;

  final Input$ComicBookmarkCreateNestedManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() => _$Input$ComicCreateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicCreateInput copyWith(
          {String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          Input$AuthorCreateNestedOneWithoutComicsInput? author,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChapterCreateNestedManyWithoutComicInput? Function()? chapters,
          Input$GenreCreateNestedManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkCreateNestedManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicCreateInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author,
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateManyAuthorInput {
  Input$ComicCreateManyAuthorInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicCreateManyAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateManyAuthorInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateManyAuthorInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateManyAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicCreateManyAuthorInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ComicCreateManyAuthorInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateManyAuthorInputEnvelope {
  Input$ComicCreateManyAuthorInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ComicCreateManyAuthorInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateManyAuthorInputEnvelopeFromJson(json);

  final Input$ComicCreateManyAuthorInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateManyAuthorInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateManyAuthorInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ComicCreateManyAuthorInputEnvelope copyWith(
          {Input$ComicCreateManyAuthorInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ComicCreateManyAuthorInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateManyInput {
  Input$ComicCreateManyInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      required this.authorId});

  @override
  factory Input$ComicCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicCreateManyInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final int authorId;

  Map<String, dynamic> toJson() => _$Input$ComicCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicCreateManyInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? authorId}) =>
      Input$ComicCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateNestedManyWithoutAuthorInput {
  Input$ComicCreateNestedManyWithoutAuthorInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ComicCreateNestedManyWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateNestedManyWithoutAuthorInputFromJson(json);

  final List<Input$ComicCreateWithoutAuthorInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutAuthorInput?>? connectOrCreate;

  final Input$ComicCreateManyAuthorInputEnvelope? createMany;

  final List<Input$ComicWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateNestedManyWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateNestedManyWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicCreateNestedManyWithoutAuthorInput copyWith(
          {List<Input$ComicCreateWithoutAuthorInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutAuthorInput?>? Function()?
              connectOrCreate,
          Input$ComicCreateManyAuthorInputEnvelope? Function()? createMany,
          List<Input$ComicWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicCreateNestedManyWithoutAuthorInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateNestedManyWithoutGenresInput {
  Input$ComicCreateNestedManyWithoutGenresInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ComicCreateNestedManyWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateNestedManyWithoutGenresInputFromJson(json);

  final List<Input$ComicCreateWithoutGenresInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutGenresInput?>? connectOrCreate;

  final List<Input$ComicWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateNestedManyWithoutGenresInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateNestedManyWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicCreateNestedManyWithoutGenresInput copyWith(
          {List<Input$ComicCreateWithoutGenresInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutGenresInput?>? Function()?
              connectOrCreate,
          List<Input$ComicWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicCreateNestedManyWithoutGenresInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateNestedOneWithoutChaptersInput {
  Input$ComicCreateNestedOneWithoutChaptersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ComicCreateNestedOneWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateNestedOneWithoutChaptersInputFromJson(json);

  final Input$ComicUncheckedCreateWithoutChaptersInput? create;

  final Input$ComicCreateOrConnectWithoutChaptersInput? connectOrCreate;

  final Input$ComicWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateNestedOneWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateNestedOneWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ComicCreateNestedOneWithoutChaptersInput copyWith(
          {Input$ComicUncheckedCreateWithoutChaptersInput? Function()? create,
          Input$ComicCreateOrConnectWithoutChaptersInput? Function()?
              connectOrCreate,
          Input$ComicWhereUniqueInput? Function()? connect}) =>
      Input$ComicCreateNestedOneWithoutChaptersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateNestedOneWithoutUserbookmarksInput {
  Input$ComicCreateNestedOneWithoutUserbookmarksInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ComicCreateNestedOneWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateNestedOneWithoutUserbookmarksInputFromJson(json);

  final Input$ComicUncheckedCreateWithoutUserbookmarksInput? create;

  final Input$ComicCreateOrConnectWithoutUserbookmarksInput? connectOrCreate;

  final Input$ComicWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateNestedOneWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateNestedOneWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$ComicCreateNestedOneWithoutUserbookmarksInput copyWith(
          {Input$ComicUncheckedCreateWithoutUserbookmarksInput? Function()?
              create,
          Input$ComicCreateOrConnectWithoutUserbookmarksInput? Function()?
              connectOrCreate,
          Input$ComicWhereUniqueInput? Function()? connect}) =>
      Input$ComicCreateNestedOneWithoutUserbookmarksInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateOrConnectWithoutAuthorInput {
  Input$ComicCreateOrConnectWithoutAuthorInput(
      {required this.where, required this.create});

  @override
  factory Input$ComicCreateOrConnectWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateOrConnectWithoutAuthorInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedCreateWithoutAuthorInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateOrConnectWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateOrConnectWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicCreateOrConnectWithoutAuthorInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedCreateWithoutAuthorInput? create}) =>
      Input$ComicCreateOrConnectWithoutAuthorInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateOrConnectWithoutChaptersInput {
  Input$ComicCreateOrConnectWithoutChaptersInput(
      {required this.where, required this.create});

  @override
  factory Input$ComicCreateOrConnectWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateOrConnectWithoutChaptersInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedCreateWithoutChaptersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateOrConnectWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateOrConnectWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicCreateOrConnectWithoutChaptersInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedCreateWithoutChaptersInput? create}) =>
      Input$ComicCreateOrConnectWithoutChaptersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateOrConnectWithoutGenresInput {
  Input$ComicCreateOrConnectWithoutGenresInput(
      {required this.where, required this.create});

  @override
  factory Input$ComicCreateOrConnectWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateOrConnectWithoutGenresInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedCreateWithoutGenresInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateOrConnectWithoutGenresInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateOrConnectWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicCreateOrConnectWithoutGenresInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedCreateWithoutGenresInput? create}) =>
      Input$ComicCreateOrConnectWithoutGenresInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateOrConnectWithoutUserbookmarksInput {
  Input$ComicCreateOrConnectWithoutUserbookmarksInput(
      {required this.where, required this.create});

  @override
  factory Input$ComicCreateOrConnectWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateOrConnectWithoutUserbookmarksInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedCreateWithoutUserbookmarksInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateOrConnectWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateOrConnectWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicCreateOrConnectWithoutUserbookmarksInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedCreateWithoutUserbookmarksInput? create}) =>
      Input$ComicCreateOrConnectWithoutUserbookmarksInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateWithoutAuthorInput {
  Input$ComicCreateWithoutAuthorInput(
      {required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicCreateWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateWithoutAuthorInputFromJson(json);

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChapterCreateNestedManyWithoutComicInput? chapters;

  final Input$GenreCreateNestedManyWithoutComicsInput? genres;

  final Input$ComicBookmarkCreateNestedManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicCreateWithoutAuthorInput copyWith(
          {String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChapterCreateNestedManyWithoutComicInput? Function()? chapters,
          Input$GenreCreateNestedManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkCreateNestedManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicCreateWithoutAuthorInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateWithoutChaptersInput {
  Input$ComicCreateWithoutChaptersInput(
      {required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      required this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicCreateWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateWithoutChaptersInputFromJson(json);

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final Input$AuthorCreateNestedOneWithoutComicsInput author;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$GenreCreateNestedManyWithoutComicsInput? genres;

  final Input$ComicBookmarkCreateNestedManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicCreateWithoutChaptersInput copyWith(
          {String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          Input$AuthorCreateNestedOneWithoutComicsInput? author,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$GenreCreateNestedManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkCreateNestedManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicCreateWithoutChaptersInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author,
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateWithoutGenresInput {
  Input$ComicCreateWithoutGenresInput(
      {required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      required this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.userbookmarks});

  @override
  factory Input$ComicCreateWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateWithoutGenresInputFromJson(json);

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final Input$AuthorCreateNestedOneWithoutComicsInput author;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChapterCreateNestedManyWithoutComicInput? chapters;

  final Input$ComicBookmarkCreateNestedManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateWithoutGenresInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicCreateWithoutGenresInput copyWith(
          {String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          Input$AuthorCreateNestedOneWithoutComicsInput? author,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChapterCreateNestedManyWithoutComicInput? Function()? chapters,
          Input$ComicBookmarkCreateNestedManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicCreateWithoutGenresInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author,
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicCreateWithoutUserbookmarksInput {
  Input$ComicCreateWithoutUserbookmarksInput(
      {required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      required this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres});

  @override
  factory Input$ComicCreateWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicCreateWithoutUserbookmarksInputFromJson(json);

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final Input$AuthorCreateNestedOneWithoutComicsInput author;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChapterCreateNestedManyWithoutComicInput? chapters;

  final Input$GenreCreateNestedManyWithoutComicsInput? genres;

  Map<String, dynamic> toJson() =>
      _$Input$ComicCreateWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicCreateWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    return true;
  }

  Input$ComicCreateWithoutUserbookmarksInput copyWith(
          {String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          Input$AuthorCreateNestedOneWithoutComicsInput? author,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChapterCreateNestedManyWithoutComicInput? Function()? chapters,
          Input$GenreCreateNestedManyWithoutComicsInput? Function()? genres}) =>
      Input$ComicCreateWithoutUserbookmarksInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author,
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicListRelationFilter {
  Input$ComicListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ComicListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicListRelationFilterFromJson(json);

  final Input$ComicWhereInput? every;

  final Input$ComicWhereInput? some;

  final Input$ComicWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$ComicListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ComicListRelationFilter copyWith(
          {Input$ComicWhereInput? Function()? every,
          Input$ComicWhereInput? Function()? some,
          Input$ComicWhereInput? Function()? none}) =>
      Input$ComicListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicMaxOrderByAggregateInput {
  Input$ComicMaxOrderByAggregateInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId});

  @override
  factory Input$ComicMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumb;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumbWide;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? released;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? description;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? age;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? concept;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastChapterUpdateAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? thumb,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? thumbWide,
          Enum$SortOrder? Function()? isHentai,
          Enum$SortOrder? Function()? released,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? description,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? age,
          Enum$SortOrder? Function()? concept,
          Enum$SortOrder? Function()? lastChapterUpdateAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? authorId}) =>
      Input$ComicMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicMinOrderByAggregateInput {
  Input$ComicMinOrderByAggregateInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId});

  @override
  factory Input$ComicMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumb;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumbWide;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? released;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? description;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? age;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? concept;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastChapterUpdateAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? thumb,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? thumbWide,
          Enum$SortOrder? Function()? isHentai,
          Enum$SortOrder? Function()? released,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? description,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? age,
          Enum$SortOrder? Function()? concept,
          Enum$SortOrder? Function()? lastChapterUpdateAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? authorId}) =>
      Input$ComicMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicOrderByRelationAggregateInput {
  Input$ComicOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ComicOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ComicOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ComicOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ComicOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicOrderByWithAggregationInput {
  Input$ComicOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ComicOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumb;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumbWide;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? altName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? released;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? description;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? age;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? concept;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastChapterUpdateAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  @JsonKey(name: '_count')
  final Input$ComicCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ComicAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ComicMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ComicMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ComicSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ComicOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ComicOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? thumb,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? thumbWide,
          Enum$SortOrder? Function()? altName,
          Enum$SortOrder? Function()? isHentai,
          Enum$SortOrder? Function()? released,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? description,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? age,
          Enum$SortOrder? Function()? concept,
          Enum$SortOrder? Function()? lastChapterUpdateAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? authorId,
          Input$ComicCountOrderByAggregateInput? Function()? $_count,
          Input$ComicAvgOrderByAggregateInput? Function()? $_avg,
          Input$ComicMaxOrderByAggregateInput? Function()? $_max,
          Input$ComicMinOrderByAggregateInput? Function()? $_min,
          Input$ComicSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ComicOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicOrderByWithRelationInput {
  Input$ComicOrderByWithRelationInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumb;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? type;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? thumbWide;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? altName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? released;

  final Input$AuthorOrderByWithRelationInput? author;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? description;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? status;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? age;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? concept;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? lastChapterUpdateAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  final Input$ChapterOrderByRelationAggregateInput? chapters;

  final Input$GenreOrderByRelationAggregateInput? genres;

  final Input$ComicBookmarkOrderByRelationAggregateInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? thumb,
          Enum$SortOrder? Function()? type,
          Enum$SortOrder? Function()? thumbWide,
          Enum$SortOrder? Function()? altName,
          Enum$SortOrder? Function()? isHentai,
          Enum$SortOrder? Function()? released,
          Input$AuthorOrderByWithRelationInput? Function()? author,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? description,
          Enum$SortOrder? Function()? status,
          Enum$SortOrder? Function()? age,
          Enum$SortOrder? Function()? concept,
          Enum$SortOrder? Function()? lastChapterUpdateAt,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Enum$SortOrder? Function()? authorId,
          Input$ChapterOrderByRelationAggregateInput? Function()? chapters,
          Input$GenreOrderByRelationAggregateInput? Function()? genres,
          Input$ComicBookmarkOrderByRelationAggregateInput? Function()?
              userbookmarks}) =>
      Input$ComicOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicRelationFilter {
  Input$ComicRelationFilter({this.$is, this.isNot});

  @override
  factory Input$ComicRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$ComicWhereInput? $is;

  final Input$ComicWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$ComicRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$ComicRelationFilter copyWith(
          {Input$ComicWhereInput? Function()? $is,
          Input$ComicWhereInput? Function()? isNot}) =>
      Input$ComicRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicScalarWhereInput {
  Input$ComicScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId});

  @override
  factory Input$ComicScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicScalarWhereInputFromJson(json);

  final List<Input$ComicScalarWhereInput?>? AND;

  final List<Input$ComicScalarWhereInput?>? OR;

  final List<Input$ComicScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? slug;

  final Input$StringFilter? thumb;

  final Input$StringFilter? type;

  final Input$StringNullableFilter? thumbWide;

  final Input$JsonNullableFilter? altName;

  final Input$BoolFilter? isHentai;

  final Input$DateTimeFilter? released;

  final Input$FloatFilter? rating;

  final Input$IntFilter? views;

  final Input$IntFilter? viewsHourly;

  final Input$IntFilter? viewsDaily;

  final Input$IntFilter? viewsWeek;

  final Input$StringNullableFilter? description;

  final Input$StringNullableFilter? status;

  final Input$StringNullableFilter? age;

  final Input$StringNullableFilter? concept;

  final Input$DateTimeFilter? lastChapterUpdateAt;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$IntFilter? authorId;

  Map<String, dynamic> toJson() => _$Input$ComicScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicScalarWhereInput copyWith(
          {List<Input$ComicScalarWhereInput?>? Function()? AND,
          List<Input$ComicScalarWhereInput?>? Function()? OR,
          List<Input$ComicScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? slug,
          Input$StringFilter? Function()? thumb,
          Input$StringFilter? Function()? type,
          Input$StringNullableFilter? Function()? thumbWide,
          Input$JsonNullableFilter? Function()? altName,
          Input$BoolFilter? Function()? isHentai,
          Input$DateTimeFilter? Function()? released,
          Input$FloatFilter? Function()? rating,
          Input$IntFilter? Function()? views,
          Input$IntFilter? Function()? viewsHourly,
          Input$IntFilter? Function()? viewsDaily,
          Input$IntFilter? Function()? viewsWeek,
          Input$StringNullableFilter? Function()? description,
          Input$StringNullableFilter? Function()? status,
          Input$StringNullableFilter? Function()? age,
          Input$StringNullableFilter? Function()? concept,
          Input$DateTimeFilter? Function()? lastChapterUpdateAt,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$IntFilter? Function()? authorId}) =>
      Input$ComicScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicScalarWhereWithAggregatesInput {
  Input$ComicScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId});

  @override
  factory Input$ComicScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ComicScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ComicScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ComicScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? slug;

  final Input$StringWithAggregatesFilter? thumb;

  final Input$StringWithAggregatesFilter? type;

  final Input$StringNullableWithAggregatesFilter? thumbWide;

  final Input$JsonNullableWithAggregatesFilter? altName;

  final Input$BoolWithAggregatesFilter? isHentai;

  final Input$DateTimeWithAggregatesFilter? released;

  final Input$FloatWithAggregatesFilter? rating;

  final Input$IntWithAggregatesFilter? views;

  final Input$IntWithAggregatesFilter? viewsHourly;

  final Input$IntWithAggregatesFilter? viewsDaily;

  final Input$IntWithAggregatesFilter? viewsWeek;

  final Input$StringNullableWithAggregatesFilter? description;

  final Input$StringNullableWithAggregatesFilter? status;

  final Input$StringNullableWithAggregatesFilter? age;

  final Input$StringNullableWithAggregatesFilter? concept;

  final Input$DateTimeWithAggregatesFilter? lastChapterUpdateAt;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  final Input$IntWithAggregatesFilter? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicScalarWhereWithAggregatesInput copyWith(
          {List<Input$ComicScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$ComicScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ComicScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? slug,
          Input$StringWithAggregatesFilter? Function()? thumb,
          Input$StringWithAggregatesFilter? Function()? type,
          Input$StringNullableWithAggregatesFilter? Function()? thumbWide,
          Input$JsonNullableWithAggregatesFilter? Function()? altName,
          Input$BoolWithAggregatesFilter? Function()? isHentai,
          Input$DateTimeWithAggregatesFilter? Function()? released,
          Input$FloatWithAggregatesFilter? Function()? rating,
          Input$IntWithAggregatesFilter? Function()? views,
          Input$IntWithAggregatesFilter? Function()? viewsHourly,
          Input$IntWithAggregatesFilter? Function()? viewsDaily,
          Input$IntWithAggregatesFilter? Function()? viewsWeek,
          Input$StringNullableWithAggregatesFilter? Function()? description,
          Input$StringNullableWithAggregatesFilter? Function()? status,
          Input$StringNullableWithAggregatesFilter? Function()? age,
          Input$StringNullableWithAggregatesFilter? Function()? concept,
          Input$DateTimeWithAggregatesFilter? Function()? lastChapterUpdateAt,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt,
          Input$IntWithAggregatesFilter? Function()? authorId}) =>
      Input$ComicScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicSumOrderByAggregateInput {
  Input$ComicSumOrderByAggregateInput(
      {this.id,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.authorId});

  @override
  factory Input$ComicSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? rating;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? views;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsHourly;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsDaily;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? viewsWeek;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? rating,
          Enum$SortOrder? Function()? views,
          Enum$SortOrder? Function()? viewsHourly,
          Enum$SortOrder? Function()? viewsDaily,
          Enum$SortOrder? Function()? viewsWeek,
          Enum$SortOrder? Function()? authorId}) =>
      Input$ComicSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateInput {
  Input$ComicUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      required this.authorId,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final int authorId;

  final Input$ChapterUncheckedCreateNestedManyWithoutComicInput? chapters;

  final Input$GenreUncheckedCreateNestedManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
      userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? authorId,
          Input$ChapterUncheckedCreateNestedManyWithoutComicInput? Function()?
              chapters,
          Input$GenreUncheckedCreateNestedManyWithoutComicsInput? Function()?
              genres,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
                  Function()?
              userbookmarks}) =>
      Input$ComicUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId,
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateNestedManyWithoutAuthorInput {
  Input$ComicUncheckedCreateNestedManyWithoutAuthorInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ComicUncheckedCreateNestedManyWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateNestedManyWithoutAuthorInputFromJson(json);

  final List<Input$ComicCreateWithoutAuthorInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutAuthorInput?>? connectOrCreate;

  final Input$ComicCreateManyAuthorInputEnvelope? createMany;

  final List<Input$ComicWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateNestedManyWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateNestedManyWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicUncheckedCreateNestedManyWithoutAuthorInput copyWith(
          {List<Input$ComicCreateWithoutAuthorInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutAuthorInput?>? Function()?
              connectOrCreate,
          Input$ComicCreateManyAuthorInputEnvelope? Function()? createMany,
          List<Input$ComicWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicUncheckedCreateNestedManyWithoutAuthorInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateNestedManyWithoutGenresInput {
  Input$ComicUncheckedCreateNestedManyWithoutGenresInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$ComicUncheckedCreateNestedManyWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateNestedManyWithoutGenresInputFromJson(json);

  final List<Input$ComicCreateWithoutGenresInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutGenresInput?>? connectOrCreate;

  final List<Input$ComicWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateNestedManyWithoutGenresInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateNestedManyWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ComicUncheckedCreateNestedManyWithoutGenresInput copyWith(
          {List<Input$ComicCreateWithoutGenresInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutGenresInput?>? Function()?
              connectOrCreate,
          List<Input$ComicWhereUniqueInput?>? Function()? connect}) =>
      Input$ComicUncheckedCreateNestedManyWithoutGenresInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateWithoutAuthorInput {
  Input$ComicUncheckedCreateWithoutAuthorInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedCreateWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateWithoutAuthorInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final Input$ChapterUncheckedCreateNestedManyWithoutComicInput? chapters;

  final Input$GenreUncheckedCreateNestedManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
      userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedCreateWithoutAuthorInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ChapterUncheckedCreateNestedManyWithoutComicInput? Function()?
              chapters,
          Input$GenreUncheckedCreateNestedManyWithoutComicsInput? Function()?
              genres,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
                  Function()?
              userbookmarks}) =>
      Input$ComicUncheckedCreateWithoutAuthorInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateWithoutChaptersInput {
  Input$ComicUncheckedCreateWithoutChaptersInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      required this.authorId,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedCreateWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateWithoutChaptersInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final int authorId;

  final Input$GenreUncheckedCreateNestedManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
      userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedCreateWithoutChaptersInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? authorId,
          Input$GenreUncheckedCreateNestedManyWithoutComicsInput? Function()?
              genres,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
                  Function()?
              userbookmarks}) =>
      Input$ComicUncheckedCreateWithoutChaptersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId,
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateWithoutGenresInput {
  Input$ComicUncheckedCreateWithoutGenresInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      required this.authorId,
      this.chapters,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedCreateWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateWithoutGenresInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final int authorId;

  final Input$ChapterUncheckedCreateNestedManyWithoutComicInput? chapters;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
      userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateWithoutGenresInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedCreateWithoutGenresInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? authorId,
          Input$ChapterUncheckedCreateNestedManyWithoutComicInput? Function()?
              chapters,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutComicInput?
                  Function()?
              userbookmarks}) =>
      Input$ComicUncheckedCreateWithoutGenresInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId,
          chapters: chapters == null ? this.chapters : chapters(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedCreateWithoutUserbookmarksInput {
  Input$ComicUncheckedCreateWithoutUserbookmarksInput(
      {this.id,
      required this.name,
      required this.slug,
      required this.thumb,
      required this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      required this.authorId,
      this.chapters,
      this.genres});

  @override
  factory Input$ComicUncheckedCreateWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedCreateWithoutUserbookmarksInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String thumb;

  final String type;

  final String? thumbWide;

  final String? altName;

  final bool? isHentai;

  final String? released;

  final double? rating;

  final int? views;

  final int? viewsHourly;

  final int? viewsDaily;

  final int? viewsWeek;

  final String? description;

  final String? status;

  final String? age;

  final String? concept;

  final String? lastChapterUpdateAt;

  final String? createdAt;

  final String? updatedAt;

  final int authorId;

  final Input$ChapterUncheckedCreateNestedManyWithoutComicInput? chapters;

  final Input$GenreUncheckedCreateNestedManyWithoutComicsInput? genres;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedCreateWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$genres = genres;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$genres
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedCreateWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    return true;
  }

  Input$ComicUncheckedCreateWithoutUserbookmarksInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? thumb,
          String? type,
          String? Function()? thumbWide,
          String? Function()? altName,
          bool? Function()? isHentai,
          String? Function()? released,
          double? Function()? rating,
          int? Function()? views,
          int? Function()? viewsHourly,
          int? Function()? viewsDaily,
          int? Function()? viewsWeek,
          String? Function()? description,
          String? Function()? status,
          String? Function()? age,
          String? Function()? concept,
          String? Function()? lastChapterUpdateAt,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          int? authorId,
          Input$ChapterUncheckedCreateNestedManyWithoutComicInput? Function()?
              chapters,
          Input$GenreUncheckedCreateNestedManyWithoutComicsInput? Function()?
              genres}) =>
      Input$ComicUncheckedCreateWithoutUserbookmarksInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          thumb: thumb == null ? this.thumb : thumb,
          type: type == null ? this.type : type,
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId,
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateInput {
  Input$ComicUncheckedUpdateInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? authorId;

  final Input$ChapterUncheckedUpdateManyWithoutComicInput? chapters;

  final Input$GenreUncheckedUpdateManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? authorId,
          Input$ChapterUncheckedUpdateManyWithoutComicInput? Function()?
              chapters,
          Input$GenreUncheckedUpdateManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateManyInput {
  Input$ComicUncheckedUpdateManyInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId});

  @override
  factory Input$ComicUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? authorId;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    return true;
  }

  Input$ComicUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? authorId}) =>
      Input$ComicUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateManyWithoutAuthorInput {
  Input$ComicUncheckedUpdateManyWithoutAuthorInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicUncheckedUpdateManyWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateManyWithoutAuthorInputFromJson(json);

  final List<Input$ComicCreateWithoutAuthorInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutAuthorInput?>? connectOrCreate;

  final List<Input$ComicUpsertWithWhereUniqueWithoutAuthorInput?>? upsert;

  final Input$ComicCreateManyAuthorInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ComicWhereUniqueInput?>? $set;

  final List<Input$ComicWhereUniqueInput?>? disconnect;

  final List<Input$ComicWhereUniqueInput?>? delete;

  final List<Input$ComicWhereUniqueInput?>? connect;

  final List<Input$ComicUpdateWithWhereUniqueWithoutAuthorInput?>? update;

  final List<Input$ComicUpdateManyWithWhereWithoutAuthorInput?>? updateMany;

  final List<Input$ComicScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateManyWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateManyWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicUncheckedUpdateManyWithoutAuthorInput copyWith(
          {List<Input$ComicCreateWithoutAuthorInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutAuthorInput?>? Function()?
              connectOrCreate,
          List<Input$ComicUpsertWithWhereUniqueWithoutAuthorInput?>? Function()?
              upsert,
          Input$ComicCreateManyAuthorInputEnvelope? Function()? createMany,
          List<Input$ComicWhereUniqueInput?>? Function()? $set,
          List<Input$ComicWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicWhereUniqueInput?>? Function()? delete,
          List<Input$ComicWhereUniqueInput?>? Function()? connect,
          List<Input$ComicUpdateWithWhereUniqueWithoutAuthorInput?>? Function()?
              update,
          List<Input$ComicUpdateManyWithWhereWithoutAuthorInput?>? Function()?
              updateMany,
          List<Input$ComicScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ComicUncheckedUpdateManyWithoutAuthorInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateManyWithoutComicsInput {
  Input$ComicUncheckedUpdateManyWithoutComicsInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicUncheckedUpdateManyWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateManyWithoutComicsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateManyWithoutComicsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateManyWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicUncheckedUpdateManyWithoutComicsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicUncheckedUpdateManyWithoutComicsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateManyWithoutGenresInput {
  Input$ComicUncheckedUpdateManyWithoutGenresInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicUncheckedUpdateManyWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateManyWithoutGenresInputFromJson(json);

  final List<Input$ComicCreateWithoutGenresInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutGenresInput?>? connectOrCreate;

  final List<Input$ComicUpsertWithWhereUniqueWithoutGenresInput?>? upsert;

  @JsonKey(name: 'set')
  final List<Input$ComicWhereUniqueInput?>? $set;

  final List<Input$ComicWhereUniqueInput?>? disconnect;

  final List<Input$ComicWhereUniqueInput?>? delete;

  final List<Input$ComicWhereUniqueInput?>? connect;

  final List<Input$ComicUpdateWithWhereUniqueWithoutGenresInput?>? update;

  final List<Input$ComicUpdateManyWithWhereWithoutGenresInput?>? updateMany;

  final List<Input$ComicScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateManyWithoutGenresInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateManyWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicUncheckedUpdateManyWithoutGenresInput copyWith(
          {List<Input$ComicCreateWithoutGenresInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutGenresInput?>? Function()?
              connectOrCreate,
          List<Input$ComicUpsertWithWhereUniqueWithoutGenresInput?>? Function()?
              upsert,
          List<Input$ComicWhereUniqueInput?>? Function()? $set,
          List<Input$ComicWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicWhereUniqueInput?>? Function()? delete,
          List<Input$ComicWhereUniqueInput?>? Function()? connect,
          List<Input$ComicUpdateWithWhereUniqueWithoutGenresInput?>? Function()?
              update,
          List<Input$ComicUpdateManyWithWhereWithoutGenresInput?>? Function()?
              updateMany,
          List<Input$ComicScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ComicUncheckedUpdateManyWithoutGenresInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateWithoutAuthorInput {
  Input$ComicUncheckedUpdateWithoutAuthorInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedUpdateWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateWithoutAuthorInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChapterUncheckedUpdateManyWithoutComicInput? chapters;

  final Input$GenreUncheckedUpdateManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedUpdateWithoutAuthorInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChapterUncheckedUpdateManyWithoutComicInput? Function()?
              chapters,
          Input$GenreUncheckedUpdateManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUncheckedUpdateWithoutAuthorInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateWithoutChaptersInput {
  Input$ComicUncheckedUpdateWithoutChaptersInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedUpdateWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateWithoutChaptersInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? authorId;

  final Input$GenreUncheckedUpdateManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedUpdateWithoutChaptersInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? authorId,
          Input$GenreUncheckedUpdateManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUncheckedUpdateWithoutChaptersInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateWithoutGenresInput {
  Input$ComicUncheckedUpdateWithoutGenresInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.chapters,
      this.userbookmarks});

  @override
  factory Input$ComicUncheckedUpdateWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateWithoutGenresInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? authorId;

  final Input$ChapterUncheckedUpdateManyWithoutComicInput? chapters;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateWithoutGenresInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUncheckedUpdateWithoutGenresInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? authorId,
          Input$ChapterUncheckedUpdateManyWithoutComicInput? Function()?
              chapters,
          Input$ComicBookmarkUncheckedUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUncheckedUpdateWithoutGenresInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          chapters: chapters == null ? this.chapters : chapters(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUncheckedUpdateWithoutUserbookmarksInput {
  Input$ComicUncheckedUpdateWithoutUserbookmarksInput(
      {this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.chapters,
      this.genres});

  @override
  factory Input$ComicUncheckedUpdateWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUncheckedUpdateWithoutUserbookmarksInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$IntFieldUpdateOperationsInput? authorId;

  final Input$ChapterUncheckedUpdateManyWithoutComicInput? chapters;

  final Input$GenreUncheckedUpdateManyWithoutComicsInput? genres;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUncheckedUpdateWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$genres = genres;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$genres
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUncheckedUpdateWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    return true;
  }

  Input$ComicUncheckedUpdateWithoutUserbookmarksInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$IntFieldUpdateOperationsInput? Function()? authorId,
          Input$ChapterUncheckedUpdateManyWithoutComicInput? Function()?
              chapters,
          Input$GenreUncheckedUpdateManyWithoutComicsInput? Function()?
              genres}) =>
      Input$ComicUncheckedUpdateWithoutUserbookmarksInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateInput {
  Input$ComicUpdateInput(
      {this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$AuthorUpdateOneRequiredWithoutComicsInput? author;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChapterUpdateManyWithoutComicInput? chapters;

  final Input$GenreUpdateManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() => _$Input$ComicUpdateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$AuthorUpdateOneRequiredWithoutComicsInput? Function()? author,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChapterUpdateManyWithoutComicInput? Function()? chapters,
          Input$GenreUpdateManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUpdateInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateManyMutationInput {
  Input$ComicUpdateManyMutationInput(
      {this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ComicUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ComicUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ComicUpdateManyMutationInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateManyWithoutAuthorInput {
  Input$ComicUpdateManyWithoutAuthorInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicUpdateManyWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateManyWithoutAuthorInputFromJson(json);

  final List<Input$ComicCreateWithoutAuthorInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutAuthorInput?>? connectOrCreate;

  final List<Input$ComicUpsertWithWhereUniqueWithoutAuthorInput?>? upsert;

  final Input$ComicCreateManyAuthorInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ComicWhereUniqueInput?>? $set;

  final List<Input$ComicWhereUniqueInput?>? disconnect;

  final List<Input$ComicWhereUniqueInput?>? delete;

  final List<Input$ComicWhereUniqueInput?>? connect;

  final List<Input$ComicUpdateWithWhereUniqueWithoutAuthorInput?>? update;

  final List<Input$ComicUpdateManyWithWhereWithoutAuthorInput?>? updateMany;

  final List<Input$ComicScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateManyWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateManyWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicUpdateManyWithoutAuthorInput copyWith(
          {List<Input$ComicCreateWithoutAuthorInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutAuthorInput?>? Function()?
              connectOrCreate,
          List<Input$ComicUpsertWithWhereUniqueWithoutAuthorInput?>? Function()?
              upsert,
          Input$ComicCreateManyAuthorInputEnvelope? Function()? createMany,
          List<Input$ComicWhereUniqueInput?>? Function()? $set,
          List<Input$ComicWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicWhereUniqueInput?>? Function()? delete,
          List<Input$ComicWhereUniqueInput?>? Function()? connect,
          List<Input$ComicUpdateWithWhereUniqueWithoutAuthorInput?>? Function()?
              update,
          List<Input$ComicUpdateManyWithWhereWithoutAuthorInput?>? Function()?
              updateMany,
          List<Input$ComicScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ComicUpdateManyWithoutAuthorInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateManyWithoutGenresInput {
  Input$ComicUpdateManyWithoutGenresInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ComicUpdateManyWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateManyWithoutGenresInputFromJson(json);

  final List<Input$ComicCreateWithoutGenresInput?>? create;

  final List<Input$ComicCreateOrConnectWithoutGenresInput?>? connectOrCreate;

  final List<Input$ComicUpsertWithWhereUniqueWithoutGenresInput?>? upsert;

  @JsonKey(name: 'set')
  final List<Input$ComicWhereUniqueInput?>? $set;

  final List<Input$ComicWhereUniqueInput?>? disconnect;

  final List<Input$ComicWhereUniqueInput?>? delete;

  final List<Input$ComicWhereUniqueInput?>? connect;

  final List<Input$ComicUpdateWithWhereUniqueWithoutGenresInput?>? update;

  final List<Input$ComicUpdateManyWithWhereWithoutGenresInput?>? updateMany;

  final List<Input$ComicScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateManyWithoutGenresInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateManyWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ComicUpdateManyWithoutGenresInput copyWith(
          {List<Input$ComicCreateWithoutGenresInput?>? Function()? create,
          List<Input$ComicCreateOrConnectWithoutGenresInput?>? Function()?
              connectOrCreate,
          List<Input$ComicUpsertWithWhereUniqueWithoutGenresInput?>? Function()?
              upsert,
          List<Input$ComicWhereUniqueInput?>? Function()? $set,
          List<Input$ComicWhereUniqueInput?>? Function()? disconnect,
          List<Input$ComicWhereUniqueInput?>? Function()? delete,
          List<Input$ComicWhereUniqueInput?>? Function()? connect,
          List<Input$ComicUpdateWithWhereUniqueWithoutGenresInput?>? Function()?
              update,
          List<Input$ComicUpdateManyWithWhereWithoutGenresInput?>? Function()?
              updateMany,
          List<Input$ComicScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ComicUpdateManyWithoutGenresInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateManyWithWhereWithoutAuthorInput {
  Input$ComicUpdateManyWithWhereWithoutAuthorInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicUpdateManyWithWhereWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateManyWithWhereWithoutAuthorInputFromJson(json);

  final Input$ComicScalarWhereInput where;

  final Input$ComicUncheckedUpdateManyWithoutComicsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateManyWithWhereWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateManyWithWhereWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicUpdateManyWithWhereWithoutAuthorInput copyWith(
          {Input$ComicScalarWhereInput? where,
          Input$ComicUncheckedUpdateManyWithoutComicsInput? data}) =>
      Input$ComicUpdateManyWithWhereWithoutAuthorInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateManyWithWhereWithoutGenresInput {
  Input$ComicUpdateManyWithWhereWithoutGenresInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicUpdateManyWithWhereWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateManyWithWhereWithoutGenresInputFromJson(json);

  final Input$ComicScalarWhereInput where;

  final Input$ComicUncheckedUpdateManyWithoutComicsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateManyWithWhereWithoutGenresInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateManyWithWhereWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicUpdateManyWithWhereWithoutGenresInput copyWith(
          {Input$ComicScalarWhereInput? where,
          Input$ComicUncheckedUpdateManyWithoutComicsInput? data}) =>
      Input$ComicUpdateManyWithWhereWithoutGenresInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateOneRequiredWithoutChaptersInput {
  Input$ComicUpdateOneRequiredWithoutChaptersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ComicUpdateOneRequiredWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateOneRequiredWithoutChaptersInputFromJson(json);

  final Input$ComicUncheckedCreateWithoutChaptersInput? create;

  final Input$ComicCreateOrConnectWithoutChaptersInput? connectOrCreate;

  final Input$ComicUpsertWithoutChaptersInput? upsert;

  final Input$ComicWhereUniqueInput? connect;

  final Input$ComicUncheckedUpdateWithoutChaptersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateOneRequiredWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateOneRequiredWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ComicUpdateOneRequiredWithoutChaptersInput copyWith(
          {Input$ComicUncheckedCreateWithoutChaptersInput? Function()? create,
          Input$ComicCreateOrConnectWithoutChaptersInput? Function()?
              connectOrCreate,
          Input$ComicUpsertWithoutChaptersInput? Function()? upsert,
          Input$ComicWhereUniqueInput? Function()? connect,
          Input$ComicUncheckedUpdateWithoutChaptersInput? Function()?
              update}) =>
      Input$ComicUpdateOneRequiredWithoutChaptersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateOneRequiredWithoutUserbookmarksInput {
  Input$ComicUpdateOneRequiredWithoutUserbookmarksInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$ComicUpdateOneRequiredWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateOneRequiredWithoutUserbookmarksInputFromJson(json);

  final Input$ComicUncheckedCreateWithoutUserbookmarksInput? create;

  final Input$ComicCreateOrConnectWithoutUserbookmarksInput? connectOrCreate;

  final Input$ComicUpsertWithoutUserbookmarksInput? upsert;

  final Input$ComicWhereUniqueInput? connect;

  final Input$ComicUncheckedUpdateWithoutUserbookmarksInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateOneRequiredWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateOneRequiredWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$ComicUpdateOneRequiredWithoutUserbookmarksInput copyWith(
          {Input$ComicUncheckedCreateWithoutUserbookmarksInput? Function()?
              create,
          Input$ComicCreateOrConnectWithoutUserbookmarksInput? Function()?
              connectOrCreate,
          Input$ComicUpsertWithoutUserbookmarksInput? Function()? upsert,
          Input$ComicWhereUniqueInput? Function()? connect,
          Input$ComicUncheckedUpdateWithoutUserbookmarksInput? Function()?
              update}) =>
      Input$ComicUpdateOneRequiredWithoutUserbookmarksInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateWithoutAuthorInput {
  Input$ComicUpdateWithoutAuthorInput(
      {this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUpdateWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateWithoutAuthorInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChapterUpdateManyWithoutComicInput? chapters;

  final Input$GenreUpdateManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUpdateWithoutAuthorInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChapterUpdateManyWithoutComicInput? Function()? chapters,
          Input$GenreUpdateManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUpdateWithoutAuthorInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateWithoutChaptersInput {
  Input$ComicUpdateWithoutChaptersInput(
      {this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicUpdateWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateWithoutChaptersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$AuthorUpdateOneRequiredWithoutComicsInput? author;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$GenreUpdateManyWithoutComicsInput? genres;

  final Input$ComicBookmarkUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUpdateWithoutChaptersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$AuthorUpdateOneRequiredWithoutComicsInput? Function()? author,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$GenreUpdateManyWithoutComicsInput? Function()? genres,
          Input$ComicBookmarkUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUpdateWithoutChaptersInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateWithoutGenresInput {
  Input$ComicUpdateWithoutGenresInput(
      {this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.userbookmarks});

  @override
  factory Input$ComicUpdateWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateWithoutGenresInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$AuthorUpdateOneRequiredWithoutComicsInput? author;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChapterUpdateManyWithoutComicInput? chapters;

  final Input$ComicBookmarkUpdateManyWithoutComicInput? userbookmarks;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateWithoutGenresInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicUpdateWithoutGenresInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$AuthorUpdateOneRequiredWithoutComicsInput? Function()? author,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChapterUpdateManyWithoutComicInput? Function()? chapters,
          Input$ComicBookmarkUpdateManyWithoutComicInput? Function()?
              userbookmarks}) =>
      Input$ComicUpdateWithoutGenresInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateWithoutUserbookmarksInput {
  Input$ComicUpdateWithoutUserbookmarksInput(
      {this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.chapters,
      this.genres});

  @override
  factory Input$ComicUpdateWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateWithoutUserbookmarksInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$StringFieldUpdateOperationsInput? thumb;

  final Input$StringFieldUpdateOperationsInput? type;

  final Input$NullableStringFieldUpdateOperationsInput? thumbWide;

  final String? altName;

  final Input$BoolFieldUpdateOperationsInput? isHentai;

  final Input$DateTimeFieldUpdateOperationsInput? released;

  final Input$AuthorUpdateOneRequiredWithoutComicsInput? author;

  final Input$FloatFieldUpdateOperationsInput? rating;

  final Input$IntFieldUpdateOperationsInput? views;

  final Input$IntFieldUpdateOperationsInput? viewsHourly;

  final Input$IntFieldUpdateOperationsInput? viewsDaily;

  final Input$IntFieldUpdateOperationsInput? viewsWeek;

  final Input$NullableStringFieldUpdateOperationsInput? description;

  final Input$NullableStringFieldUpdateOperationsInput? status;

  final Input$NullableStringFieldUpdateOperationsInput? age;

  final Input$NullableStringFieldUpdateOperationsInput? concept;

  final Input$DateTimeFieldUpdateOperationsInput? lastChapterUpdateAt;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ChapterUpdateManyWithoutComicInput? chapters;

  final Input$GenreUpdateManyWithoutComicsInput? genres;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$chapters = chapters;
    final l$genres = genres;
    return Object.hashAll([
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$chapters,
      l$genres
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    return true;
  }

  Input$ComicUpdateWithoutUserbookmarksInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$StringFieldUpdateOperationsInput? Function()? thumb,
          Input$StringFieldUpdateOperationsInput? Function()? type,
          Input$NullableStringFieldUpdateOperationsInput? Function()? thumbWide,
          String? Function()? altName,
          Input$BoolFieldUpdateOperationsInput? Function()? isHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? released,
          Input$AuthorUpdateOneRequiredWithoutComicsInput? Function()? author,
          Input$FloatFieldUpdateOperationsInput? Function()? rating,
          Input$IntFieldUpdateOperationsInput? Function()? views,
          Input$IntFieldUpdateOperationsInput? Function()? viewsHourly,
          Input$IntFieldUpdateOperationsInput? Function()? viewsDaily,
          Input$IntFieldUpdateOperationsInput? Function()? viewsWeek,
          Input$NullableStringFieldUpdateOperationsInput? Function()?
              description,
          Input$NullableStringFieldUpdateOperationsInput? Function()? status,
          Input$NullableStringFieldUpdateOperationsInput? Function()? age,
          Input$NullableStringFieldUpdateOperationsInput? Function()? concept,
          Input$DateTimeFieldUpdateOperationsInput? Function()?
              lastChapterUpdateAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ChapterUpdateManyWithoutComicInput? Function()? chapters,
          Input$GenreUpdateManyWithoutComicsInput? Function()? genres}) =>
      Input$ComicUpdateWithoutUserbookmarksInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateWithWhereUniqueWithoutAuthorInput {
  Input$ComicUpdateWithWhereUniqueWithoutAuthorInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicUpdateWithWhereUniqueWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateWithWhereUniqueWithoutAuthorInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedUpdateWithoutAuthorInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateWithWhereUniqueWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateWithWhereUniqueWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicUpdateWithWhereUniqueWithoutAuthorInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedUpdateWithoutAuthorInput? data}) =>
      Input$ComicUpdateWithWhereUniqueWithoutAuthorInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpdateWithWhereUniqueWithoutGenresInput {
  Input$ComicUpdateWithWhereUniqueWithoutGenresInput(
      {required this.where, required this.data});

  @override
  factory Input$ComicUpdateWithWhereUniqueWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpdateWithWhereUniqueWithoutGenresInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedUpdateWithoutGenresInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpdateWithWhereUniqueWithoutGenresInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpdateWithWhereUniqueWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ComicUpdateWithWhereUniqueWithoutGenresInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedUpdateWithoutGenresInput? data}) =>
      Input$ComicUpdateWithWhereUniqueWithoutGenresInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpsertWithoutChaptersInput {
  Input$ComicUpsertWithoutChaptersInput(
      {required this.update, required this.create});

  @override
  factory Input$ComicUpsertWithoutChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpsertWithoutChaptersInputFromJson(json);

  final Input$ComicUncheckedUpdateWithoutChaptersInput update;

  final Input$ComicUncheckedCreateWithoutChaptersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpsertWithoutChaptersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpsertWithoutChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicUpsertWithoutChaptersInput copyWith(
          {Input$ComicUncheckedUpdateWithoutChaptersInput? update,
          Input$ComicUncheckedCreateWithoutChaptersInput? create}) =>
      Input$ComicUpsertWithoutChaptersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpsertWithoutUserbookmarksInput {
  Input$ComicUpsertWithoutUserbookmarksInput(
      {required this.update, required this.create});

  @override
  factory Input$ComicUpsertWithoutUserbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpsertWithoutUserbookmarksInputFromJson(json);

  final Input$ComicUncheckedUpdateWithoutUserbookmarksInput update;

  final Input$ComicUncheckedCreateWithoutUserbookmarksInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpsertWithoutUserbookmarksInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpsertWithoutUserbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicUpsertWithoutUserbookmarksInput copyWith(
          {Input$ComicUncheckedUpdateWithoutUserbookmarksInput? update,
          Input$ComicUncheckedCreateWithoutUserbookmarksInput? create}) =>
      Input$ComicUpsertWithoutUserbookmarksInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpsertWithWhereUniqueWithoutAuthorInput {
  Input$ComicUpsertWithWhereUniqueWithoutAuthorInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ComicUpsertWithWhereUniqueWithoutAuthorInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpsertWithWhereUniqueWithoutAuthorInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedUpdateWithoutAuthorInput update;

  final Input$ComicUncheckedCreateWithoutAuthorInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpsertWithWhereUniqueWithoutAuthorInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpsertWithWhereUniqueWithoutAuthorInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicUpsertWithWhereUniqueWithoutAuthorInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedUpdateWithoutAuthorInput? update,
          Input$ComicUncheckedCreateWithoutAuthorInput? create}) =>
      Input$ComicUpsertWithWhereUniqueWithoutAuthorInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicUpsertWithWhereUniqueWithoutGenresInput {
  Input$ComicUpsertWithWhereUniqueWithoutGenresInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ComicUpsertWithWhereUniqueWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ComicUpsertWithWhereUniqueWithoutGenresInputFromJson(json);

  final Input$ComicWhereUniqueInput where;

  final Input$ComicUncheckedUpdateWithoutGenresInput update;

  final Input$ComicUncheckedCreateWithoutGenresInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ComicUpsertWithWhereUniqueWithoutGenresInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicUpsertWithWhereUniqueWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ComicUpsertWithWhereUniqueWithoutGenresInput copyWith(
          {Input$ComicWhereUniqueInput? where,
          Input$ComicUncheckedUpdateWithoutGenresInput? update,
          Input$ComicUncheckedCreateWithoutGenresInput? create}) =>
      Input$ComicUpsertWithWhereUniqueWithoutGenresInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ComicWhereInput {
  Input$ComicWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.thumb,
      this.type,
      this.thumbWide,
      this.altName,
      this.isHentai,
      this.released,
      this.author,
      this.rating,
      this.views,
      this.viewsHourly,
      this.viewsDaily,
      this.viewsWeek,
      this.description,
      this.status,
      this.age,
      this.concept,
      this.lastChapterUpdateAt,
      this.createdAt,
      this.updatedAt,
      this.authorId,
      this.chapters,
      this.genres,
      this.userbookmarks});

  @override
  factory Input$ComicWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicWhereInputFromJson(json);

  final List<Input$ComicWhereInput?>? AND;

  final List<Input$ComicWhereInput?>? OR;

  final List<Input$ComicWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? slug;

  final Input$StringFilter? thumb;

  final Input$StringFilter? type;

  final Input$StringNullableFilter? thumbWide;

  final Input$JsonNullableFilter? altName;

  final Input$BoolFilter? isHentai;

  final Input$DateTimeFilter? released;

  final Input$AuthorWhereInput? author;

  final Input$FloatFilter? rating;

  final Input$IntFilter? views;

  final Input$IntFilter? viewsHourly;

  final Input$IntFilter? viewsDaily;

  final Input$IntFilter? viewsWeek;

  final Input$StringNullableFilter? description;

  final Input$StringNullableFilter? status;

  final Input$StringNullableFilter? age;

  final Input$StringNullableFilter? concept;

  final Input$DateTimeFilter? lastChapterUpdateAt;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$IntFilter? authorId;

  final Input$ChapterListRelationFilter? chapters;

  final Input$GenreListRelationFilter? genres;

  final Input$ComicBookmarkListRelationFilter? userbookmarks;

  Map<String, dynamic> toJson() => _$Input$ComicWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$thumb = thumb;
    final l$type = type;
    final l$thumbWide = thumbWide;
    final l$altName = altName;
    final l$isHentai = isHentai;
    final l$released = released;
    final l$author = author;
    final l$rating = rating;
    final l$views = views;
    final l$viewsHourly = viewsHourly;
    final l$viewsDaily = viewsDaily;
    final l$viewsWeek = viewsWeek;
    final l$description = description;
    final l$status = status;
    final l$age = age;
    final l$concept = concept;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$authorId = authorId;
    final l$chapters = chapters;
    final l$genres = genres;
    final l$userbookmarks = userbookmarks;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$thumb,
      l$type,
      l$thumbWide,
      l$altName,
      l$isHentai,
      l$released,
      l$author,
      l$rating,
      l$views,
      l$viewsHourly,
      l$viewsDaily,
      l$viewsWeek,
      l$description,
      l$status,
      l$age,
      l$concept,
      l$lastChapterUpdateAt,
      l$createdAt,
      l$updatedAt,
      l$authorId,
      l$chapters,
      l$genres,
      l$userbookmarks
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$thumb = thumb;
    final lOther$thumb = other.thumb;
    if (l$thumb != lOther$thumb) return false;
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) return false;
    final l$thumbWide = thumbWide;
    final lOther$thumbWide = other.thumbWide;
    if (l$thumbWide != lOther$thumbWide) return false;
    final l$altName = altName;
    final lOther$altName = other.altName;
    if (l$altName != lOther$altName) return false;
    final l$isHentai = isHentai;
    final lOther$isHentai = other.isHentai;
    if (l$isHentai != lOther$isHentai) return false;
    final l$released = released;
    final lOther$released = other.released;
    if (l$released != lOther$released) return false;
    final l$author = author;
    final lOther$author = other.author;
    if (l$author != lOther$author) return false;
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) return false;
    final l$views = views;
    final lOther$views = other.views;
    if (l$views != lOther$views) return false;
    final l$viewsHourly = viewsHourly;
    final lOther$viewsHourly = other.viewsHourly;
    if (l$viewsHourly != lOther$viewsHourly) return false;
    final l$viewsDaily = viewsDaily;
    final lOther$viewsDaily = other.viewsDaily;
    if (l$viewsDaily != lOther$viewsDaily) return false;
    final l$viewsWeek = viewsWeek;
    final lOther$viewsWeek = other.viewsWeek;
    if (l$viewsWeek != lOther$viewsWeek) return false;
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) return false;
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) return false;
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) return false;
    final l$concept = concept;
    final lOther$concept = other.concept;
    if (l$concept != lOther$concept) return false;
    final l$lastChapterUpdateAt = lastChapterUpdateAt;
    final lOther$lastChapterUpdateAt = other.lastChapterUpdateAt;
    if (l$lastChapterUpdateAt != lOther$lastChapterUpdateAt) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$authorId = authorId;
    final lOther$authorId = other.authorId;
    if (l$authorId != lOther$authorId) return false;
    final l$chapters = chapters;
    final lOther$chapters = other.chapters;
    if (l$chapters != lOther$chapters) return false;
    final l$genres = genres;
    final lOther$genres = other.genres;
    if (l$genres != lOther$genres) return false;
    final l$userbookmarks = userbookmarks;
    final lOther$userbookmarks = other.userbookmarks;
    if (l$userbookmarks != lOther$userbookmarks) return false;
    return true;
  }

  Input$ComicWhereInput copyWith(
          {List<Input$ComicWhereInput?>? Function()? AND,
          List<Input$ComicWhereInput?>? Function()? OR,
          List<Input$ComicWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? slug,
          Input$StringFilter? Function()? thumb,
          Input$StringFilter? Function()? type,
          Input$StringNullableFilter? Function()? thumbWide,
          Input$JsonNullableFilter? Function()? altName,
          Input$BoolFilter? Function()? isHentai,
          Input$DateTimeFilter? Function()? released,
          Input$AuthorWhereInput? Function()? author,
          Input$FloatFilter? Function()? rating,
          Input$IntFilter? Function()? views,
          Input$IntFilter? Function()? viewsHourly,
          Input$IntFilter? Function()? viewsDaily,
          Input$IntFilter? Function()? viewsWeek,
          Input$StringNullableFilter? Function()? description,
          Input$StringNullableFilter? Function()? status,
          Input$StringNullableFilter? Function()? age,
          Input$StringNullableFilter? Function()? concept,
          Input$DateTimeFilter? Function()? lastChapterUpdateAt,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$IntFilter? Function()? authorId,
          Input$ChapterListRelationFilter? Function()? chapters,
          Input$GenreListRelationFilter? Function()? genres,
          Input$ComicBookmarkListRelationFilter? Function()? userbookmarks}) =>
      Input$ComicWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          thumb: thumb == null ? this.thumb : thumb(),
          type: type == null ? this.type : type(),
          thumbWide: thumbWide == null ? this.thumbWide : thumbWide(),
          altName: altName == null ? this.altName : altName(),
          isHentai: isHentai == null ? this.isHentai : isHentai(),
          released: released == null ? this.released : released(),
          author: author == null ? this.author : author(),
          rating: rating == null ? this.rating : rating(),
          views: views == null ? this.views : views(),
          viewsHourly: viewsHourly == null ? this.viewsHourly : viewsHourly(),
          viewsDaily: viewsDaily == null ? this.viewsDaily : viewsDaily(),
          viewsWeek: viewsWeek == null ? this.viewsWeek : viewsWeek(),
          description: description == null ? this.description : description(),
          status: status == null ? this.status : status(),
          age: age == null ? this.age : age(),
          concept: concept == null ? this.concept : concept(),
          lastChapterUpdateAt: lastChapterUpdateAt == null
              ? this.lastChapterUpdateAt
              : lastChapterUpdateAt(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          authorId: authorId == null ? this.authorId : authorId(),
          chapters: chapters == null ? this.chapters : chapters(),
          genres: genres == null ? this.genres : genres(),
          userbookmarks:
              userbookmarks == null ? this.userbookmarks : userbookmarks());
}

@JsonSerializable(explicitToJson: true)
class Input$ComicWhereUniqueInput {
  Input$ComicWhereUniqueInput({this.id, this.name, this.slug});

  @override
  factory Input$ComicWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ComicWhereUniqueInputFromJson(json);

  final int? id;

  final String? name;

  final String? slug;

  Map<String, dynamic> toJson() => _$Input$ComicWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    return Object.hashAll([l$id, l$name, l$slug]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ComicWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    return true;
  }

  Input$ComicWhereUniqueInput copyWith(
          {int? Function()? id,
          String? Function()? name,
          String? Function()? slug}) =>
      Input$ComicWhereUniqueInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeFieldUpdateOperationsInput {
  Input$DateTimeFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$DateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$DateTimeFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$DateTimeFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$DateTimeFieldUpdateOperationsInput copyWith(
          {String? Function()? $set}) =>
      Input$DateTimeFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeFilter {
  Input$DateTimeFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$DateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$DateTimeFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeFilter? not;

  Map<String, dynamic> toJson() => _$Input$DateTimeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$DateTimeFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeFilter? Function()? not}) =>
      Input$DateTimeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$DateTimeWithAggregatesFilter {
  Input$DateTimeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$DateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$DateTimeWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedDateTimeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedDateTimeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$DateTimeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$DateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$DateTimeWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedDateTimeFilter? Function()? $_min,
          Input$NestedDateTimeFilter? Function()? $_max}) =>
      Input$DateTimeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumAdsPositionNullableListFilter {
  Input$EnumAdsPositionNullableListFilter(
      {this.equals, this.has, this.hasEvery, this.hasSome, this.isEmpty});

  @override
  factory Input$EnumAdsPositionNullableListFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumAdsPositionNullableListFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? equals;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final Enum$AdsPosition? has;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? hasEvery;

  @JsonKey(unknownEnumValue: Enum$AdsPosition.$unknown)
  final List<Enum$AdsPosition?>? hasSome;

  final bool? isEmpty;

  Map<String, dynamic> toJson() =>
      _$Input$EnumAdsPositionNullableListFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$has = has;
    final l$hasEvery = hasEvery;
    final l$hasSome = hasSome;
    final l$isEmpty = isEmpty;
    return Object.hashAll([
      l$equals == null ? null : Object.hashAll(l$equals.map((v) => v)),
      l$has,
      l$hasEvery == null ? null : Object.hashAll(l$hasEvery.map((v) => v)),
      l$hasSome == null ? null : Object.hashAll(l$hasSome.map((v) => v)),
      l$isEmpty
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumAdsPositionNullableListFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != null && lOther$equals != null) {
      if (l$equals.length != lOther$equals.length) return false;
      for (int i = 0; i < l$equals.length; i++) {
        final l$equals$entry = l$equals[i];
        final lOther$equals$entry = lOther$equals[i];
        if (l$equals$entry != lOther$equals$entry) return false;
      }
    } else if (l$equals != lOther$equals) {
      return false;
    }

    final l$has = has;
    final lOther$has = other.has;
    if (l$has != lOther$has) return false;
    final l$hasEvery = hasEvery;
    final lOther$hasEvery = other.hasEvery;
    if (l$hasEvery != null && lOther$hasEvery != null) {
      if (l$hasEvery.length != lOther$hasEvery.length) return false;
      for (int i = 0; i < l$hasEvery.length; i++) {
        final l$hasEvery$entry = l$hasEvery[i];
        final lOther$hasEvery$entry = lOther$hasEvery[i];
        if (l$hasEvery$entry != lOther$hasEvery$entry) return false;
      }
    } else if (l$hasEvery != lOther$hasEvery) {
      return false;
    }

    final l$hasSome = hasSome;
    final lOther$hasSome = other.hasSome;
    if (l$hasSome != null && lOther$hasSome != null) {
      if (l$hasSome.length != lOther$hasSome.length) return false;
      for (int i = 0; i < l$hasSome.length; i++) {
        final l$hasSome$entry = l$hasSome[i];
        final lOther$hasSome$entry = lOther$hasSome[i];
        if (l$hasSome$entry != lOther$hasSome$entry) return false;
      }
    } else if (l$hasSome != lOther$hasSome) {
      return false;
    }

    final l$isEmpty = isEmpty;
    final lOther$isEmpty = other.isEmpty;
    if (l$isEmpty != lOther$isEmpty) return false;
    return true;
  }

  Input$EnumAdsPositionNullableListFilter copyWith(
          {List<Enum$AdsPosition?>? Function()? equals,
          Enum$AdsPosition? Function()? has,
          List<Enum$AdsPosition?>? Function()? hasEvery,
          List<Enum$AdsPosition?>? Function()? hasSome,
          bool? Function()? isEmpty}) =>
      Input$EnumAdsPositionNullableListFilter(
          equals: equals == null ? this.equals : equals(),
          has: has == null ? this.has : has(),
          hasEvery: hasEvery == null ? this.hasEvery : hasEvery(),
          hasSome: hasSome == null ? this.hasSome : hasSome(),
          isEmpty: isEmpty == null ? this.isEmpty : isEmpty());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumChapterQualityFieldUpdateOperationsInput {
  Input$EnumChapterQualityFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$EnumChapterQualityFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumChapterQualityFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set', unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? $set;

  Map<String, dynamic> toJson() =>
      _$Input$EnumChapterQualityFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumChapterQualityFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$EnumChapterQualityFieldUpdateOperationsInput copyWith(
          {Enum$ChapterQuality? Function()? $set}) =>
      Input$EnumChapterQualityFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumChapterQualityFilter {
  Input$EnumChapterQualityFilter({this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$EnumChapterQualityFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$EnumChapterQualityFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? $in;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? notIn;

  final Input$NestedEnumChapterQualityFilter? not;

  Map<String, dynamic> toJson() => _$Input$EnumChapterQualityFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumChapterQualityFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$EnumChapterQualityFilter copyWith(
          {Enum$ChapterQuality? Function()? equals,
          List<Enum$ChapterQuality?>? Function()? $in,
          List<Enum$ChapterQuality?>? Function()? notIn,
          Input$NestedEnumChapterQualityFilter? Function()? not}) =>
      Input$EnumChapterQualityFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$EnumChapterQualityWithAggregatesFilter {
  Input$EnumChapterQualityWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$EnumChapterQualityWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$EnumChapterQualityWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? $in;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? notIn;

  final Input$NestedEnumChapterQualityWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumChapterQualityFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumChapterQualityFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$EnumChapterQualityWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$EnumChapterQualityWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$EnumChapterQualityWithAggregatesFilter copyWith(
          {Enum$ChapterQuality? Function()? equals,
          List<Enum$ChapterQuality?>? Function()? $in,
          List<Enum$ChapterQuality?>? Function()? notIn,
          Input$NestedEnumChapterQualityWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumChapterQualityFilter? Function()? $_min,
          Input$NestedEnumChapterQualityFilter? Function()? $_max}) =>
      Input$EnumChapterQualityWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$FloatFieldUpdateOperationsInput {
  Input$FloatFieldUpdateOperationsInput(
      {this.$set, this.increment, this.decrement, this.multiply, this.divide});

  @override
  factory Input$FloatFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$FloatFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final double? $set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  Map<String, dynamic> toJson() =>
      _$Input$FloatFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll(
        [l$$set, l$increment, l$decrement, l$multiply, l$divide]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$FloatFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (l$increment != lOther$increment) return false;
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (l$decrement != lOther$decrement) return false;
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (l$multiply != lOther$multiply) return false;
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (l$divide != lOther$divide) return false;
    return true;
  }

  Input$FloatFieldUpdateOperationsInput copyWith(
          {double? Function()? $set,
          double? Function()? increment,
          double? Function()? decrement,
          double? Function()? multiply,
          double? Function()? divide}) =>
      Input$FloatFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set(),
          increment: increment == null ? this.increment : increment(),
          decrement: decrement == null ? this.decrement : decrement(),
          multiply: multiply == null ? this.multiply : multiply(),
          divide: divide == null ? this.divide : divide());
}

@JsonSerializable(explicitToJson: true)
class Input$FloatFilter {
  Input$FloatFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$FloatFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$FloatFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatFilter? not;

  Map<String, dynamic> toJson() => _$Input$FloatFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$FloatFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$FloatFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatFilter? Function()? not}) =>
      Input$FloatFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$FloatWithAggregatesFilter {
  Input$FloatWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$FloatWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$FloatWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedFloatFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedFloatFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedFloatFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$FloatWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$FloatWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$FloatWithAggregatesFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedFloatFilter? Function()? $_sum,
          Input$NestedFloatFilter? Function()? $_min,
          Input$NestedFloatFilter? Function()? $_max}) =>
      Input$FloatWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreAvgOrderByAggregateInput {
  Input$GenreAvgOrderByAggregateInput({this.id});

  @override
  factory Input$GenreAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$GenreAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$GenreAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$GenreAvgOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreCountOrderByAggregateInput {
  Input$GenreCountOrderByAggregateInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$GenreCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreCreateInput {
  Input$GenreCreateInput(
      {required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$GenreCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreCreateInputFromJson(json);

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  final Input$ComicCreateNestedManyWithoutGenresInput? comics;

  Map<String, dynamic> toJson() => _$Input$GenreCreateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$GenreCreateInput copyWith(
          {String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ComicCreateNestedManyWithoutGenresInput? Function()? comics}) =>
      Input$GenreCreateInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreCreateManyInput {
  Input$GenreCreateManyInput(
      {this.id,
      required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$GenreCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreCreateManyInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$GenreCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreCreateManyInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$GenreCreateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreCreateNestedManyWithoutComicsInput {
  Input$GenreCreateNestedManyWithoutComicsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$GenreCreateNestedManyWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreCreateNestedManyWithoutComicsInputFromJson(json);

  final List<Input$GenreCreateWithoutComicsInput?>? create;

  final List<Input$GenreCreateOrConnectWithoutComicsInput?>? connectOrCreate;

  final List<Input$GenreWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$GenreCreateNestedManyWithoutComicsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreCreateNestedManyWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$GenreCreateNestedManyWithoutComicsInput copyWith(
          {List<Input$GenreCreateWithoutComicsInput?>? Function()? create,
          List<Input$GenreCreateOrConnectWithoutComicsInput?>? Function()?
              connectOrCreate,
          List<Input$GenreWhereUniqueInput?>? Function()? connect}) =>
      Input$GenreCreateNestedManyWithoutComicsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreCreateOrConnectWithoutComicsInput {
  Input$GenreCreateOrConnectWithoutComicsInput(
      {required this.where, required this.create});

  @override
  factory Input$GenreCreateOrConnectWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreCreateOrConnectWithoutComicsInputFromJson(json);

  final Input$GenreWhereUniqueInput where;

  final Input$GenreUncheckedCreateWithoutComicsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$GenreCreateOrConnectWithoutComicsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreCreateOrConnectWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$GenreCreateOrConnectWithoutComicsInput copyWith(
          {Input$GenreWhereUniqueInput? where,
          Input$GenreUncheckedCreateWithoutComicsInput? create}) =>
      Input$GenreCreateOrConnectWithoutComicsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$GenreCreateWithoutComicsInput {
  Input$GenreCreateWithoutComicsInput(
      {required this.name, required this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreCreateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreCreateWithoutComicsInputFromJson(json);

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreCreateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreCreateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreCreateWithoutComicsInput copyWith(
          {String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$GenreCreateWithoutComicsInput(
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreListRelationFilter {
  Input$GenreListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$GenreListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreListRelationFilterFromJson(json);

  final Input$GenreWhereInput? every;

  final Input$GenreWhereInput? some;

  final Input$GenreWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$GenreListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$GenreListRelationFilter copyWith(
          {Input$GenreWhereInput? Function()? every,
          Input$GenreWhereInput? Function()? some,
          Input$GenreWhereInput? Function()? none}) =>
      Input$GenreListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreMaxOrderByAggregateInput {
  Input$GenreMaxOrderByAggregateInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$GenreMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreMinOrderByAggregateInput {
  Input$GenreMinOrderByAggregateInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$GenreMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreOrderByRelationAggregateInput {
  Input$GenreOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$GenreOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$GenreOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$GenreOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$GenreOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreOrderByWithAggregationInput {
  Input$GenreOrderByWithAggregationInput(
      {this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$GenreOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$GenreCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$GenreAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$GenreMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$GenreMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$GenreSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$GenreOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$GenreOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$GenreCountOrderByAggregateInput? Function()? $_count,
          Input$GenreAvgOrderByAggregateInput? Function()? $_avg,
          Input$GenreMaxOrderByAggregateInput? Function()? $_max,
          Input$GenreMinOrderByAggregateInput? Function()? $_min,
          Input$GenreSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$GenreOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreOrderByWithRelationInput {
  Input$GenreOrderByWithRelationInput(
      {this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$GenreOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? slug;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ComicOrderByRelationAggregateInput? comics;

  Map<String, dynamic> toJson() =>
      _$Input$GenreOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll(
        [l$id, l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$GenreOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? slug,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ComicOrderByRelationAggregateInput? Function()? comics}) =>
      Input$GenreOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreScalarWhereInput {
  Input$GenreScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$GenreScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreScalarWhereInputFromJson(json);

  final List<Input$GenreScalarWhereInput?>? AND;

  final List<Input$GenreScalarWhereInput?>? OR;

  final List<Input$GenreScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? slug;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$GenreScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreScalarWhereInput copyWith(
          {List<Input$GenreScalarWhereInput?>? Function()? AND,
          List<Input$GenreScalarWhereInput?>? Function()? OR,
          List<Input$GenreScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? slug,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$GenreScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreScalarWhereWithAggregatesInput {
  Input$GenreScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$GenreScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$GenreScalarWhereWithAggregatesInput?>? AND;

  final List<Input$GenreScalarWhereWithAggregatesInput?>? OR;

  final List<Input$GenreScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringWithAggregatesFilter? slug;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreScalarWhereWithAggregatesInput copyWith(
          {List<Input$GenreScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$GenreScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$GenreScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringWithAggregatesFilter? Function()? slug,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$GenreScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreSumOrderByAggregateInput {
  Input$GenreSumOrderByAggregateInput({this.id});

  @override
  factory Input$GenreSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$GenreSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$GenreSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$GenreSumOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedCreateInput {
  Input$GenreUncheckedCreateInput(
      {this.id,
      required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$GenreUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreUncheckedCreateInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  final Input$ComicUncheckedCreateNestedManyWithoutGenresInput? comics;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll(
        [l$id, l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$GenreUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ComicUncheckedCreateNestedManyWithoutGenresInput? Function()?
              comics}) =>
      Input$GenreUncheckedCreateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedCreateNestedManyWithoutComicsInput {
  Input$GenreUncheckedCreateNestedManyWithoutComicsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$GenreUncheckedCreateNestedManyWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUncheckedCreateNestedManyWithoutComicsInputFromJson(json);

  final List<Input$GenreCreateWithoutComicsInput?>? create;

  final List<Input$GenreCreateOrConnectWithoutComicsInput?>? connectOrCreate;

  final List<Input$GenreWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedCreateNestedManyWithoutComicsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedCreateNestedManyWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$GenreUncheckedCreateNestedManyWithoutComicsInput copyWith(
          {List<Input$GenreCreateWithoutComicsInput?>? Function()? create,
          List<Input$GenreCreateOrConnectWithoutComicsInput?>? Function()?
              connectOrCreate,
          List<Input$GenreWhereUniqueInput?>? Function()? connect}) =>
      Input$GenreUncheckedCreateNestedManyWithoutComicsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedCreateWithoutComicsInput {
  Input$GenreUncheckedCreateWithoutComicsInput(
      {this.id,
      required this.name,
      required this.slug,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$GenreUncheckedCreateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUncheckedCreateWithoutComicsInputFromJson(json);

  final int? id;

  final String name;

  final String slug;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedCreateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedCreateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreUncheckedCreateWithoutComicsInput copyWith(
          {int? Function()? id,
          String? name,
          String? slug,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$GenreUncheckedCreateWithoutComicsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          slug: slug == null ? this.slug : slug,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedUpdateInput {
  Input$GenreUncheckedUpdateInput(
      {this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$GenreUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ComicUncheckedUpdateManyWithoutGenresInput? comics;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll(
        [l$id, l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$GenreUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ComicUncheckedUpdateManyWithoutGenresInput? Function()?
              comics}) =>
      Input$GenreUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedUpdateManyInput {
  Input$GenreUncheckedUpdateManyInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$GenreUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedUpdateManyWithoutComicsInput {
  Input$GenreUncheckedUpdateManyWithoutComicsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$GenreUncheckedUpdateManyWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUncheckedUpdateManyWithoutComicsInputFromJson(json);

  final List<Input$GenreCreateWithoutComicsInput?>? create;

  final List<Input$GenreCreateOrConnectWithoutComicsInput?>? connectOrCreate;

  final List<Input$GenreUpsertWithWhereUniqueWithoutComicsInput?>? upsert;

  @JsonKey(name: 'set')
  final List<Input$GenreWhereUniqueInput?>? $set;

  final List<Input$GenreWhereUniqueInput?>? disconnect;

  final List<Input$GenreWhereUniqueInput?>? delete;

  final List<Input$GenreWhereUniqueInput?>? connect;

  final List<Input$GenreUpdateWithWhereUniqueWithoutComicsInput?>? update;

  final List<Input$GenreUpdateManyWithWhereWithoutComicsInput?>? updateMany;

  final List<Input$GenreScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedUpdateManyWithoutComicsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedUpdateManyWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$GenreUncheckedUpdateManyWithoutComicsInput copyWith(
          {List<Input$GenreCreateWithoutComicsInput?>? Function()? create,
          List<Input$GenreCreateOrConnectWithoutComicsInput?>? Function()?
              connectOrCreate,
          List<Input$GenreUpsertWithWhereUniqueWithoutComicsInput?>? Function()?
              upsert,
          List<Input$GenreWhereUniqueInput?>? Function()? $set,
          List<Input$GenreWhereUniqueInput?>? Function()? disconnect,
          List<Input$GenreWhereUniqueInput?>? Function()? delete,
          List<Input$GenreWhereUniqueInput?>? Function()? connect,
          List<Input$GenreUpdateWithWhereUniqueWithoutComicsInput?>? Function()?
              update,
          List<Input$GenreUpdateManyWithWhereWithoutComicsInput?>? Function()?
              updateMany,
          List<Input$GenreScalarWhereInput?>? Function()? deleteMany}) =>
      Input$GenreUncheckedUpdateManyWithoutComicsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedUpdateManyWithoutGenresInput {
  Input$GenreUncheckedUpdateManyWithoutGenresInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreUncheckedUpdateManyWithoutGenresInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUncheckedUpdateManyWithoutGenresInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedUpdateManyWithoutGenresInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedUpdateManyWithoutGenresInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreUncheckedUpdateManyWithoutGenresInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$GenreUncheckedUpdateManyWithoutGenresInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUncheckedUpdateWithoutComicsInput {
  Input$GenreUncheckedUpdateWithoutComicsInput(
      {this.id, this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreUncheckedUpdateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUncheckedUpdateWithoutComicsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUncheckedUpdateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUncheckedUpdateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreUncheckedUpdateWithoutComicsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$GenreUncheckedUpdateWithoutComicsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpdateInput {
  Input$GenreUpdateInput(
      {this.name, this.slug, this.createdAt, this.updatedAt, this.comics});

  @override
  factory Input$GenreUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ComicUpdateManyWithoutGenresInput? comics;

  Map<String, dynamic> toJson() => _$Input$GenreUpdateInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt, l$comics]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$GenreUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ComicUpdateManyWithoutGenresInput? Function()? comics}) =>
      Input$GenreUpdateInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpdateManyMutationInput {
  Input$GenreUpdateManyMutationInput(
      {this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$GenreUpdateManyMutationInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpdateManyWithoutComicsInput {
  Input$GenreUpdateManyWithoutComicsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$GenreUpdateManyWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUpdateManyWithoutComicsInputFromJson(json);

  final List<Input$GenreCreateWithoutComicsInput?>? create;

  final List<Input$GenreCreateOrConnectWithoutComicsInput?>? connectOrCreate;

  final List<Input$GenreUpsertWithWhereUniqueWithoutComicsInput?>? upsert;

  @JsonKey(name: 'set')
  final List<Input$GenreWhereUniqueInput?>? $set;

  final List<Input$GenreWhereUniqueInput?>? disconnect;

  final List<Input$GenreWhereUniqueInput?>? delete;

  final List<Input$GenreWhereUniqueInput?>? connect;

  final List<Input$GenreUpdateWithWhereUniqueWithoutComicsInput?>? update;

  final List<Input$GenreUpdateManyWithWhereWithoutComicsInput?>? updateMany;

  final List<Input$GenreScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUpdateManyWithoutComicsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpdateManyWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$GenreUpdateManyWithoutComicsInput copyWith(
          {List<Input$GenreCreateWithoutComicsInput?>? Function()? create,
          List<Input$GenreCreateOrConnectWithoutComicsInput?>? Function()?
              connectOrCreate,
          List<Input$GenreUpsertWithWhereUniqueWithoutComicsInput?>? Function()?
              upsert,
          List<Input$GenreWhereUniqueInput?>? Function()? $set,
          List<Input$GenreWhereUniqueInput?>? Function()? disconnect,
          List<Input$GenreWhereUniqueInput?>? Function()? delete,
          List<Input$GenreWhereUniqueInput?>? Function()? connect,
          List<Input$GenreUpdateWithWhereUniqueWithoutComicsInput?>? Function()?
              update,
          List<Input$GenreUpdateManyWithWhereWithoutComicsInput?>? Function()?
              updateMany,
          List<Input$GenreScalarWhereInput?>? Function()? deleteMany}) =>
      Input$GenreUpdateManyWithoutComicsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpdateManyWithWhereWithoutComicsInput {
  Input$GenreUpdateManyWithWhereWithoutComicsInput(
      {required this.where, required this.data});

  @override
  factory Input$GenreUpdateManyWithWhereWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUpdateManyWithWhereWithoutComicsInputFromJson(json);

  final Input$GenreScalarWhereInput where;

  final Input$GenreUncheckedUpdateManyWithoutGenresInput data;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUpdateManyWithWhereWithoutComicsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpdateManyWithWhereWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$GenreUpdateManyWithWhereWithoutComicsInput copyWith(
          {Input$GenreScalarWhereInput? where,
          Input$GenreUncheckedUpdateManyWithoutGenresInput? data}) =>
      Input$GenreUpdateManyWithWhereWithoutComicsInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpdateWithoutComicsInput {
  Input$GenreUpdateWithoutComicsInput(
      {this.name, this.slug, this.createdAt, this.updatedAt});

  @override
  factory Input$GenreUpdateWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUpdateWithoutComicsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$StringFieldUpdateOperationsInput? slug;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUpdateWithoutComicsInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$name, l$slug, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpdateWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$GenreUpdateWithoutComicsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$StringFieldUpdateOperationsInput? Function()? slug,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$GenreUpdateWithoutComicsInput(
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpdateWithWhereUniqueWithoutComicsInput {
  Input$GenreUpdateWithWhereUniqueWithoutComicsInput(
      {required this.where, required this.data});

  @override
  factory Input$GenreUpdateWithWhereUniqueWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUpdateWithWhereUniqueWithoutComicsInputFromJson(json);

  final Input$GenreWhereUniqueInput where;

  final Input$GenreUncheckedUpdateWithoutComicsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUpdateWithWhereUniqueWithoutComicsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpdateWithWhereUniqueWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$GenreUpdateWithWhereUniqueWithoutComicsInput copyWith(
          {Input$GenreWhereUniqueInput? where,
          Input$GenreUncheckedUpdateWithoutComicsInput? data}) =>
      Input$GenreUpdateWithWhereUniqueWithoutComicsInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$GenreUpsertWithWhereUniqueWithoutComicsInput {
  Input$GenreUpsertWithWhereUniqueWithoutComicsInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$GenreUpsertWithWhereUniqueWithoutComicsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$GenreUpsertWithWhereUniqueWithoutComicsInputFromJson(json);

  final Input$GenreWhereUniqueInput where;

  final Input$GenreUncheckedUpdateWithoutComicsInput update;

  final Input$GenreUncheckedCreateWithoutComicsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$GenreUpsertWithWhereUniqueWithoutComicsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreUpsertWithWhereUniqueWithoutComicsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$GenreUpsertWithWhereUniqueWithoutComicsInput copyWith(
          {Input$GenreWhereUniqueInput? where,
          Input$GenreUncheckedUpdateWithoutComicsInput? update,
          Input$GenreUncheckedCreateWithoutComicsInput? create}) =>
      Input$GenreUpsertWithWhereUniqueWithoutComicsInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$GenreWhereInput {
  Input$GenreWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.name,
      this.slug,
      this.createdAt,
      this.updatedAt,
      this.comics});

  @override
  factory Input$GenreWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreWhereInputFromJson(json);

  final List<Input$GenreWhereInput?>? AND;

  final List<Input$GenreWhereInput?>? OR;

  final List<Input$GenreWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? name;

  final Input$StringFilter? slug;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ComicListRelationFilter? comics;

  Map<String, dynamic> toJson() => _$Input$GenreWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comics = comics;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$name,
      l$slug,
      l$createdAt,
      l$updatedAt,
      l$comics
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comics = comics;
    final lOther$comics = other.comics;
    if (l$comics != lOther$comics) return false;
    return true;
  }

  Input$GenreWhereInput copyWith(
          {List<Input$GenreWhereInput?>? Function()? AND,
          List<Input$GenreWhereInput?>? Function()? OR,
          List<Input$GenreWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? name,
          Input$StringFilter? Function()? slug,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ComicListRelationFilter? Function()? comics}) =>
      Input$GenreWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comics: comics == null ? this.comics : comics());
}

@JsonSerializable(explicitToJson: true)
class Input$GenreWhereUniqueInput {
  Input$GenreWhereUniqueInput({this.id, this.name, this.slug});

  @override
  factory Input$GenreWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$GenreWhereUniqueInputFromJson(json);

  final int? id;

  final String? name;

  final String? slug;

  Map<String, dynamic> toJson() => _$Input$GenreWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    return Object.hashAll([l$id, l$name, l$slug]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$GenreWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) return false;
    return true;
  }

  Input$GenreWhereUniqueInput copyWith(
          {int? Function()? id,
          String? Function()? name,
          String? Function()? slug}) =>
      Input$GenreWhereUniqueInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          slug: slug == null ? this.slug : slug());
}

@JsonSerializable(explicitToJson: true)
class Input$IntFieldUpdateOperationsInput {
  Input$IntFieldUpdateOperationsInput(
      {this.$set, this.increment, this.decrement, this.multiply, this.divide});

  @override
  factory Input$IntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IntFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final int? $set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  Map<String, dynamic> toJson() =>
      _$Input$IntFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll(
        [l$$set, l$increment, l$decrement, l$multiply, l$divide]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (l$increment != lOther$increment) return false;
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (l$decrement != lOther$decrement) return false;
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (l$multiply != lOther$multiply) return false;
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (l$divide != lOther$divide) return false;
    return true;
  }

  Input$IntFieldUpdateOperationsInput copyWith(
          {int? Function()? $set,
          int? Function()? increment,
          int? Function()? decrement,
          int? Function()? multiply,
          int? Function()? divide}) =>
      Input$IntFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set(),
          increment: increment == null ? this.increment : increment(),
          decrement: decrement == null ? this.decrement : decrement(),
          multiply: multiply == null ? this.multiply : multiply(),
          divide: divide == null ? this.divide : divide());
}

@JsonSerializable(explicitToJson: true)
class Input$IntFilter {
  Input$IntFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$IntFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntFilter? not;

  Map<String, dynamic> toJson() => _$Input$IntFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$IntFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntFilter? Function()? not}) =>
      Input$IntFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$IntNullableFilter {
  Input$IntNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$IntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$IntNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntNullableFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$IntNullableFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableFilter? Function()? not}) =>
      Input$IntNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$IntNullableWithAggregatesFilter {
  Input$IntNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$IntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$IntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatNullableFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntNullableFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$IntNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$IntNullableWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedFloatNullableFilter? Function()? $_avg,
          Input$NestedIntNullableFilter? Function()? $_sum,
          Input$NestedIntNullableFilter? Function()? $_min,
          Input$NestedIntNullableFilter? Function()? $_max}) =>
      Input$IntNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$IntWithAggregatesFilter {
  Input$IntWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$IntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$IntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntFilter? $_max;

  Map<String, dynamic> toJson() => _$Input$IntWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$IntWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$IntWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedIntFilter? Function()? $_sum,
          Input$NestedIntFilter? Function()? $_min,
          Input$NestedIntFilter? Function()? $_max}) =>
      Input$IntWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$JsonNullableFilter {
  Input$JsonNullableFilter({this.equals, this.not});

  @override
  factory Input$JsonNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$JsonNullableFilterFromJson(json);

  final String? equals;

  final String? not;

  Map<String, dynamic> toJson() => _$Input$JsonNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([l$equals, l$not]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$JsonNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$JsonNullableFilter copyWith(
          {String? Function()? equals, String? Function()? not}) =>
      Input$JsonNullableFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$JsonNullableWithAggregatesFilter {
  Input$JsonNullableWithAggregatesFilter(
      {this.equals, this.not, this.$_count, this.$_min, this.$_max});

  @override
  factory Input$JsonNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$JsonNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  final String? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedJsonNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedJsonNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$JsonNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([l$equals, l$not, l$$_count, l$$_min, l$$_max]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$JsonNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$JsonNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          String? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedJsonNullableFilter? Function()? $_min,
          Input$NestedJsonNullableFilter? Function()? $_max}) =>
      Input$JsonNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingAvgOrderByAggregateInput {
  Input$MissingAvgOrderByAggregateInput({this.id});

  @override
  factory Input$MissingAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$MissingAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$MissingAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$MissingAvgOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingCountOrderByAggregateInput {
  Input$MissingCountOrderByAggregateInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? data;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? context;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? data,
          Enum$SortOrder? Function()? context,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$MissingCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingCreateInput {
  Input$MissingCreateInput(
      {required this.data,
      required this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$MissingCreateInputFromJson(json);

  final String data;

  final String context;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$MissingCreateInputToJson(this);
  int get hashCode {
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingCreateInput copyWith(
          {String? data,
          String? context,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$MissingCreateInput(
          data: data == null ? this.data : data,
          context: context == null ? this.context : context,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingCreateManyInput {
  Input$MissingCreateManyInput(
      {this.id,
      required this.data,
      required this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$MissingCreateManyInputFromJson(json);

  final int? id;

  final String data;

  final String context;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$MissingCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingCreateManyInput copyWith(
          {int? Function()? id,
          String? data,
          String? context,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$MissingCreateManyInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data,
          context: context == null ? this.context : context,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingMaxOrderByAggregateInput {
  Input$MissingMaxOrderByAggregateInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? data;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? context;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? data,
          Enum$SortOrder? Function()? context,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$MissingMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingMinOrderByAggregateInput {
  Input$MissingMinOrderByAggregateInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? data;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? context;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? data,
          Enum$SortOrder? Function()? context,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$MissingMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingOrderByWithAggregationInput {
  Input$MissingOrderByWithAggregationInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$MissingOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? data;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? context;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$MissingCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$MissingAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$MissingMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$MissingMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$MissingSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$MissingOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$data,
      l$context,
      l$resolved,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$MissingOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? data,
          Enum$SortOrder? Function()? context,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$MissingCountOrderByAggregateInput? Function()? $_count,
          Input$MissingAvgOrderByAggregateInput? Function()? $_avg,
          Input$MissingMaxOrderByAggregateInput? Function()? $_max,
          Input$MissingMinOrderByAggregateInput? Function()? $_min,
          Input$MissingSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$MissingOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingOrderByWithRelationInput {
  Input$MissingOrderByWithRelationInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? data;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? context;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? data,
          Enum$SortOrder? Function()? context,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$MissingOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingScalarWhereWithAggregatesInput {
  Input$MissingScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$MissingScalarWhereWithAggregatesInput?>? AND;

  final List<Input$MissingScalarWhereWithAggregatesInput?>? OR;

  final List<Input$MissingScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? data;

  final Input$StringWithAggregatesFilter? context;

  final Input$BoolWithAggregatesFilter? resolved;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$data,
      l$context,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingScalarWhereWithAggregatesInput copyWith(
          {List<Input$MissingScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$MissingScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$MissingScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? data,
          Input$StringWithAggregatesFilter? Function()? context,
          Input$BoolWithAggregatesFilter? Function()? resolved,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$MissingScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingSumOrderByAggregateInput {
  Input$MissingSumOrderByAggregateInput({this.id});

  @override
  factory Input$MissingSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$MissingSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$MissingSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$MissingSumOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingUncheckedCreateInput {
  Input$MissingUncheckedCreateInput(
      {this.id,
      required this.data,
      required this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingUncheckedCreateInputFromJson(json);

  final int? id;

  final String data;

  final String context;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? data,
          String? context,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$MissingUncheckedCreateInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data,
          context: context == null ? this.context : context,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingUncheckedUpdateInput {
  Input$MissingUncheckedUpdateInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? data;

  final Input$StringFieldUpdateOperationsInput? context;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? data,
          Input$StringFieldUpdateOperationsInput? Function()? context,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$MissingUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingUncheckedUpdateManyInput {
  Input$MissingUncheckedUpdateManyInput(
      {this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? data;

  final Input$StringFieldUpdateOperationsInput? context;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? data,
          Input$StringFieldUpdateOperationsInput? Function()? context,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$MissingUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingUpdateInput {
  Input$MissingUpdateInput(
      {this.data, this.context, this.resolved, this.createdAt, this.updatedAt});

  @override
  factory Input$MissingUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$MissingUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? data;

  final Input$StringFieldUpdateOperationsInput? context;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$MissingUpdateInputToJson(this);
  int get hashCode {
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? data,
          Input$StringFieldUpdateOperationsInput? Function()? context,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$MissingUpdateInput(
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingUpdateManyMutationInput {
  Input$MissingUpdateManyMutationInput(
      {this.data, this.context, this.resolved, this.createdAt, this.updatedAt});

  @override
  factory Input$MissingUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$MissingUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? data;

  final Input$StringFieldUpdateOperationsInput? context;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$MissingUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$data, l$context, l$resolved, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? data,
          Input$StringFieldUpdateOperationsInput? Function()? context,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$MissingUpdateManyMutationInput(
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingWhereInput {
  Input$MissingWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.data,
      this.context,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$MissingWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$MissingWhereInputFromJson(json);

  final List<Input$MissingWhereInput?>? AND;

  final List<Input$MissingWhereInput?>? OR;

  final List<Input$MissingWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? data;

  final Input$StringFilter? context;

  final Input$BoolFilter? resolved;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$MissingWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$data = data;
    final l$context = context;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$data,
      l$context,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$MissingWhereInput copyWith(
          {List<Input$MissingWhereInput?>? Function()? AND,
          List<Input$MissingWhereInput?>? Function()? OR,
          List<Input$MissingWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? data,
          Input$StringFilter? Function()? context,
          Input$BoolFilter? Function()? resolved,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$MissingWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          data: data == null ? this.data : data(),
          context: context == null ? this.context : context(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$MissingWhereUniqueInput {
  Input$MissingWhereUniqueInput({this.id});

  @override
  factory Input$MissingWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$MissingWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() => _$Input$MissingWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$MissingWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$MissingWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$MissingWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedBoolFilter {
  Input$NestedBoolFilter({this.equals, this.not});

  @override
  factory Input$NestedBoolFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedBoolFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedBoolFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([l$equals, l$not]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedBoolFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedBoolFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolFilter? Function()? not}) =>
      Input$NestedBoolFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedBoolWithAggregatesFilter {
  Input$NestedBoolWithAggregatesFilter(
      {this.equals, this.not, this.$_count, this.$_min, this.$_max});

  @override
  factory Input$NestedBoolWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedBoolWithAggregatesFilterFromJson(json);

  final bool? equals;

  final Input$NestedBoolWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedBoolFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedBoolFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedBoolWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([l$equals, l$not, l$$_count, l$$_min, l$$_max]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedBoolWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedBoolWithAggregatesFilter copyWith(
          {bool? Function()? equals,
          Input$NestedBoolWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedBoolFilter? Function()? $_min,
          Input$NestedBoolFilter? Function()? $_max}) =>
      Input$NestedBoolWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedDateTimeFilter {
  Input$NestedDateTimeFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedDateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedDateTimeFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedDateTimeFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedDateTimeFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedDateTimeFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeFilter? Function()? not}) =>
      Input$NestedDateTimeFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedDateTimeWithAggregatesFilter {
  Input$NestedDateTimeWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedDateTimeWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final Input$NestedDateTimeWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedDateTimeFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedDateTimeFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedDateTimeWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedDateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedDateTimeWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          Input$NestedDateTimeWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedDateTimeFilter? Function()? $_min,
          Input$NestedDateTimeFilter? Function()? $_max}) =>
      Input$NestedDateTimeWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumChapterQualityFilter {
  Input$NestedEnumChapterQualityFilter(
      {this.equals, this.$in, this.notIn, this.not});

  @override
  factory Input$NestedEnumChapterQualityFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumChapterQualityFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? $in;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? notIn;

  final Input$NestedEnumChapterQualityFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumChapterQualityFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumChapterQualityFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedEnumChapterQualityFilter copyWith(
          {Enum$ChapterQuality? Function()? equals,
          List<Enum$ChapterQuality?>? Function()? $in,
          List<Enum$ChapterQuality?>? Function()? notIn,
          Input$NestedEnumChapterQualityFilter? Function()? not}) =>
      Input$NestedEnumChapterQualityFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedEnumChapterQualityWithAggregatesFilter {
  Input$NestedEnumChapterQualityWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedEnumChapterQualityWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedEnumChapterQualityWithAggregatesFilterFromJson(json);

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final Enum$ChapterQuality? equals;

  @JsonKey(name: 'in', unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? $in;

  @JsonKey(unknownEnumValue: Enum$ChapterQuality.$unknown)
  final List<Enum$ChapterQuality?>? notIn;

  final Input$NestedEnumChapterQualityWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedEnumChapterQualityFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedEnumChapterQualityFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedEnumChapterQualityWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedEnumChapterQualityWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedEnumChapterQualityWithAggregatesFilter copyWith(
          {Enum$ChapterQuality? Function()? equals,
          List<Enum$ChapterQuality?>? Function()? $in,
          List<Enum$ChapterQuality?>? Function()? notIn,
          Input$NestedEnumChapterQualityWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedEnumChapterQualityFilter? Function()? $_min,
          Input$NestedEnumChapterQualityFilter? Function()? $_max}) =>
      Input$NestedEnumChapterQualityWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedFloatFilter {
  Input$NestedFloatFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedFloatFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedFloatFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedFloatFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedFloatFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedFloatFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatFilter? Function()? not}) =>
      Input$NestedFloatFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedFloatNullableFilter {
  Input$NestedFloatNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedFloatNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedFloatNullableFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedFloatNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedFloatNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedFloatNullableFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatNullableFilter? Function()? not}) =>
      Input$NestedFloatNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedFloatWithAggregatesFilter {
  Input$NestedFloatWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedFloatWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedFloatWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: 'in')
  final List<double?>? $in;

  final List<double?>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final Input$NestedFloatWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedFloatFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedFloatFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedFloatFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedFloatWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedFloatWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedFloatWithAggregatesFilter copyWith(
          {double? Function()? equals,
          List<double?>? Function()? $in,
          List<double?>? Function()? notIn,
          double? Function()? lt,
          double? Function()? lte,
          double? Function()? gt,
          double? Function()? gte,
          Input$NestedFloatWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedFloatFilter? Function()? $_sum,
          Input$NestedFloatFilter? Function()? $_min,
          Input$NestedFloatFilter? Function()? $_max}) =>
      Input$NestedFloatWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntFilter {
  Input$NestedIntFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedIntFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedIntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedIntFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedIntFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntFilter? Function()? not}) =>
      Input$NestedIntFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntNullableFilter {
  Input$NestedIntNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not});

  @override
  factory Input$NestedIntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedIntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedIntNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedIntNullableFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableFilter? Function()? not}) =>
      Input$NestedIntNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntNullableWithAggregatesFilter {
  Input$NestedIntNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedIntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedIntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatNullableFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntNullableFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedIntNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedIntNullableWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedFloatNullableFilter? Function()? $_avg,
          Input$NestedIntNullableFilter? Function()? $_sum,
          Input$NestedIntNullableFilter? Function()? $_min,
          Input$NestedIntNullableFilter? Function()? $_max}) =>
      Input$NestedIntNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedIntWithAggregatesFilter {
  Input$NestedIntWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.not,
      this.$_count,
      this.$_avg,
      this.$_sum,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedIntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: 'in')
  final List<int?>? $in;

  final List<int?>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final Input$NestedIntWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_avg')
  final Input$NestedFloatFilter? $_avg;

  @JsonKey(name: '_sum')
  final Input$NestedIntFilter? $_sum;

  @JsonKey(name: '_min')
  final Input$NestedIntFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedIntFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedIntWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$not,
      l$$_count,
      l$$_avg,
      l$$_sum,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedIntWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedIntWithAggregatesFilter copyWith(
          {int? Function()? equals,
          List<int?>? Function()? $in,
          List<int?>? Function()? notIn,
          int? Function()? lt,
          int? Function()? lte,
          int? Function()? gt,
          int? Function()? gte,
          Input$NestedIntWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedFloatFilter? Function()? $_avg,
          Input$NestedIntFilter? Function()? $_sum,
          Input$NestedIntFilter? Function()? $_min,
          Input$NestedIntFilter? Function()? $_max}) =>
      Input$NestedIntWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_sum: $_sum == null ? this.$_sum : $_sum(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedJsonNullableFilter {
  Input$NestedJsonNullableFilter({this.equals, this.not});

  @override
  factory Input$NestedJsonNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedJsonNullableFilterFromJson(json);

  final String? equals;

  final String? not;

  Map<String, dynamic> toJson() => _$Input$NestedJsonNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([l$equals, l$not]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedJsonNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedJsonNullableFilter copyWith(
          {String? Function()? equals, String? Function()? not}) =>
      Input$NestedJsonNullableFilter(
          equals: equals == null ? this.equals : equals(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringFilter {
  Input$NestedStringFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not});

  @override
  factory Input$NestedStringFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$NestedStringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringFilter? not;

  Map<String, dynamic> toJson() => _$Input$NestedStringFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedStringFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringFilter? Function()? not}) =>
      Input$NestedStringFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringNullableFilter {
  Input$NestedStringNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not});

  @override
  factory Input$NestedStringNullableFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedStringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringNullableFilter? not;

  Map<String, dynamic> toJson() =>
      _$Input$NestedStringNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$NestedStringNullableFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringNullableFilter? Function()? not}) =>
      Input$NestedStringNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringNullableWithAggregatesFilter {
  Input$NestedStringNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedStringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedStringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedStringNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedStringNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedStringNullableFilter? Function()? $_min,
          Input$NestedStringNullableFilter? Function()? $_max}) =>
      Input$NestedStringNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NestedStringWithAggregatesFilter {
  Input$NestedStringWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$NestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NestedStringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final Input$NestedStringWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$NestedStringWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NestedStringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$NestedStringWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Input$NestedStringWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedStringFilter? Function()? $_min,
          Input$NestedStringFilter? Function()? $_max}) =>
      Input$NestedStringWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$NullableIntFieldUpdateOperationsInput {
  Input$NullableIntFieldUpdateOperationsInput(
      {this.$set, this.increment, this.decrement, this.multiply, this.divide});

  @override
  factory Input$NullableIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NullableIntFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final int? $set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  Map<String, dynamic> toJson() =>
      _$Input$NullableIntFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll(
        [l$$set, l$increment, l$decrement, l$multiply, l$divide]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NullableIntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (l$increment != lOther$increment) return false;
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (l$decrement != lOther$decrement) return false;
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (l$multiply != lOther$multiply) return false;
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (l$divide != lOther$divide) return false;
    return true;
  }

  Input$NullableIntFieldUpdateOperationsInput copyWith(
          {int? Function()? $set,
          int? Function()? increment,
          int? Function()? decrement,
          int? Function()? multiply,
          int? Function()? divide}) =>
      Input$NullableIntFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set(),
          increment: increment == null ? this.increment : increment(),
          decrement: decrement == null ? this.decrement : decrement(),
          multiply: multiply == null ? this.multiply : multiply(),
          divide: divide == null ? this.divide : divide());
}

@JsonSerializable(explicitToJson: true)
class Input$NullableStringFieldUpdateOperationsInput {
  Input$NullableStringFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$NullableStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$NullableStringFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$NullableStringFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$NullableStringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$NullableStringFieldUpdateOperationsInput copyWith(
          {String? Function()? $set}) =>
      Input$NullableStringFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticAvgOrderByAggregateInput {
  Input$PerfomanceAnalyticAvgOrderByAggregateInput({this.id, this.time});

  @override
  factory Input$PerfomanceAnalyticAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$time = time;
    return Object.hashAll([l$id, l$time]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    return true;
  }

  Input$PerfomanceAnalyticAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id, Enum$SortOrder? Function()? time}) =>
      Input$PerfomanceAnalyticAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          time: time == null ? this.time : time());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticCountOrderByAggregateInput {
  Input$PerfomanceAnalyticCountOrderByAggregateInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? operationName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? query;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? variables;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? operationName,
          Enum$SortOrder? Function()? query,
          Enum$SortOrder? Function()? variables,
          Enum$SortOrder? Function()? time,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticCreateInput {
  Input$PerfomanceAnalyticCreateInput(
      {required this.operationName,
      required this.query,
      required this.variables,
      required this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticCreateInputFromJson(json);

  final String operationName;

  final String query;

  final String variables;

  final double time;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticCreateInputToJson(this);
  int get hashCode {
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticCreateInput copyWith(
          {String? operationName,
          String? query,
          String? variables,
          double? time,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticCreateInput(
          operationName:
              operationName == null ? this.operationName : operationName,
          query: query == null ? this.query : query,
          variables: variables == null ? this.variables : variables,
          time: time == null ? this.time : time,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticCreateManyInput {
  Input$PerfomanceAnalyticCreateManyInput(
      {this.id,
      required this.operationName,
      required this.query,
      required this.variables,
      required this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticCreateManyInputFromJson(json);

  final int? id;

  final String operationName;

  final String query;

  final String variables;

  final double time;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticCreateManyInput copyWith(
          {int? Function()? id,
          String? operationName,
          String? query,
          String? variables,
          double? time,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticCreateManyInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName,
          query: query == null ? this.query : query,
          variables: variables == null ? this.variables : variables,
          time: time == null ? this.time : time,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticMaxOrderByAggregateInput {
  Input$PerfomanceAnalyticMaxOrderByAggregateInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? operationName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? query;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? variables;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? operationName,
          Enum$SortOrder? Function()? query,
          Enum$SortOrder? Function()? variables,
          Enum$SortOrder? Function()? time,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticMinOrderByAggregateInput {
  Input$PerfomanceAnalyticMinOrderByAggregateInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? operationName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? query;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? variables;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? operationName,
          Enum$SortOrder? Function()? query,
          Enum$SortOrder? Function()? variables,
          Enum$SortOrder? Function()? time,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticOrderByWithAggregationInput {
  Input$PerfomanceAnalyticOrderByWithAggregationInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$PerfomanceAnalyticOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? operationName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? query;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? variables;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$PerfomanceAnalyticCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$PerfomanceAnalyticAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$PerfomanceAnalyticMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$PerfomanceAnalyticMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$PerfomanceAnalyticSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$PerfomanceAnalyticOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? operationName,
          Enum$SortOrder? Function()? query,
          Enum$SortOrder? Function()? variables,
          Enum$SortOrder? Function()? time,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$PerfomanceAnalyticCountOrderByAggregateInput? Function()?
              $_count,
          Input$PerfomanceAnalyticAvgOrderByAggregateInput? Function()? $_avg,
          Input$PerfomanceAnalyticMaxOrderByAggregateInput? Function()? $_max,
          Input$PerfomanceAnalyticMinOrderByAggregateInput? Function()? $_min,
          Input$PerfomanceAnalyticSumOrderByAggregateInput? Function()?
              $_sum}) =>
      Input$PerfomanceAnalyticOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticOrderByWithRelationInput {
  Input$PerfomanceAnalyticOrderByWithRelationInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? operationName;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? query;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? variables;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? operationName,
          Enum$SortOrder? Function()? query,
          Enum$SortOrder? Function()? variables,
          Enum$SortOrder? Function()? time,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticScalarWhereWithAggregatesInput {
  Input$PerfomanceAnalyticScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$PerfomanceAnalyticScalarWhereWithAggregatesInput?>? AND;

  final List<Input$PerfomanceAnalyticScalarWhereWithAggregatesInput?>? OR;

  final List<Input$PerfomanceAnalyticScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? operationName;

  final Input$StringWithAggregatesFilter? query;

  final Input$StringWithAggregatesFilter? variables;

  final Input$FloatWithAggregatesFilter? time;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticScalarWhereWithAggregatesInput copyWith(
          {List<Input$PerfomanceAnalyticScalarWhereWithAggregatesInput?>?
                  Function()?
              AND,
          List<Input$PerfomanceAnalyticScalarWhereWithAggregatesInput?>?
                  Function()?
              OR,
          List<Input$PerfomanceAnalyticScalarWhereWithAggregatesInput?>?
                  Function()?
              NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? operationName,
          Input$StringWithAggregatesFilter? Function()? query,
          Input$StringWithAggregatesFilter? Function()? variables,
          Input$FloatWithAggregatesFilter? Function()? time,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticSumOrderByAggregateInput {
  Input$PerfomanceAnalyticSumOrderByAggregateInput({this.id, this.time});

  @override
  factory Input$PerfomanceAnalyticSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? time;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$time = time;
    return Object.hashAll([l$id, l$time]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    return true;
  }

  Input$PerfomanceAnalyticSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id, Enum$SortOrder? Function()? time}) =>
      Input$PerfomanceAnalyticSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          time: time == null ? this.time : time());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticUncheckedCreateInput {
  Input$PerfomanceAnalyticUncheckedCreateInput(
      {this.id,
      required this.operationName,
      required this.query,
      required this.variables,
      required this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticUncheckedCreateInputFromJson(json);

  final int? id;

  final String operationName;

  final String query;

  final String variables;

  final double time;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? operationName,
          String? query,
          String? variables,
          double? time,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticUncheckedCreateInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName,
          query: query == null ? this.query : query,
          variables: variables == null ? this.variables : variables,
          time: time == null ? this.time : time,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticUncheckedUpdateInput {
  Input$PerfomanceAnalyticUncheckedUpdateInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? operationName;

  final Input$StringFieldUpdateOperationsInput? query;

  final Input$StringFieldUpdateOperationsInput? variables;

  final Input$FloatFieldUpdateOperationsInput? time;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? operationName,
          Input$StringFieldUpdateOperationsInput? Function()? query,
          Input$StringFieldUpdateOperationsInput? Function()? variables,
          Input$FloatFieldUpdateOperationsInput? Function()? time,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticUncheckedUpdateManyInput {
  Input$PerfomanceAnalyticUncheckedUpdateManyInput(
      {this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? operationName;

  final Input$StringFieldUpdateOperationsInput? query;

  final Input$StringFieldUpdateOperationsInput? variables;

  final Input$FloatFieldUpdateOperationsInput? time;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? operationName,
          Input$StringFieldUpdateOperationsInput? Function()? query,
          Input$StringFieldUpdateOperationsInput? Function()? variables,
          Input$FloatFieldUpdateOperationsInput? Function()? time,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticUpdateInput {
  Input$PerfomanceAnalyticUpdateInput(
      {this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? operationName;

  final Input$StringFieldUpdateOperationsInput? query;

  final Input$StringFieldUpdateOperationsInput? variables;

  final Input$FloatFieldUpdateOperationsInput? time;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticUpdateInputToJson(this);
  int get hashCode {
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? operationName,
          Input$StringFieldUpdateOperationsInput? Function()? query,
          Input$StringFieldUpdateOperationsInput? Function()? variables,
          Input$FloatFieldUpdateOperationsInput? Function()? time,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticUpdateInput(
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticUpdateManyMutationInput {
  Input$PerfomanceAnalyticUpdateManyMutationInput(
      {this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? operationName;

  final Input$StringFieldUpdateOperationsInput? query;

  final Input$StringFieldUpdateOperationsInput? variables;

  final Input$FloatFieldUpdateOperationsInput? time;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? operationName,
          Input$StringFieldUpdateOperationsInput? Function()? query,
          Input$StringFieldUpdateOperationsInput? Function()? variables,
          Input$FloatFieldUpdateOperationsInput? Function()? time,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticUpdateManyMutationInput(
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticWhereInput {
  Input$PerfomanceAnalyticWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.operationName,
      this.query,
      this.variables,
      this.time,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$PerfomanceAnalyticWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticWhereInputFromJson(json);

  final List<Input$PerfomanceAnalyticWhereInput?>? AND;

  final List<Input$PerfomanceAnalyticWhereInput?>? OR;

  final List<Input$PerfomanceAnalyticWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? operationName;

  final Input$StringFilter? query;

  final Input$StringFilter? variables;

  final Input$FloatFilter? time;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$operationName = operationName;
    final l$query = query;
    final l$variables = variables;
    final l$time = time;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$operationName,
      l$query,
      l$variables,
      l$time,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$operationName = operationName;
    final lOther$operationName = other.operationName;
    if (l$operationName != lOther$operationName) return false;
    final l$query = query;
    final lOther$query = other.query;
    if (l$query != lOther$query) return false;
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (l$variables != lOther$variables) return false;
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$PerfomanceAnalyticWhereInput copyWith(
          {List<Input$PerfomanceAnalyticWhereInput?>? Function()? AND,
          List<Input$PerfomanceAnalyticWhereInput?>? Function()? OR,
          List<Input$PerfomanceAnalyticWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? operationName,
          Input$StringFilter? Function()? query,
          Input$StringFilter? Function()? variables,
          Input$FloatFilter? Function()? time,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$PerfomanceAnalyticWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          operationName:
              operationName == null ? this.operationName : operationName(),
          query: query == null ? this.query : query(),
          variables: variables == null ? this.variables : variables(),
          time: time == null ? this.time : time(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$PerfomanceAnalyticWhereUniqueInput {
  Input$PerfomanceAnalyticWhereUniqueInput({this.id});

  @override
  factory Input$PerfomanceAnalyticWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$PerfomanceAnalyticWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() =>
      _$Input$PerfomanceAnalyticWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$PerfomanceAnalyticWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$PerfomanceAnalyticWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$PerfomanceAnalyticWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportAvgOrderByAggregateInput {
  Input$ReportAvgOrderByAggregateInput({this.id, this.userId});

  @override
  factory Input$ReportAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ReportAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    return Object.hashAll([l$id, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ReportAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId}) =>
      Input$ReportAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCountOrderByAggregateInput {
  Input$ReportCountOrderByAggregateInput(
      {this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextIdentifier;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? contextIdentifier,
          Enum$SortOrder? Function()? contextType,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ReportCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateInput {
  Input$ReportCreateInput(
      {this.user,
      required this.name,
      this.message,
      required this.contextIdentifier,
      required this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportCreateInputFromJson(json);

  final Input$UserCreateNestedOneWithoutReportsInput? user;

  final String name;

  final String? message;

  final String contextIdentifier;

  final String contextType;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ReportCreateInputToJson(this);
  int get hashCode {
    final l$user = user;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$user,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportCreateInput copyWith(
          {Input$UserCreateNestedOneWithoutReportsInput? Function()? user,
          String? name,
          String? Function()? message,
          String? contextIdentifier,
          String? contextType,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ReportCreateInput(
          user: user == null ? this.user : user(),
          name: name == null ? this.name : name,
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier,
          contextType: contextType == null ? this.contextType : contextType,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateManyInput {
  Input$ReportCreateManyInput(
      {this.id,
      this.userId,
      required this.name,
      this.message,
      required this.contextIdentifier,
      required this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportCreateManyInputFromJson(json);

  final int? id;

  final int? userId;

  final String name;

  final String? message;

  final String contextIdentifier;

  final String contextType;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ReportCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportCreateManyInput copyWith(
          {int? Function()? id,
          int? Function()? userId,
          String? name,
          String? Function()? message,
          String? contextIdentifier,
          String? contextType,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ReportCreateManyInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name,
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier,
          contextType: contextType == null ? this.contextType : contextType,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateManyUserInput {
  Input$ReportCreateManyUserInput(
      {this.id,
      required this.name,
      this.message,
      required this.contextIdentifier,
      required this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportCreateManyUserInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportCreateManyUserInputFromJson(json);

  final int? id;

  final String name;

  final String? message;

  final String contextIdentifier;

  final String contextType;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportCreateManyUserInput copyWith(
          {int? Function()? id,
          String? name,
          String? Function()? message,
          String? contextIdentifier,
          String? contextType,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ReportCreateManyUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier,
          contextType: contextType == null ? this.contextType : contextType,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateManyUserInputEnvelope {
  Input$ReportCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ReportCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportCreateManyUserInputEnvelopeFromJson(json);

  final Input$ReportCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ReportCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ReportCreateManyUserInputEnvelope copyWith(
          {Input$ReportCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ReportCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateNestedManyWithoutUserInput {
  Input$ReportCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ReportCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ReportCreateWithoutUserInput?>? create;

  final List<Input$ReportCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ReportCreateManyUserInputEnvelope? createMany;

  final List<Input$ReportWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ReportCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ReportCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ReportCreateWithoutUserInput?>? Function()? create,
          List<Input$ReportCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ReportCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ReportWhereUniqueInput?>? Function()? connect}) =>
      Input$ReportCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateOrConnectWithoutUserInput {
  Input$ReportCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ReportCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ReportWhereUniqueInput where;

  final Input$ReportUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ReportCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ReportCreateOrConnectWithoutUserInput copyWith(
          {Input$ReportWhereUniqueInput? where,
          Input$ReportUncheckedCreateWithoutUserInput? create}) =>
      Input$ReportCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ReportCreateWithoutUserInput {
  Input$ReportCreateWithoutUserInput(
      {required this.name,
      this.message,
      required this.contextIdentifier,
      required this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportCreateWithoutUserInputFromJson(json);

  final String name;

  final String? message;

  final String contextIdentifier;

  final String contextType;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportCreateWithoutUserInput copyWith(
          {String? name,
          String? Function()? message,
          String? contextIdentifier,
          String? contextType,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ReportCreateWithoutUserInput(
          name: name == null ? this.name : name,
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier,
          contextType: contextType == null ? this.contextType : contextType,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportListRelationFilter {
  Input$ReportListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ReportListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportListRelationFilterFromJson(json);

  final Input$ReportWhereInput? every;

  final Input$ReportWhereInput? some;

  final Input$ReportWhereInput? none;

  Map<String, dynamic> toJson() => _$Input$ReportListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ReportListRelationFilter copyWith(
          {Input$ReportWhereInput? Function()? every,
          Input$ReportWhereInput? Function()? some,
          Input$ReportWhereInput? Function()? none}) =>
      Input$ReportListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportMaxOrderByAggregateInput {
  Input$ReportMaxOrderByAggregateInput(
      {this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextIdentifier;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? contextIdentifier,
          Enum$SortOrder? Function()? contextType,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ReportMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportMinOrderByAggregateInput {
  Input$ReportMinOrderByAggregateInput(
      {this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextIdentifier;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? contextIdentifier,
          Enum$SortOrder? Function()? contextType,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ReportMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportOrderByRelationAggregateInput {
  Input$ReportOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ReportOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ReportOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ReportOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ReportOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportOrderByWithAggregationInput {
  Input$ReportOrderByWithAggregationInput(
      {this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ReportOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextIdentifier;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ReportCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ReportAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ReportMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ReportMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ReportSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ReportOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ReportOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? contextIdentifier,
          Enum$SortOrder? Function()? contextType,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ReportCountOrderByAggregateInput? Function()? $_count,
          Input$ReportAvgOrderByAggregateInput? Function()? $_avg,
          Input$ReportMaxOrderByAggregateInput? Function()? $_max,
          Input$ReportMinOrderByAggregateInput? Function()? $_min,
          Input$ReportSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ReportOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportOrderByWithRelationInput {
  Input$ReportOrderByWithRelationInput(
      {this.id,
      this.userId,
      this.user,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? message;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextIdentifier;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? contextType;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? resolved;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$user = user;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$user,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? message,
          Enum$SortOrder? Function()? contextIdentifier,
          Enum$SortOrder? Function()? contextType,
          Enum$SortOrder? Function()? resolved,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ReportOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportScalarWhereInput {
  Input$ReportScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportScalarWhereInputFromJson(json);

  final List<Input$ReportScalarWhereInput?>? AND;

  final List<Input$ReportScalarWhereInput?>? OR;

  final List<Input$ReportScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$IntNullableFilter? userId;

  final Input$StringFilter? name;

  final Input$StringNullableFilter? message;

  final Input$StringFilter? contextIdentifier;

  final Input$StringFilter? contextType;

  final Input$BoolFilter? resolved;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ReportScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportScalarWhereInput copyWith(
          {List<Input$ReportScalarWhereInput?>? Function()? AND,
          List<Input$ReportScalarWhereInput?>? Function()? OR,
          List<Input$ReportScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$IntNullableFilter? Function()? userId,
          Input$StringFilter? Function()? name,
          Input$StringNullableFilter? Function()? message,
          Input$StringFilter? Function()? contextIdentifier,
          Input$StringFilter? Function()? contextType,
          Input$BoolFilter? Function()? resolved,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ReportScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportScalarWhereWithAggregatesInput {
  Input$ReportScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ReportScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ReportScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ReportScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$IntNullableWithAggregatesFilter? userId;

  final Input$StringWithAggregatesFilter? name;

  final Input$StringNullableWithAggregatesFilter? message;

  final Input$StringWithAggregatesFilter? contextIdentifier;

  final Input$StringWithAggregatesFilter? contextType;

  final Input$BoolWithAggregatesFilter? resolved;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportScalarWhereWithAggregatesInput copyWith(
          {List<Input$ReportScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$ReportScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$ReportScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$IntNullableWithAggregatesFilter? Function()? userId,
          Input$StringWithAggregatesFilter? Function()? name,
          Input$StringNullableWithAggregatesFilter? Function()? message,
          Input$StringWithAggregatesFilter? Function()? contextIdentifier,
          Input$StringWithAggregatesFilter? Function()? contextType,
          Input$BoolWithAggregatesFilter? Function()? resolved,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ReportScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportSumOrderByAggregateInput {
  Input$ReportSumOrderByAggregateInput({this.id, this.userId});

  @override
  factory Input$ReportSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ReportSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    return Object.hashAll([l$id, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ReportSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? userId}) =>
      Input$ReportSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedCreateInput {
  Input$ReportUncheckedCreateInput(
      {this.id,
      this.userId,
      required this.name,
      this.message,
      required this.contextIdentifier,
      required this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedCreateInputFromJson(json);

  final int? id;

  final int? userId;

  final String name;

  final String? message;

  final String contextIdentifier;

  final String contextType;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUncheckedCreateInput copyWith(
          {int? Function()? id,
          int? Function()? userId,
          String? name,
          String? Function()? message,
          String? contextIdentifier,
          String? contextType,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ReportUncheckedCreateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name,
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier,
          contextType: contextType == null ? this.contextType : contextType,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedCreateNestedManyWithoutUserInput {
  Input$ReportUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ReportUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ReportCreateWithoutUserInput?>? create;

  final List<Input$ReportCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final Input$ReportCreateManyUserInputEnvelope? createMany;

  final List<Input$ReportWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ReportUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ReportCreateWithoutUserInput?>? Function()? create,
          List<Input$ReportCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ReportCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ReportWhereUniqueInput?>? Function()? connect}) =>
      Input$ReportUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedCreateWithoutUserInput {
  Input$ReportUncheckedCreateWithoutUserInput(
      {this.id,
      required this.name,
      this.message,
      required this.contextIdentifier,
      required this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedCreateWithoutUserInputFromJson(json);

  final int? id;

  final String name;

  final String? message;

  final String contextIdentifier;

  final String contextType;

  final bool? resolved;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUncheckedCreateWithoutUserInput copyWith(
          {int? Function()? id,
          String? name,
          String? Function()? message,
          String? contextIdentifier,
          String? contextType,
          bool? Function()? resolved,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ReportUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name,
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier,
          contextType: contextType == null ? this.contextType : contextType,
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedUpdateInput {
  Input$ReportUncheckedUpdateInput(
      {this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$NullableIntFieldUpdateOperationsInput? userId;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$NullableIntFieldUpdateOperationsInput? Function()? userId,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedUpdateManyInput {
  Input$ReportUncheckedUpdateManyInput(
      {this.id,
      this.userId,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$NullableIntFieldUpdateOperationsInput? userId;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$userId,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$NullableIntFieldUpdateOperationsInput? Function()? userId,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedUpdateManyWithoutReportsInput {
  Input$ReportUncheckedUpdateManyWithoutReportsInput(
      {this.id,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUncheckedUpdateManyWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedUpdateManyWithoutReportsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedUpdateManyWithoutReportsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedUpdateManyWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUncheckedUpdateManyWithoutReportsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUncheckedUpdateManyWithoutReportsInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedUpdateManyWithoutUserInput {
  Input$ReportUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ReportUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ReportCreateWithoutUserInput?>? create;

  final List<Input$ReportCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ReportUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ReportCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ReportWhereUniqueInput?>? $set;

  final List<Input$ReportWhereUniqueInput?>? disconnect;

  final List<Input$ReportWhereUniqueInput?>? delete;

  final List<Input$ReportWhereUniqueInput?>? connect;

  final List<Input$ReportUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ReportUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ReportScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ReportUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ReportCreateWithoutUserInput?>? Function()? create,
          List<Input$ReportCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ReportUpsertWithWhereUniqueWithoutUserInput?>? Function()?
              upsert,
          Input$ReportCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ReportWhereUniqueInput?>? Function()? $set,
          List<Input$ReportWhereUniqueInput?>? Function()? disconnect,
          List<Input$ReportWhereUniqueInput?>? Function()? delete,
          List<Input$ReportWhereUniqueInput?>? Function()? connect,
          List<Input$ReportUpdateWithWhereUniqueWithoutUserInput?>? Function()?
              update,
          List<Input$ReportUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ReportScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ReportUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUncheckedUpdateWithoutUserInput {
  Input$ReportUncheckedUpdateWithoutUserInput(
      {this.id,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUncheckedUpdateWithoutUserInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpdateInput {
  Input$ReportUpdateInput(
      {this.user,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportUpdateInputFromJson(json);

  final Input$UserUpdateOneWithoutReportsInput? user;

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ReportUpdateInputToJson(this);
  int get hashCode {
    final l$user = user;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$user,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUpdateInput copyWith(
          {Input$UserUpdateOneWithoutReportsInput? Function()? user,
          Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUpdateInput(
          user: user == null ? this.user : user(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpdateManyMutationInput {
  Input$ReportUpdateManyMutationInput(
      {this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUpdateManyMutationInput(
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpdateManyWithoutUserInput {
  Input$ReportUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ReportUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ReportCreateWithoutUserInput?>? create;

  final List<Input$ReportCreateOrConnectWithoutUserInput?>? connectOrCreate;

  final List<Input$ReportUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ReportCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ReportWhereUniqueInput?>? $set;

  final List<Input$ReportWhereUniqueInput?>? disconnect;

  final List<Input$ReportWhereUniqueInput?>? delete;

  final List<Input$ReportWhereUniqueInput?>? connect;

  final List<Input$ReportUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ReportUpdateManyWithWhereWithoutUserInput?>? updateMany;

  final List<Input$ReportScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ReportUpdateManyWithoutUserInput copyWith(
          {List<Input$ReportCreateWithoutUserInput?>? Function()? create,
          List<Input$ReportCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ReportUpsertWithWhereUniqueWithoutUserInput?>? Function()?
              upsert,
          Input$ReportCreateManyUserInputEnvelope? Function()? createMany,
          List<Input$ReportWhereUniqueInput?>? Function()? $set,
          List<Input$ReportWhereUniqueInput?>? Function()? disconnect,
          List<Input$ReportWhereUniqueInput?>? Function()? delete,
          List<Input$ReportWhereUniqueInput?>? Function()? connect,
          List<Input$ReportUpdateWithWhereUniqueWithoutUserInput?>? Function()?
              update,
          List<Input$ReportUpdateManyWithWhereWithoutUserInput?>? Function()?
              updateMany,
          List<Input$ReportScalarWhereInput?>? Function()? deleteMany}) =>
      Input$ReportUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpdateManyWithWhereWithoutUserInput {
  Input$ReportUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ReportUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ReportScalarWhereInput where;

  final Input$ReportUncheckedUpdateManyWithoutReportsInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ReportUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ReportScalarWhereInput? where,
          Input$ReportUncheckedUpdateManyWithoutReportsInput? data}) =>
      Input$ReportUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpdateWithoutUserInput {
  Input$ReportUpdateWithoutUserInput(
      {this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUpdateWithoutUserInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? name;

  final Input$NullableStringFieldUpdateOperationsInput? message;

  final Input$StringFieldUpdateOperationsInput? contextIdentifier;

  final Input$StringFieldUpdateOperationsInput? contextType;

  final Input$BoolFieldUpdateOperationsInput? resolved;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportUpdateWithoutUserInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? name,
          Input$NullableStringFieldUpdateOperationsInput? Function()? message,
          Input$StringFieldUpdateOperationsInput? Function()? contextIdentifier,
          Input$StringFieldUpdateOperationsInput? Function()? contextType,
          Input$BoolFieldUpdateOperationsInput? Function()? resolved,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ReportUpdateWithoutUserInput(
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpdateWithWhereUniqueWithoutUserInput {
  Input$ReportUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ReportUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ReportWhereUniqueInput where;

  final Input$ReportUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ReportUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ReportWhereUniqueInput? where,
          Input$ReportUncheckedUpdateWithoutUserInput? data}) =>
      Input$ReportUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ReportUpsertWithWhereUniqueWithoutUserInput {
  Input$ReportUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ReportUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ReportUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ReportWhereUniqueInput where;

  final Input$ReportUncheckedUpdateWithoutUserInput update;

  final Input$ReportUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ReportUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ReportUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ReportWhereUniqueInput? where,
          Input$ReportUncheckedUpdateWithoutUserInput? update,
          Input$ReportUncheckedCreateWithoutUserInput? create}) =>
      Input$ReportUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ReportWhereInput {
  Input$ReportWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.userId,
      this.user,
      this.name,
      this.message,
      this.contextIdentifier,
      this.contextType,
      this.resolved,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ReportWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportWhereInputFromJson(json);

  final List<Input$ReportWhereInput?>? AND;

  final List<Input$ReportWhereInput?>? OR;

  final List<Input$ReportWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$IntNullableFilter? userId;

  final Input$UserWhereInput? user;

  final Input$StringFilter? name;

  final Input$StringNullableFilter? message;

  final Input$StringFilter? contextIdentifier;

  final Input$StringFilter? contextType;

  final Input$BoolFilter? resolved;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ReportWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$userId = userId;
    final l$user = user;
    final l$name = name;
    final l$message = message;
    final l$contextIdentifier = contextIdentifier;
    final l$contextType = contextType;
    final l$resolved = resolved;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$userId,
      l$user,
      l$name,
      l$message,
      l$contextIdentifier,
      l$contextType,
      l$resolved,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) return false;
    final l$contextIdentifier = contextIdentifier;
    final lOther$contextIdentifier = other.contextIdentifier;
    if (l$contextIdentifier != lOther$contextIdentifier) return false;
    final l$contextType = contextType;
    final lOther$contextType = other.contextType;
    if (l$contextType != lOther$contextType) return false;
    final l$resolved = resolved;
    final lOther$resolved = other.resolved;
    if (l$resolved != lOther$resolved) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ReportWhereInput copyWith(
          {List<Input$ReportWhereInput?>? Function()? AND,
          List<Input$ReportWhereInput?>? Function()? OR,
          List<Input$ReportWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$IntNullableFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$StringFilter? Function()? name,
          Input$StringNullableFilter? Function()? message,
          Input$StringFilter? Function()? contextIdentifier,
          Input$StringFilter? Function()? contextType,
          Input$BoolFilter? Function()? resolved,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ReportWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          name: name == null ? this.name : name(),
          message: message == null ? this.message : message(),
          contextIdentifier: contextIdentifier == null
              ? this.contextIdentifier
              : contextIdentifier(),
          contextType: contextType == null ? this.contextType : contextType(),
          resolved: resolved == null ? this.resolved : resolved(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ReportWhereUniqueInput {
  Input$ReportWhereUniqueInput({this.id});

  @override
  factory Input$ReportWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ReportWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() => _$Input$ReportWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ReportWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ReportWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$ReportWhereUniqueInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$StringFieldUpdateOperationsInput {
  Input$StringFieldUpdateOperationsInput({this.$set});

  @override
  factory Input$StringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$StringFieldUpdateOperationsInputFromJson(json);

  @JsonKey(name: 'set')
  final String? $set;

  Map<String, dynamic> toJson() =>
      _$Input$StringFieldUpdateOperationsInputToJson(this);
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([l$$set]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != lOther$$set) return false;
    return true;
  }

  Input$StringFieldUpdateOperationsInput copyWith({String? Function()? $set}) =>
      Input$StringFieldUpdateOperationsInput(
          $set: $set == null ? this.$set : $set());
}

@JsonSerializable(explicitToJson: true)
class Input$StringFilter {
  Input$StringFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not});

  @override
  factory Input$StringFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$StringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringFilter? not;

  Map<String, dynamic> toJson() => _$Input$StringFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType)
      return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$StringFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringFilter? Function()? not}) =>
      Input$StringFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$StringNullableFilter {
  Input$StringNullableFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not});

  @override
  factory Input$StringNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$StringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringNullableFilter? not;

  Map<String, dynamic> toJson() => _$Input$StringNullableFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringNullableFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    return true;
  }

  Input$StringNullableFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringNullableFilter? Function()? not}) =>
      Input$StringNullableFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not());
}

@JsonSerializable(explicitToJson: true)
class Input$StringNullableListFilter {
  Input$StringNullableListFilter(
      {this.equals, this.has, this.hasEvery, this.hasSome, this.isEmpty});

  @override
  factory Input$StringNullableListFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$StringNullableListFilterFromJson(json);

  final List<String?>? equals;

  final String? has;

  final List<String?>? hasEvery;

  final List<String?>? hasSome;

  final bool? isEmpty;

  Map<String, dynamic> toJson() => _$Input$StringNullableListFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$has = has;
    final l$hasEvery = hasEvery;
    final l$hasSome = hasSome;
    final l$isEmpty = isEmpty;
    return Object.hashAll([
      l$equals == null ? null : Object.hashAll(l$equals.map((v) => v)),
      l$has,
      l$hasEvery == null ? null : Object.hashAll(l$hasEvery.map((v) => v)),
      l$hasSome == null ? null : Object.hashAll(l$hasSome.map((v) => v)),
      l$isEmpty
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringNullableListFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != null && lOther$equals != null) {
      if (l$equals.length != lOther$equals.length) return false;
      for (int i = 0; i < l$equals.length; i++) {
        final l$equals$entry = l$equals[i];
        final lOther$equals$entry = lOther$equals[i];
        if (l$equals$entry != lOther$equals$entry) return false;
      }
    } else if (l$equals != lOther$equals) {
      return false;
    }

    final l$has = has;
    final lOther$has = other.has;
    if (l$has != lOther$has) return false;
    final l$hasEvery = hasEvery;
    final lOther$hasEvery = other.hasEvery;
    if (l$hasEvery != null && lOther$hasEvery != null) {
      if (l$hasEvery.length != lOther$hasEvery.length) return false;
      for (int i = 0; i < l$hasEvery.length; i++) {
        final l$hasEvery$entry = l$hasEvery[i];
        final lOther$hasEvery$entry = lOther$hasEvery[i];
        if (l$hasEvery$entry != lOther$hasEvery$entry) return false;
      }
    } else if (l$hasEvery != lOther$hasEvery) {
      return false;
    }

    final l$hasSome = hasSome;
    final lOther$hasSome = other.hasSome;
    if (l$hasSome != null && lOther$hasSome != null) {
      if (l$hasSome.length != lOther$hasSome.length) return false;
      for (int i = 0; i < l$hasSome.length; i++) {
        final l$hasSome$entry = l$hasSome[i];
        final lOther$hasSome$entry = lOther$hasSome[i];
        if (l$hasSome$entry != lOther$hasSome$entry) return false;
      }
    } else if (l$hasSome != lOther$hasSome) {
      return false;
    }

    final l$isEmpty = isEmpty;
    final lOther$isEmpty = other.isEmpty;
    if (l$isEmpty != lOther$isEmpty) return false;
    return true;
  }

  Input$StringNullableListFilter copyWith(
          {List<String?>? Function()? equals,
          String? Function()? has,
          List<String?>? Function()? hasEvery,
          List<String?>? Function()? hasSome,
          bool? Function()? isEmpty}) =>
      Input$StringNullableListFilter(
          equals: equals == null ? this.equals : equals(),
          has: has == null ? this.has : has(),
          hasEvery: hasEvery == null ? this.hasEvery : hasEvery(),
          hasSome: hasSome == null ? this.hasSome : hasSome(),
          isEmpty: isEmpty == null ? this.isEmpty : isEmpty());
}

@JsonSerializable(explicitToJson: true)
class Input$StringNullableWithAggregatesFilter {
  Input$StringNullableWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$StringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$StringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntNullableFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringNullableFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringNullableFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$StringNullableWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$StringNullableWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringNullableWithAggregatesFilter? Function()? not,
          Input$NestedIntNullableFilter? Function()? $_count,
          Input$NestedStringNullableFilter? Function()? $_min,
          Input$NestedStringNullableFilter? Function()? $_max}) =>
      Input$StringNullableWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$StringWithAggregatesFilter {
  Input$StringWithAggregatesFilter(
      {this.equals,
      this.$in,
      this.notIn,
      this.lt,
      this.lte,
      this.gt,
      this.gte,
      this.contains,
      this.startsWith,
      this.endsWith,
      this.mode,
      this.not,
      this.$_count,
      this.$_min,
      this.$_max});

  @override
  factory Input$StringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$StringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: 'in')
  final List<String?>? $in;

  final List<String?>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  @JsonKey(unknownEnumValue: Enum$QueryMode.$unknown)
  final Enum$QueryMode? mode;

  final Input$NestedStringWithAggregatesFilter? not;

  @JsonKey(name: '_count')
  final Input$NestedIntFilter? $_count;

  @JsonKey(name: '_min')
  final Input$NestedStringFilter? $_min;

  @JsonKey(name: '_max')
  final Input$NestedStringFilter? $_max;

  Map<String, dynamic> toJson() =>
      _$Input$StringWithAggregatesFilterToJson(this);
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$mode = mode;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      l$equals,
      l$$in == null ? null : Object.hashAll(l$$in.map((v) => v)),
      l$notIn == null ? null : Object.hashAll(l$notIn.map((v) => v)),
      l$lt,
      l$lte,
      l$gt,
      l$gte,
      l$contains,
      l$startsWith,
      l$endsWith,
      l$mode,
      l$not,
      l$$_count,
      l$$_min,
      l$$_max
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$StringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (l$equals != lOther$equals) return false;
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) return false;
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) return false;
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }

    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) return false;
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) return false;
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }

    final l$lt = lt;
    final lOther$lt = other.lt;
    if (l$lt != lOther$lt) return false;
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (l$lte != lOther$lte) return false;
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (l$gt != lOther$gt) return false;
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (l$gte != lOther$gte) return false;
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (l$contains != lOther$contains) return false;
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (l$startsWith != lOther$startsWith) return false;
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (l$endsWith != lOther$endsWith) return false;
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) return false;
    final l$not = not;
    final lOther$not = other.not;
    if (l$not != lOther$not) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    return true;
  }

  Input$StringWithAggregatesFilter copyWith(
          {String? Function()? equals,
          List<String?>? Function()? $in,
          List<String?>? Function()? notIn,
          String? Function()? lt,
          String? Function()? lte,
          String? Function()? gt,
          String? Function()? gte,
          String? Function()? contains,
          String? Function()? startsWith,
          String? Function()? endsWith,
          Enum$QueryMode? Function()? mode,
          Input$NestedStringWithAggregatesFilter? Function()? not,
          Input$NestedIntFilter? Function()? $_count,
          Input$NestedStringFilter? Function()? $_min,
          Input$NestedStringFilter? Function()? $_max}) =>
      Input$StringWithAggregatesFilter(
          equals: equals == null ? this.equals : equals(),
          $in: $in == null ? this.$in : $in(),
          notIn: notIn == null ? this.notIn : notIn(),
          lt: lt == null ? this.lt : lt(),
          lte: lte == null ? this.lte : lte(),
          gt: gt == null ? this.gt : gt(),
          gte: gte == null ? this.gte : gte(),
          contains: contains == null ? this.contains : contains(),
          startsWith: startsWith == null ? this.startsWith : startsWith(),
          endsWith: endsWith == null ? this.endsWith : endsWith(),
          mode: mode == null ? this.mode : mode(),
          not: not == null ? this.not : not(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_max: $_max == null ? this.$_max : $_max());
}

@JsonSerializable(explicitToJson: true)
class Input$UserAvgOrderByAggregateInput {
  Input$UserAvgOrderByAggregateInput({this.id});

  @override
  factory Input$UserAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$UserAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$UserAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$UserAvgOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCountOrderByAggregateInput {
  Input$UserCountOrderByAggregateInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? allowHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? allowHentai,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$UserCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateInput {
  Input$UserCreateInput(
      {required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserCreateInputFromJson(json);

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportCreateNestedManyWithoutUserInput? reports;

  final Input$ComicBookmarkCreateNestedManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterCreateNestedManyWithoutUserInput? viewedChapters;

  final Input$ChangelogCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() => _$Input$UserCreateInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateInput) || runtimeType != other.runtimeType)
      return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserCreateInput copyWith(
          {String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportCreateNestedManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkCreateNestedManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterCreateNestedManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserCreateInput(
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateManyInput {
  Input$UserCreateManyInput(
      {this.id,
      required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserCreateManyInputFromJson(json);

  final int? id;

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$UserCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserCreateManyInput copyWith(
          {int? Function()? id,
          String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$UserCreateManyInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutChangelogsInput {
  Input$UserCreateNestedOneWithoutChangelogsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutChangelogsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutChangelogsInput? create;

  final Input$UserCreateOrConnectWithoutChangelogsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutChangelogsInput copyWith(
          {Input$UserUncheckedCreateWithoutChangelogsInput? Function()? create,
          Input$UserCreateOrConnectWithoutChangelogsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutChangelogsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutComicbookmarksInput {
  Input$UserCreateNestedOneWithoutComicbookmarksInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutComicbookmarksInputFromJson(json);

  final Input$UserUncheckedCreateWithoutComicbookmarksInput? create;

  final Input$UserCreateOrConnectWithoutComicbookmarksInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutComicbookmarksInput copyWith(
          {Input$UserUncheckedCreateWithoutComicbookmarksInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutComicbookmarksInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutComicbookmarksInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutReportsInput {
  Input$UserCreateNestedOneWithoutReportsInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutReportsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutReportsInput? create;

  final Input$UserCreateOrConnectWithoutReportsInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutReportsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutReportsInput copyWith(
          {Input$UserUncheckedCreateWithoutReportsInput? Function()? create,
          Input$UserCreateOrConnectWithoutReportsInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutReportsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateNestedOneWithoutViewedChaptersInput {
  Input$UserCreateNestedOneWithoutViewedChaptersInput(
      {this.create, this.connectOrCreate, this.connect});

  @override
  factory Input$UserCreateNestedOneWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateNestedOneWithoutViewedChaptersInputFromJson(json);

  final Input$UserUncheckedCreateWithoutViewedChaptersInput? create;

  final Input$UserCreateOrConnectWithoutViewedChaptersInput? connectOrCreate;

  final Input$UserWhereUniqueInput? connect;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateNestedOneWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([l$create, l$connectOrCreate, l$connect]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateNestedOneWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    return true;
  }

  Input$UserCreateNestedOneWithoutViewedChaptersInput copyWith(
          {Input$UserUncheckedCreateWithoutViewedChaptersInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutViewedChaptersInput? Function()?
              connectOrCreate,
          Input$UserWhereUniqueInput? Function()? connect}) =>
      Input$UserCreateNestedOneWithoutViewedChaptersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutChangelogsInput {
  Input$UserCreateOrConnectWithoutChangelogsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutChangelogsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutChangelogsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutChangelogsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutChangelogsInput? create}) =>
      Input$UserCreateOrConnectWithoutChangelogsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutComicbookmarksInput {
  Input$UserCreateOrConnectWithoutComicbookmarksInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutComicbookmarksInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutComicbookmarksInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutComicbookmarksInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutComicbookmarksInput? create}) =>
      Input$UserCreateOrConnectWithoutComicbookmarksInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutReportsInput {
  Input$UserCreateOrConnectWithoutReportsInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutReportsInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutReportsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutReportsInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutReportsInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutReportsInput? create}) =>
      Input$UserCreateOrConnectWithoutReportsInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateOrConnectWithoutViewedChaptersInput {
  Input$UserCreateOrConnectWithoutViewedChaptersInput(
      {required this.where, required this.create});

  @override
  factory Input$UserCreateOrConnectWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateOrConnectWithoutViewedChaptersInputFromJson(json);

  final Input$UserWhereUniqueInput where;

  final Input$UserUncheckedCreateWithoutViewedChaptersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateOrConnectWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateOrConnectWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserCreateOrConnectWithoutViewedChaptersInput copyWith(
          {Input$UserWhereUniqueInput? where,
          Input$UserUncheckedCreateWithoutViewedChaptersInput? create}) =>
      Input$UserCreateOrConnectWithoutViewedChaptersInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutChangelogsInput {
  Input$UserCreateWithoutChangelogsInput(
      {required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters});

  @override
  factory Input$UserCreateWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutChangelogsInputFromJson(json);

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportCreateNestedManyWithoutUserInput? reports;

  final Input$ComicBookmarkCreateNestedManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterCreateNestedManyWithoutUserInput? viewedChapters;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    return true;
  }

  Input$UserCreateWithoutChangelogsInput copyWith(
          {String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportCreateNestedManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkCreateNestedManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterCreateNestedManyWithoutUserInput? Function()?
              viewedChapters}) =>
      Input$UserCreateWithoutChangelogsInput(
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutComicbookmarksInput {
  Input$UserCreateWithoutComicbookmarksInput(
      {required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserCreateWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutComicbookmarksInputFromJson(json);

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportCreateNestedManyWithoutUserInput? reports;

  final Input$ViewedChapterCreateNestedManyWithoutUserInput? viewedChapters;

  final Input$ChangelogCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserCreateWithoutComicbookmarksInput copyWith(
          {String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportCreateNestedManyWithoutUserInput? Function()? reports,
          Input$ViewedChapterCreateNestedManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserCreateWithoutComicbookmarksInput(
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutReportsInput {
  Input$UserCreateWithoutReportsInput(
      {required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserCreateWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutReportsInputFromJson(json);

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ComicBookmarkCreateNestedManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterCreateNestedManyWithoutUserInput? viewedChapters;

  final Input$ChangelogCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutReportsInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserCreateWithoutReportsInput copyWith(
          {String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ComicBookmarkCreateNestedManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterCreateNestedManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserCreateWithoutReportsInput(
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserCreateWithoutViewedChaptersInput {
  Input$UserCreateWithoutViewedChaptersInput(
      {required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.changelogs});

  @override
  factory Input$UserCreateWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserCreateWithoutViewedChaptersInputFromJson(json);

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportCreateNestedManyWithoutUserInput? reports;

  final Input$ComicBookmarkCreateNestedManyWithoutUserInput? comicbookmarks;

  final Input$ChangelogCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserCreateWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserCreateWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserCreateWithoutViewedChaptersInput copyWith(
          {String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportCreateNestedManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkCreateNestedManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ChangelogCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserCreateWithoutViewedChaptersInput(
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserMaxOrderByAggregateInput {
  Input$UserMaxOrderByAggregateInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? allowHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? allowHentai,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$UserMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserMinOrderByAggregateInput {
  Input$UserMinOrderByAggregateInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? allowHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? allowHentai,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$UserMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserOrderByWithAggregationInput {
  Input$UserOrderByWithAggregationInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$UserOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? allowHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$UserCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$UserAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$UserMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$UserMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$UserSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$UserOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$UserOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? allowHentai,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$UserCountOrderByAggregateInput? Function()? $_count,
          Input$UserAvgOrderByAggregateInput? Function()? $_avg,
          Input$UserMaxOrderByAggregateInput? Function()? $_max,
          Input$UserMinOrderByAggregateInput? Function()? $_min,
          Input$UserSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$UserOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$UserOrderByWithRelationInput {
  Input$UserOrderByWithRelationInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? email;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? name;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? isAdmin;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? allowHentai;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  final Input$ReportOrderByRelationAggregateInput? reports;

  final Input$ComicBookmarkOrderByRelationAggregateInput? comicbookmarks;

  final Input$ViewedChapterOrderByRelationAggregateInput? viewedChapters;

  final Input$ChangelogOrderByRelationAggregateInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? email,
          Enum$SortOrder? Function()? name,
          Enum$SortOrder? Function()? isAdmin,
          Enum$SortOrder? Function()? allowHentai,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ReportOrderByRelationAggregateInput? Function()? reports,
          Input$ComicBookmarkOrderByRelationAggregateInput? Function()?
              comicbookmarks,
          Input$ViewedChapterOrderByRelationAggregateInput? Function()?
              viewedChapters,
          Input$ChangelogOrderByRelationAggregateInput? Function()?
              changelogs}) =>
      Input$UserOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserRelationFilter {
  Input$UserRelationFilter({this.$is, this.isNot});

  @override
  factory Input$UserRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$Input$UserRelationFilterFromJson(json);

  @JsonKey(name: 'is')
  final Input$UserWhereInput? $is;

  final Input$UserWhereInput? isNot;

  Map<String, dynamic> toJson() => _$Input$UserRelationFilterToJson(this);
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([l$$is, l$isNot]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (l$$is != lOther$$is) return false;
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (l$isNot != lOther$isNot) return false;
    return true;
  }

  Input$UserRelationFilter copyWith(
          {Input$UserWhereInput? Function()? $is,
          Input$UserWhereInput? Function()? isNot}) =>
      Input$UserRelationFilter(
          $is: $is == null ? this.$is : $is(),
          isNot: isNot == null ? this.isNot : isNot());
}

@JsonSerializable(explicitToJson: true)
class Input$UserScalarWhereWithAggregatesInput {
  Input$UserScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$UserScalarWhereWithAggregatesInput?>? AND;

  final List<Input$UserScalarWhereWithAggregatesInput?>? OR;

  final List<Input$UserScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$StringWithAggregatesFilter? email;

  final Input$StringNullableWithAggregatesFilter? name;

  final Input$BoolWithAggregatesFilter? isAdmin;

  final Input$BoolWithAggregatesFilter? allowHentai;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserScalarWhereWithAggregatesInput copyWith(
          {List<Input$UserScalarWhereWithAggregatesInput?>? Function()? AND,
          List<Input$UserScalarWhereWithAggregatesInput?>? Function()? OR,
          List<Input$UserScalarWhereWithAggregatesInput?>? Function()? NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$StringWithAggregatesFilter? Function()? email,
          Input$StringNullableWithAggregatesFilter? Function()? name,
          Input$BoolWithAggregatesFilter? Function()? isAdmin,
          Input$BoolWithAggregatesFilter? Function()? allowHentai,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$UserScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserSumOrderByAggregateInput {
  Input$UserSumOrderByAggregateInput({this.id});

  @override
  factory Input$UserSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  Map<String, dynamic> toJson() =>
      _$Input$UserSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$UserSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id}) =>
      Input$UserSumOrderByAggregateInput(id: id == null ? this.id : id());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateInput {
  Input$UserUncheckedCreateInput(
      {this.id,
      required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateInputFromJson(json);

  final int? id;

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportUncheckedCreateNestedManyWithoutUserInput? reports;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
      comicbookmarks;

  final Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
      viewedChapters;

  final Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() => _$Input$UserUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedCreateInput copyWith(
          {int? Function()? id,
          String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportUncheckedCreateNestedManyWithoutUserInput? Function()?
              reports,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              comicbookmarks,
          Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              viewedChapters,
          Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedCreateInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutChangelogsInput {
  Input$UserUncheckedCreateWithoutChangelogsInput(
      {this.id,
      required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters});

  @override
  factory Input$UserUncheckedCreateWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutChangelogsInputFromJson(json);

  final int? id;

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportUncheckedCreateNestedManyWithoutUserInput? reports;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
      comicbookmarks;

  final Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
      viewedChapters;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutChangelogsInput copyWith(
          {int? Function()? id,
          String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportUncheckedCreateNestedManyWithoutUserInput? Function()?
              reports,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              comicbookmarks,
          Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              viewedChapters}) =>
      Input$UserUncheckedCreateWithoutChangelogsInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutComicbookmarksInput {
  Input$UserUncheckedCreateWithoutComicbookmarksInput(
      {this.id,
      required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUncheckedCreateWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutComicbookmarksInputFromJson(json);

  final int? id;

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportUncheckedCreateNestedManyWithoutUserInput? reports;

  final Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
      viewedChapters;

  final Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutComicbookmarksInput copyWith(
          {int? Function()? id,
          String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportUncheckedCreateNestedManyWithoutUserInput? Function()?
              reports,
          Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              viewedChapters,
          Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedCreateWithoutComicbookmarksInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutReportsInput {
  Input$UserUncheckedCreateWithoutReportsInput(
      {this.id,
      required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUncheckedCreateWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutReportsInputFromJson(json);

  final int? id;

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
      comicbookmarks;

  final Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
      viewedChapters;

  final Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutReportsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutReportsInput copyWith(
          {int? Function()? id,
          String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              comicbookmarks,
          Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              viewedChapters,
          Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedCreateWithoutReportsInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedCreateWithoutViewedChaptersInput {
  Input$UserUncheckedCreateWithoutViewedChaptersInput(
      {this.id,
      required this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.changelogs});

  @override
  factory Input$UserUncheckedCreateWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedCreateWithoutViewedChaptersInputFromJson(json);

  final int? id;

  final String email;

  final String? name;

  final bool? isAdmin;

  final bool? allowHentai;

  final String? createdAt;

  final String? updatedAt;

  final Input$ReportUncheckedCreateNestedManyWithoutUserInput? reports;

  final Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
      comicbookmarks;

  final Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedCreateWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedCreateWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedCreateWithoutViewedChaptersInput copyWith(
          {int? Function()? id,
          String? email,
          String? Function()? name,
          bool? Function()? isAdmin,
          bool? Function()? allowHentai,
          String? Function()? createdAt,
          String? Function()? updatedAt,
          Input$ReportUncheckedCreateNestedManyWithoutUserInput? Function()?
              reports,
          Input$ComicBookmarkUncheckedCreateNestedManyWithoutUserInput?
                  Function()?
              comicbookmarks,
          Input$ChangelogUncheckedCreateNestedManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedCreateWithoutViewedChaptersInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email,
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateInput {
  Input$UserUncheckedUpdateInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUncheckedUpdateManyWithoutUserInput? reports;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? viewedChapters;

  final Input$ChangelogUncheckedUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() => _$Input$UserUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUncheckedUpdateManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogUncheckedUpdateManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateManyInput {
  Input$UserUncheckedUpdateManyInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$UserUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutChangelogsInput {
  Input$UserUncheckedUpdateWithoutChangelogsInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters});

  @override
  factory Input$UserUncheckedUpdateWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutChangelogsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUncheckedUpdateManyWithoutUserInput? reports;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? viewedChapters;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutChangelogsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUncheckedUpdateManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? Function()?
              viewedChapters}) =>
      Input$UserUncheckedUpdateWithoutChangelogsInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutComicbookmarksInput {
  Input$UserUncheckedUpdateWithoutComicbookmarksInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUncheckedUpdateWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutComicbookmarksInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUncheckedUpdateManyWithoutUserInput? reports;

  final Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? viewedChapters;

  final Input$ChangelogUncheckedUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutComicbookmarksInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUncheckedUpdateManyWithoutUserInput? Function()? reports,
          Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogUncheckedUpdateManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedUpdateWithoutComicbookmarksInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutReportsInput {
  Input$UserUncheckedUpdateWithoutReportsInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUncheckedUpdateWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutReportsInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? viewedChapters;

  final Input$ChangelogUncheckedUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutReportsInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutReportsInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterUncheckedUpdateManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogUncheckedUpdateManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedUpdateWithoutReportsInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUncheckedUpdateWithoutViewedChaptersInput {
  Input$UserUncheckedUpdateWithoutViewedChaptersInput(
      {this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.changelogs});

  @override
  factory Input$UserUncheckedUpdateWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUncheckedUpdateWithoutViewedChaptersInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUncheckedUpdateManyWithoutUserInput? reports;

  final Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ChangelogUncheckedUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUncheckedUpdateWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUncheckedUpdateWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUncheckedUpdateWithoutViewedChaptersInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUncheckedUpdateManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkUncheckedUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ChangelogUncheckedUpdateManyWithoutUserInput? Function()?
              changelogs}) =>
      Input$UserUncheckedUpdateWithoutViewedChaptersInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateInput {
  Input$UserUpdateInput(
      {this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserUpdateInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUpdateManyWithoutUserInput? reports;

  final Input$ComicBookmarkUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterUpdateManyWithoutUserInput? viewedChapters;

  final Input$ChangelogUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() => _$Input$UserUpdateInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateInput) || runtimeType != other.runtimeType)
      return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUpdateInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUpdateManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterUpdateManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogUpdateManyWithoutUserInput? Function()? changelogs}) =>
      Input$UserUpdateInput(
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateManyMutationInput {
  Input$UserUpdateManyMutationInput(
      {this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$UserUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateManyMutationInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$email, l$name, l$isAdmin, l$allowHentai, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$UserUpdateManyMutationInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$UserUpdateManyMutationInput(
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutChangelogsInput {
  Input$UserUpdateOneRequiredWithoutChangelogsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutChangelogsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutChangelogsInput? create;

  final Input$UserCreateOrConnectWithoutChangelogsInput? connectOrCreate;

  final Input$UserUpsertWithoutChangelogsInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutChangelogsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutChangelogsInput copyWith(
          {Input$UserUncheckedCreateWithoutChangelogsInput? Function()? create,
          Input$UserCreateOrConnectWithoutChangelogsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutChangelogsInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutChangelogsInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutChangelogsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutComicbookmarksInput {
  Input$UserUpdateOneRequiredWithoutComicbookmarksInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutComicbookmarksInputFromJson(json);

  final Input$UserUncheckedCreateWithoutComicbookmarksInput? create;

  final Input$UserCreateOrConnectWithoutComicbookmarksInput? connectOrCreate;

  final Input$UserUpsertWithoutComicbookmarksInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutComicbookmarksInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutComicbookmarksInput copyWith(
          {Input$UserUncheckedCreateWithoutComicbookmarksInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutComicbookmarksInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutComicbookmarksInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutComicbookmarksInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutComicbookmarksInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneRequiredWithoutViewedChaptersInput {
  Input$UserUpdateOneRequiredWithoutViewedChaptersInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneRequiredWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneRequiredWithoutViewedChaptersInputFromJson(json);

  final Input$UserUncheckedCreateWithoutViewedChaptersInput? create;

  final Input$UserCreateOrConnectWithoutViewedChaptersInput? connectOrCreate;

  final Input$UserUpsertWithoutViewedChaptersInput? upsert;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutViewedChaptersInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneRequiredWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll(
        [l$create, l$connectOrCreate, l$upsert, l$connect, l$update]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneRequiredWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneRequiredWithoutViewedChaptersInput copyWith(
          {Input$UserUncheckedCreateWithoutViewedChaptersInput? Function()?
              create,
          Input$UserCreateOrConnectWithoutViewedChaptersInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutViewedChaptersInput? Function()? upsert,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutViewedChaptersInput? Function()?
              update}) =>
      Input$UserUpdateOneRequiredWithoutViewedChaptersInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateOneWithoutReportsInput {
  Input$UserUpdateOneWithoutReportsInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.disconnect,
      this.delete,
      this.connect,
      this.update});

  @override
  factory Input$UserUpdateOneWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateOneWithoutReportsInputFromJson(json);

  final Input$UserUncheckedCreateWithoutReportsInput? create;

  final Input$UserCreateOrConnectWithoutReportsInput? connectOrCreate;

  final Input$UserUpsertWithoutReportsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final Input$UserWhereUniqueInput? connect;

  final Input$UserUncheckedUpdateWithoutReportsInput? update;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateOneWithoutReportsInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      l$create,
      l$connectOrCreate,
      l$upsert,
      l$disconnect,
      l$delete,
      l$connect,
      l$update
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateOneWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != lOther$connectOrCreate) return false;
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != lOther$upsert) return false;
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != lOther$disconnect) return false;
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != lOther$delete) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != lOther$connect) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    return true;
  }

  Input$UserUpdateOneWithoutReportsInput copyWith(
          {Input$UserUncheckedCreateWithoutReportsInput? Function()? create,
          Input$UserCreateOrConnectWithoutReportsInput? Function()?
              connectOrCreate,
          Input$UserUpsertWithoutReportsInput? Function()? upsert,
          bool? Function()? disconnect,
          bool? Function()? delete,
          Input$UserWhereUniqueInput? Function()? connect,
          Input$UserUncheckedUpdateWithoutReportsInput? Function()? update}) =>
      Input$UserUpdateOneWithoutReportsInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutChangelogsInput {
  Input$UserUpdateWithoutChangelogsInput(
      {this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters});

  @override
  factory Input$UserUpdateWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutChangelogsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUpdateManyWithoutUserInput? reports;

  final Input$ComicBookmarkUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterUpdateManyWithoutUserInput? viewedChapters;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    return true;
  }

  Input$UserUpdateWithoutChangelogsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUpdateManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterUpdateManyWithoutUserInput? Function()?
              viewedChapters}) =>
      Input$UserUpdateWithoutChangelogsInput(
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutComicbookmarksInput {
  Input$UserUpdateWithoutComicbookmarksInput(
      {this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUpdateWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutComicbookmarksInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUpdateManyWithoutUserInput? reports;

  final Input$ViewedChapterUpdateManyWithoutUserInput? viewedChapters;

  final Input$ChangelogUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUpdateWithoutComicbookmarksInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUpdateManyWithoutUserInput? Function()? reports,
          Input$ViewedChapterUpdateManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogUpdateManyWithoutUserInput? Function()? changelogs}) =>
      Input$UserUpdateWithoutComicbookmarksInput(
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutReportsInput {
  Input$UserUpdateWithoutReportsInput(
      {this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserUpdateWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutReportsInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ComicBookmarkUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ViewedChapterUpdateManyWithoutUserInput? viewedChapters;

  final Input$ChangelogUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutReportsInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUpdateWithoutReportsInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ComicBookmarkUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ViewedChapterUpdateManyWithoutUserInput? Function()?
              viewedChapters,
          Input$ChangelogUpdateManyWithoutUserInput? Function()? changelogs}) =>
      Input$UserUpdateWithoutReportsInput(
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpdateWithoutViewedChaptersInput {
  Input$UserUpdateWithoutViewedChaptersInput(
      {this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.changelogs});

  @override
  factory Input$UserUpdateWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpdateWithoutViewedChaptersInputFromJson(json);

  final Input$StringFieldUpdateOperationsInput? email;

  final Input$NullableStringFieldUpdateOperationsInput? name;

  final Input$BoolFieldUpdateOperationsInput? isAdmin;

  final Input$BoolFieldUpdateOperationsInput? allowHentai;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  final Input$ReportUpdateManyWithoutUserInput? reports;

  final Input$ComicBookmarkUpdateManyWithoutUserInput? comicbookmarks;

  final Input$ChangelogUpdateManyWithoutUserInput? changelogs;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpdateWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpdateWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserUpdateWithoutViewedChaptersInput copyWith(
          {Input$StringFieldUpdateOperationsInput? Function()? email,
          Input$NullableStringFieldUpdateOperationsInput? Function()? name,
          Input$BoolFieldUpdateOperationsInput? Function()? isAdmin,
          Input$BoolFieldUpdateOperationsInput? Function()? allowHentai,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt,
          Input$ReportUpdateManyWithoutUserInput? Function()? reports,
          Input$ComicBookmarkUpdateManyWithoutUserInput? Function()?
              comicbookmarks,
          Input$ChangelogUpdateManyWithoutUserInput? Function()? changelogs}) =>
      Input$UserUpdateWithoutViewedChaptersInput(
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutChangelogsInput {
  Input$UserUpsertWithoutChangelogsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutChangelogsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutChangelogsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutChangelogsInput update;

  final Input$UserUncheckedCreateWithoutChangelogsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutChangelogsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutChangelogsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutChangelogsInput copyWith(
          {Input$UserUncheckedUpdateWithoutChangelogsInput? update,
          Input$UserUncheckedCreateWithoutChangelogsInput? create}) =>
      Input$UserUpsertWithoutChangelogsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutComicbookmarksInput {
  Input$UserUpsertWithoutComicbookmarksInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutComicbookmarksInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutComicbookmarksInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutComicbookmarksInput update;

  final Input$UserUncheckedCreateWithoutComicbookmarksInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutComicbookmarksInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutComicbookmarksInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutComicbookmarksInput copyWith(
          {Input$UserUncheckedUpdateWithoutComicbookmarksInput? update,
          Input$UserUncheckedCreateWithoutComicbookmarksInput? create}) =>
      Input$UserUpsertWithoutComicbookmarksInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutReportsInput {
  Input$UserUpsertWithoutReportsInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutReportsInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutReportsInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutReportsInput update;

  final Input$UserUncheckedCreateWithoutReportsInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutReportsInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutReportsInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutReportsInput copyWith(
          {Input$UserUncheckedUpdateWithoutReportsInput? update,
          Input$UserUncheckedCreateWithoutReportsInput? create}) =>
      Input$UserUpsertWithoutReportsInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserUpsertWithoutViewedChaptersInput {
  Input$UserUpsertWithoutViewedChaptersInput(
      {required this.update, required this.create});

  @override
  factory Input$UserUpsertWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$UserUpsertWithoutViewedChaptersInputFromJson(json);

  final Input$UserUncheckedUpdateWithoutViewedChaptersInput update;

  final Input$UserUncheckedCreateWithoutViewedChaptersInput create;

  Map<String, dynamic> toJson() =>
      _$Input$UserUpsertWithoutViewedChaptersInputToJson(this);
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserUpsertWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$UserUpsertWithoutViewedChaptersInput copyWith(
          {Input$UserUncheckedUpdateWithoutViewedChaptersInput? update,
          Input$UserUncheckedCreateWithoutViewedChaptersInput? create}) =>
      Input$UserUpsertWithoutViewedChaptersInput(
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$UserWhereInput {
  Input$UserWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.email,
      this.name,
      this.isAdmin,
      this.allowHentai,
      this.createdAt,
      this.updatedAt,
      this.reports,
      this.comicbookmarks,
      this.viewedChapters,
      this.changelogs});

  @override
  factory Input$UserWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserWhereInputFromJson(json);

  final List<Input$UserWhereInput?>? AND;

  final List<Input$UserWhereInput?>? OR;

  final List<Input$UserWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$StringFilter? email;

  final Input$StringNullableFilter? name;

  final Input$BoolFilter? isAdmin;

  final Input$BoolFilter? allowHentai;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  final Input$ReportListRelationFilter? reports;

  final Input$ComicBookmarkListRelationFilter? comicbookmarks;

  final Input$ViewedChapterListRelationFilter? viewedChapters;

  final Input$ChangelogListRelationFilter? changelogs;

  Map<String, dynamic> toJson() => _$Input$UserWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$email = email;
    final l$name = name;
    final l$isAdmin = isAdmin;
    final l$allowHentai = allowHentai;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$reports = reports;
    final l$comicbookmarks = comicbookmarks;
    final l$viewedChapters = viewedChapters;
    final l$changelogs = changelogs;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$email,
      l$name,
      l$isAdmin,
      l$allowHentai,
      l$createdAt,
      l$updatedAt,
      l$reports,
      l$comicbookmarks,
      l$viewedChapters,
      l$changelogs
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserWhereInput) || runtimeType != other.runtimeType)
      return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) return false;
    final l$isAdmin = isAdmin;
    final lOther$isAdmin = other.isAdmin;
    if (l$isAdmin != lOther$isAdmin) return false;
    final l$allowHentai = allowHentai;
    final lOther$allowHentai = other.allowHentai;
    if (l$allowHentai != lOther$allowHentai) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$reports = reports;
    final lOther$reports = other.reports;
    if (l$reports != lOther$reports) return false;
    final l$comicbookmarks = comicbookmarks;
    final lOther$comicbookmarks = other.comicbookmarks;
    if (l$comicbookmarks != lOther$comicbookmarks) return false;
    final l$viewedChapters = viewedChapters;
    final lOther$viewedChapters = other.viewedChapters;
    if (l$viewedChapters != lOther$viewedChapters) return false;
    final l$changelogs = changelogs;
    final lOther$changelogs = other.changelogs;
    if (l$changelogs != lOther$changelogs) return false;
    return true;
  }

  Input$UserWhereInput copyWith(
          {List<Input$UserWhereInput?>? Function()? AND,
          List<Input$UserWhereInput?>? Function()? OR,
          List<Input$UserWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$StringFilter? Function()? email,
          Input$StringNullableFilter? Function()? name,
          Input$BoolFilter? Function()? isAdmin,
          Input$BoolFilter? Function()? allowHentai,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt,
          Input$ReportListRelationFilter? Function()? reports,
          Input$ComicBookmarkListRelationFilter? Function()? comicbookmarks,
          Input$ViewedChapterListRelationFilter? Function()? viewedChapters,
          Input$ChangelogListRelationFilter? Function()? changelogs}) =>
      Input$UserWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email(),
          name: name == null ? this.name : name(),
          isAdmin: isAdmin == null ? this.isAdmin : isAdmin(),
          allowHentai: allowHentai == null ? this.allowHentai : allowHentai(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          reports: reports == null ? this.reports : reports(),
          comicbookmarks:
              comicbookmarks == null ? this.comicbookmarks : comicbookmarks(),
          viewedChapters:
              viewedChapters == null ? this.viewedChapters : viewedChapters(),
          changelogs: changelogs == null ? this.changelogs : changelogs());
}

@JsonSerializable(explicitToJson: true)
class Input$UserWhereUniqueInput {
  Input$UserWhereUniqueInput({this.id, this.email});

  @override
  factory Input$UserWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$Input$UserWhereUniqueInputFromJson(json);

  final int? id;

  final String? email;

  Map<String, dynamic> toJson() => _$Input$UserWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$email = email;
    return Object.hashAll([l$id, l$email]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$UserWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) return false;
    return true;
  }

  Input$UserWhereUniqueInput copyWith(
          {int? Function()? id, String? Function()? email}) =>
      Input$UserWhereUniqueInput(
          id: id == null ? this.id : id(),
          email: email == null ? this.email : email());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterAvgOrderByAggregateInput {
  Input$ViewedChapterAvgOrderByAggregateInput(
      {this.id, this.chapterId, this.userId});

  @override
  factory Input$ViewedChapterAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterAvgOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterAvgOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    return Object.hashAll([l$id, l$chapterId, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ViewedChapterAvgOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Enum$SortOrder? Function()? userId}) =>
      Input$ViewedChapterAvgOrderByAggregateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCountOrderByAggregateInput {
  Input$ViewedChapterCountOrderByAggregateInput(
      {this.id, this.chapterId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCountOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCountOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCountOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ViewedChapterCountOrderByAggregateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateInput {
  Input$ViewedChapterCreateInput(
      {required this.chapter,
      required this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterCreateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateInputFromJson(json);

  final Input$ChapterCreateNestedOneWithoutUserviewersInput chapter;

  final Input$UserCreateNestedOneWithoutViewedChaptersInput user;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ViewedChapterCreateInputToJson(this);
  int get hashCode {
    final l$chapter = chapter;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$chapter, l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$chapter = chapter;
    final lOther$chapter = other.chapter;
    if (l$chapter != lOther$chapter) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCreateInput copyWith(
          {Input$ChapterCreateNestedOneWithoutUserviewersInput? chapter,
          Input$UserCreateNestedOneWithoutViewedChaptersInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterCreateInput(
          chapter: chapter == null ? this.chapter : chapter,
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateManyChapterInput {
  Input$ViewedChapterCreateManyChapterInput(
      {this.id, required this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterCreateManyChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateManyChapterInputFromJson(json);

  final int? id;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateManyChapterInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateManyChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCreateManyChapterInput copyWith(
          {int? Function()? id,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterCreateManyChapterInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateManyChapterInputEnvelope {
  Input$ViewedChapterCreateManyChapterInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ViewedChapterCreateManyChapterInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateManyChapterInputEnvelopeFromJson(json);

  final Input$ViewedChapterCreateManyChapterInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateManyChapterInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateManyChapterInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ViewedChapterCreateManyChapterInputEnvelope copyWith(
          {Input$ViewedChapterCreateManyChapterInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ViewedChapterCreateManyChapterInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateManyInput {
  Input$ViewedChapterCreateManyInput(
      {this.id,
      required this.chapterId,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateManyInputFromJson(json);

  final int? id;

  final int chapterId;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCreateManyInput copyWith(
          {int? Function()? id,
          int? chapterId,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterCreateManyInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateManyUserInput {
  Input$ViewedChapterCreateManyUserInput(
      {this.id, required this.chapterId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterCreateManyUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateManyUserInputFromJson(json);

  final int? id;

  final int chapterId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateManyUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$chapterId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateManyUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCreateManyUserInput copyWith(
          {int? Function()? id,
          int? chapterId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterCreateManyUserInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateManyUserInputEnvelope {
  Input$ViewedChapterCreateManyUserInputEnvelope(
      {required this.data, this.skipDuplicates});

  @override
  factory Input$ViewedChapterCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateManyUserInputEnvelopeFromJson(json);

  final Input$ViewedChapterCreateManyUserInput data;

  final bool? skipDuplicates;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateManyUserInputEnvelopeToJson(this);
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([l$data, l$skipDuplicates]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateManyUserInputEnvelope) ||
        runtimeType != other.runtimeType) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (l$skipDuplicates != lOther$skipDuplicates) return false;
    return true;
  }

  Input$ViewedChapterCreateManyUserInputEnvelope copyWith(
          {Input$ViewedChapterCreateManyUserInput? data,
          bool? Function()? skipDuplicates}) =>
      Input$ViewedChapterCreateManyUserInputEnvelope(
          data: data == null ? this.data : data,
          skipDuplicates:
              skipDuplicates == null ? this.skipDuplicates : skipDuplicates());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateNestedManyWithoutChapterInput {
  Input$ViewedChapterCreateNestedManyWithoutChapterInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ViewedChapterCreateNestedManyWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateNestedManyWithoutChapterInputFromJson(json);

  final List<Input$ViewedChapterCreateWithoutChapterInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
      connectOrCreate;

  final Input$ViewedChapterCreateManyChapterInputEnvelope? createMany;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateNestedManyWithoutChapterInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateNestedManyWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterCreateNestedManyWithoutChapterInput copyWith(
          {List<Input$ViewedChapterCreateWithoutChapterInput?>? Function()?
              create,
          List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
                  Function()?
              connectOrCreate,
          Input$ViewedChapterCreateManyChapterInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect}) =>
      Input$ViewedChapterCreateNestedManyWithoutChapterInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateNestedManyWithoutUserInput {
  Input$ViewedChapterCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ViewedChapterCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateNestedManyWithoutUserInputFromJson(json);

  final List<Input$ViewedChapterCreateWithoutUserInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ViewedChapterCreateManyUserInputEnvelope? createMany;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateNestedManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ViewedChapterCreateWithoutUserInput?>? Function()? create,
          List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ViewedChapterCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect}) =>
      Input$ViewedChapterCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateOrConnectWithoutChapterInput {
  Input$ViewedChapterCreateOrConnectWithoutChapterInput(
      {required this.where, required this.create});

  @override
  factory Input$ViewedChapterCreateOrConnectWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateOrConnectWithoutChapterInputFromJson(json);

  final Input$ViewedChapterWhereUniqueInput where;

  final Input$ViewedChapterUncheckedCreateWithoutChapterInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateOrConnectWithoutChapterInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateOrConnectWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ViewedChapterCreateOrConnectWithoutChapterInput copyWith(
          {Input$ViewedChapterWhereUniqueInput? where,
          Input$ViewedChapterUncheckedCreateWithoutChapterInput? create}) =>
      Input$ViewedChapterCreateOrConnectWithoutChapterInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateOrConnectWithoutUserInput {
  Input$ViewedChapterCreateOrConnectWithoutUserInput(
      {required this.where, required this.create});

  @override
  factory Input$ViewedChapterCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateOrConnectWithoutUserInputFromJson(json);

  final Input$ViewedChapterWhereUniqueInput where;

  final Input$ViewedChapterUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateOrConnectWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([l$where, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ViewedChapterCreateOrConnectWithoutUserInput copyWith(
          {Input$ViewedChapterWhereUniqueInput? where,
          Input$ViewedChapterUncheckedCreateWithoutUserInput? create}) =>
      Input$ViewedChapterCreateOrConnectWithoutUserInput(
          where: where == null ? this.where : where,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateWithoutChapterInput {
  Input$ViewedChapterCreateWithoutChapterInput(
      {required this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterCreateWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateWithoutChapterInputFromJson(json);

  final Input$UserCreateNestedOneWithoutViewedChaptersInput user;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateWithoutChapterInputToJson(this);
  int get hashCode {
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCreateWithoutChapterInput copyWith(
          {Input$UserCreateNestedOneWithoutViewedChaptersInput? user,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterCreateWithoutChapterInput(
          user: user == null ? this.user : user,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterCreateWithoutUserInput {
  Input$ViewedChapterCreateWithoutUserInput(
      {required this.chapter, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterCreateWithoutUserInputFromJson(json);

  final Input$ChapterCreateNestedOneWithoutUserviewersInput chapter;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$chapter = chapter;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$chapter, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$chapter = chapter;
    final lOther$chapter = other.chapter;
    if (l$chapter != lOther$chapter) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterCreateWithoutUserInput copyWith(
          {Input$ChapterCreateNestedOneWithoutUserviewersInput? chapter,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterCreateWithoutUserInput(
          chapter: chapter == null ? this.chapter : chapter,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterListRelationFilter {
  Input$ViewedChapterListRelationFilter({this.every, this.some, this.none});

  @override
  factory Input$ViewedChapterListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterListRelationFilterFromJson(json);

  final Input$ViewedChapterWhereInput? every;

  final Input$ViewedChapterWhereInput? some;

  final Input$ViewedChapterWhereInput? none;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterListRelationFilterToJson(this);
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([l$every, l$some, l$none]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterListRelationFilter) ||
        runtimeType != other.runtimeType) return false;
    final l$every = every;
    final lOther$every = other.every;
    if (l$every != lOther$every) return false;
    final l$some = some;
    final lOther$some = other.some;
    if (l$some != lOther$some) return false;
    final l$none = none;
    final lOther$none = other.none;
    if (l$none != lOther$none) return false;
    return true;
  }

  Input$ViewedChapterListRelationFilter copyWith(
          {Input$ViewedChapterWhereInput? Function()? every,
          Input$ViewedChapterWhereInput? Function()? some,
          Input$ViewedChapterWhereInput? Function()? none}) =>
      Input$ViewedChapterListRelationFilter(
          every: every == null ? this.every : every(),
          some: some == null ? this.some : some(),
          none: none == null ? this.none : none());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterMaxOrderByAggregateInput {
  Input$ViewedChapterMaxOrderByAggregateInput(
      {this.id, this.chapterId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterMaxOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterMaxOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterMaxOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ViewedChapterMaxOrderByAggregateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterMinOrderByAggregateInput {
  Input$ViewedChapterMinOrderByAggregateInput(
      {this.id, this.chapterId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterMinOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterMinOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterMinOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ViewedChapterMinOrderByAggregateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterOrderByRelationAggregateInput {
  Input$ViewedChapterOrderByRelationAggregateInput({this.$_count});

  @override
  factory Input$ViewedChapterOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: '_count', unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? $_count;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterOrderByRelationAggregateInputToJson(this);
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll([l$$_count]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    return true;
  }

  Input$ViewedChapterOrderByRelationAggregateInput copyWith(
          {Enum$SortOrder? Function()? $_count}) =>
      Input$ViewedChapterOrderByRelationAggregateInput(
          $_count: $_count == null ? this.$_count : $_count());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterOrderByWithAggregationInput {
  Input$ViewedChapterOrderByWithAggregationInput(
      {this.id,
      this.chapterId,
      this.userId,
      this.createdAt,
      this.updatedAt,
      this.$_count,
      this.$_avg,
      this.$_max,
      this.$_min,
      this.$_sum});

  @override
  factory Input$ViewedChapterOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterOrderByWithAggregationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  @JsonKey(name: '_count')
  final Input$ViewedChapterCountOrderByAggregateInput? $_count;

  @JsonKey(name: '_avg')
  final Input$ViewedChapterAvgOrderByAggregateInput? $_avg;

  @JsonKey(name: '_max')
  final Input$ViewedChapterMaxOrderByAggregateInput? $_max;

  @JsonKey(name: '_min')
  final Input$ViewedChapterMinOrderByAggregateInput? $_min;

  @JsonKey(name: '_sum')
  final Input$ViewedChapterSumOrderByAggregateInput? $_sum;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterOrderByWithAggregationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      l$id,
      l$chapterId,
      l$userId,
      l$createdAt,
      l$updatedAt,
      l$$_count,
      l$$_avg,
      l$$_max,
      l$$_min,
      l$$_sum
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (l$$_count != lOther$$_count) return false;
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (l$$_avg != lOther$$_avg) return false;
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (l$$_max != lOther$$_max) return false;
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (l$$_min != lOther$$_min) return false;
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (l$$_sum != lOther$$_sum) return false;
    return true;
  }

  Input$ViewedChapterOrderByWithAggregationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Enum$SortOrder? Function()? userId,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt,
          Input$ViewedChapterCountOrderByAggregateInput? Function()? $_count,
          Input$ViewedChapterAvgOrderByAggregateInput? Function()? $_avg,
          Input$ViewedChapterMaxOrderByAggregateInput? Function()? $_max,
          Input$ViewedChapterMinOrderByAggregateInput? Function()? $_min,
          Input$ViewedChapterSumOrderByAggregateInput? Function()? $_sum}) =>
      Input$ViewedChapterOrderByWithAggregationInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt(),
          $_count: $_count == null ? this.$_count : $_count(),
          $_avg: $_avg == null ? this.$_avg : $_avg(),
          $_max: $_max == null ? this.$_max : $_max(),
          $_min: $_min == null ? this.$_min : $_min(),
          $_sum: $_sum == null ? this.$_sum : $_sum());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterOrderByWithRelationInput {
  Input$ViewedChapterOrderByWithRelationInput(
      {this.id,
      this.chapterId,
      this.chapter,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterOrderByWithRelationInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  final Input$ChapterOrderByWithRelationInput? chapter;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  final Input$UserOrderByWithRelationInput? user;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? createdAt;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterOrderByWithRelationInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$chapter = chapter;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$id,
      l$chapterId,
      l$chapter,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$chapter = chapter;
    final lOther$chapter = other.chapter;
    if (l$chapter != lOther$chapter) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterOrderByWithRelationInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Input$ChapterOrderByWithRelationInput? Function()? chapter,
          Enum$SortOrder? Function()? userId,
          Input$UserOrderByWithRelationInput? Function()? user,
          Enum$SortOrder? Function()? createdAt,
          Enum$SortOrder? Function()? updatedAt}) =>
      Input$ViewedChapterOrderByWithRelationInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          chapter: chapter == null ? this.chapter : chapter(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterScalarWhereInput {
  Input$ViewedChapterScalarWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.chapterId,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterScalarWhereInputFromJson(json);

  final List<Input$ViewedChapterScalarWhereInput?>? AND;

  final List<Input$ViewedChapterScalarWhereInput?>? OR;

  final List<Input$ViewedChapterScalarWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$IntFilter? chapterId;

  final Input$IntFilter? userId;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterScalarWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$chapterId,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterScalarWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterScalarWhereInput copyWith(
          {List<Input$ViewedChapterScalarWhereInput?>? Function()? AND,
          List<Input$ViewedChapterScalarWhereInput?>? Function()? OR,
          List<Input$ViewedChapterScalarWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$IntFilter? Function()? chapterId,
          Input$IntFilter? Function()? userId,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ViewedChapterScalarWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterScalarWhereWithAggregatesInput {
  Input$ViewedChapterScalarWhereWithAggregatesInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.chapterId,
      this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterScalarWhereWithAggregatesInputFromJson(json);

  final List<Input$ViewedChapterScalarWhereWithAggregatesInput?>? AND;

  final List<Input$ViewedChapterScalarWhereWithAggregatesInput?>? OR;

  final List<Input$ViewedChapterScalarWhereWithAggregatesInput?>? NOT;

  final Input$IntWithAggregatesFilter? id;

  final Input$IntWithAggregatesFilter? chapterId;

  final Input$IntWithAggregatesFilter? userId;

  final Input$DateTimeWithAggregatesFilter? createdAt;

  final Input$DateTimeWithAggregatesFilter? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterScalarWhereWithAggregatesInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$chapterId,
      l$userId,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterScalarWhereWithAggregatesInput copyWith(
          {List<Input$ViewedChapterScalarWhereWithAggregatesInput?>? Function()?
              AND,
          List<Input$ViewedChapterScalarWhereWithAggregatesInput?>? Function()?
              OR,
          List<Input$ViewedChapterScalarWhereWithAggregatesInput?>? Function()?
              NOT,
          Input$IntWithAggregatesFilter? Function()? id,
          Input$IntWithAggregatesFilter? Function()? chapterId,
          Input$IntWithAggregatesFilter? Function()? userId,
          Input$DateTimeWithAggregatesFilter? Function()? createdAt,
          Input$DateTimeWithAggregatesFilter? Function()? updatedAt}) =>
      Input$ViewedChapterScalarWhereWithAggregatesInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterSumOrderByAggregateInput {
  Input$ViewedChapterSumOrderByAggregateInput(
      {this.id, this.chapterId, this.userId});

  @override
  factory Input$ViewedChapterSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterSumOrderByAggregateInputFromJson(json);

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? id;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? chapterId;

  @JsonKey(unknownEnumValue: Enum$SortOrder.$unknown)
  final Enum$SortOrder? userId;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterSumOrderByAggregateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    return Object.hashAll([l$id, l$chapterId, l$userId]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    return true;
  }

  Input$ViewedChapterSumOrderByAggregateInput copyWith(
          {Enum$SortOrder? Function()? id,
          Enum$SortOrder? Function()? chapterId,
          Enum$SortOrder? Function()? userId}) =>
      Input$ViewedChapterSumOrderByAggregateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedCreateInput {
  Input$ViewedChapterUncheckedCreateInput(
      {this.id,
      required this.chapterId,
      required this.userId,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedCreateInputFromJson(json);

  final int? id;

  final int chapterId;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedCreateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedCreateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedCreateInput copyWith(
          {int? Function()? id,
          int? chapterId,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedCreateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId,
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput {
  Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInputFromJson(
          json);

  final List<Input$ViewedChapterCreateWithoutChapterInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
      connectOrCreate;

  final Input$ViewedChapterCreateManyChapterInputEnvelope? createMany;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput copyWith(
          {List<Input$ViewedChapterCreateWithoutChapterInput?>? Function()?
              create,
          List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
                  Function()?
              connectOrCreate,
          Input$ViewedChapterCreateManyChapterInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect}) =>
      Input$ViewedChapterUncheckedCreateNestedManyWithoutChapterInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput {
  Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput(
      {this.create, this.connectOrCreate, this.createMany, this.connect});

  @override
  factory Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInputFromJson(
          json);

  final List<Input$ViewedChapterCreateWithoutUserInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final Input$ViewedChapterCreateManyUserInputEnvelope? createMany;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInputToJson(
          this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$createMany,
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput copyWith(
          {List<Input$ViewedChapterCreateWithoutUserInput?>? Function()? create,
          List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          Input$ViewedChapterCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect}) =>
      Input$ViewedChapterUncheckedCreateNestedManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          createMany: createMany == null ? this.createMany : createMany(),
          connect: connect == null ? this.connect : connect());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedCreateWithoutChapterInput {
  Input$ViewedChapterUncheckedCreateWithoutChapterInput(
      {this.id, required this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedCreateWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedCreateWithoutChapterInputFromJson(json);

  final int? id;

  final int userId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedCreateWithoutChapterInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedCreateWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedCreateWithoutChapterInput copyWith(
          {int? Function()? id,
          int? userId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedCreateWithoutChapterInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedCreateWithoutUserInput {
  Input$ViewedChapterUncheckedCreateWithoutUserInput(
      {this.id, required this.chapterId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedCreateWithoutUserInputFromJson(json);

  final int? id;

  final int chapterId;

  final String? createdAt;

  final String? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedCreateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$chapterId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedCreateWithoutUserInput copyWith(
          {int? Function()? id,
          int? chapterId,
          String? Function()? createdAt,
          String? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedCreateWithoutUserInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId,
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateInput {
  Input$ViewedChapterUncheckedUpdateInput(
      {this.id, this.chapterId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? chapterId;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedUpdateInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? chapterId,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedUpdateInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateManyInput {
  Input$ViewedChapterUncheckedUpdateManyInput(
      {this.id, this.chapterId, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateManyInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? chapterId;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateManyInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll(
        [l$id, l$chapterId, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedUpdateManyInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedUpdateManyInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? chapterId,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedUpdateManyInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput {
  Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutChapterInputFromJson(json);

  final List<Input$ViewedChapterCreateWithoutChapterInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
      connectOrCreate;

  final List<Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput?>?
      upsert;

  final Input$ViewedChapterCreateManyChapterInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ViewedChapterWhereUniqueInput?>? $set;

  final List<Input$ViewedChapterWhereUniqueInput?>? disconnect;

  final List<Input$ViewedChapterWhereUniqueInput?>? delete;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  final List<Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput?>?
      update;

  final List<Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput?>?
      updateMany;

  final List<Input$ViewedChapterScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutChapterInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput copyWith(
          {List<Input$ViewedChapterCreateWithoutChapterInput?>? Function()?
              create,
          List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput?>?
                  Function()?
              upsert,
          Input$ViewedChapterCreateManyChapterInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? $set,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? disconnect,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? delete,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect,
          List<Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput?>?
                  Function()?
              update,
          List<Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput?>?
                  Function()?
              updateMany,
          List<Input$ViewedChapterScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ViewedChapterUncheckedUpdateManyWithoutChapterInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateManyWithoutUserInput {
  Input$ViewedChapterUncheckedUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ViewedChapterUncheckedUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ViewedChapterCreateWithoutUserInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ViewedChapterCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ViewedChapterWhereUniqueInput?>? $set;

  final List<Input$ViewedChapterWhereUniqueInput?>? disconnect;

  final List<Input$ViewedChapterWhereUniqueInput?>? delete;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  final List<Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ViewedChapterUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$ViewedChapterScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterUncheckedUpdateManyWithoutUserInput copyWith(
          {List<Input$ViewedChapterCreateWithoutUserInput?>? Function()? create,
          List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ViewedChapterCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? $set,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? disconnect,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? delete,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect,
          List<Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ViewedChapterUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ViewedChapterScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ViewedChapterUncheckedUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput {
  Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput(
      {this.id, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInputFromJson(
          json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput {
  Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput(
      {this.id, this.chapterId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInputFromJson(
          json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? chapterId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInputToJson(
          this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$chapterId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? chapterId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateWithoutChapterInput {
  Input$ViewedChapterUncheckedUpdateWithoutChapterInput(
      {this.id, this.userId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedUpdateWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateWithoutChapterInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? userId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateWithoutChapterInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$userId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedUpdateWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedUpdateWithoutChapterInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? userId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedUpdateWithoutChapterInput(
          id: id == null ? this.id : id(),
          userId: userId == null ? this.userId : userId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUncheckedUpdateWithoutUserInput {
  Input$ViewedChapterUncheckedUpdateWithoutUserInput(
      {this.id, this.chapterId, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUncheckedUpdateWithoutUserInputFromJson(json);

  final Input$IntFieldUpdateOperationsInput? id;

  final Input$IntFieldUpdateOperationsInput? chapterId;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUncheckedUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$id = id;
    final l$chapterId = chapterId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$id, l$chapterId, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUncheckedUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUncheckedUpdateWithoutUserInput copyWith(
          {Input$IntFieldUpdateOperationsInput? Function()? id,
          Input$IntFieldUpdateOperationsInput? Function()? chapterId,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUncheckedUpdateWithoutUserInput(
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateInput {
  Input$ViewedChapterUpdateInput(
      {this.chapter, this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateInputFromJson(json);

  final Input$ChapterUpdateOneRequiredWithoutUserviewersInput? chapter;

  final Input$UserUpdateOneRequiredWithoutViewedChaptersInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ViewedChapterUpdateInputToJson(this);
  int get hashCode {
    final l$chapter = chapter;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$chapter, l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateInput) ||
        runtimeType != other.runtimeType) return false;
    final l$chapter = chapter;
    final lOther$chapter = other.chapter;
    if (l$chapter != lOther$chapter) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUpdateInput copyWith(
          {Input$ChapterUpdateOneRequiredWithoutUserviewersInput? Function()?
              chapter,
          Input$UserUpdateOneRequiredWithoutViewedChaptersInput? Function()?
              user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUpdateInput(
          chapter: chapter == null ? this.chapter : chapter(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateManyMutationInput {
  Input$ViewedChapterUpdateManyMutationInput({this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateManyMutationInputFromJson(json);

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateManyMutationInputToJson(this);
  int get hashCode {
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUpdateManyMutationInput copyWith(
          {Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUpdateManyMutationInput(
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateManyWithoutChapterInput {
  Input$ViewedChapterUpdateManyWithoutChapterInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ViewedChapterUpdateManyWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateManyWithoutChapterInputFromJson(json);

  final List<Input$ViewedChapterCreateWithoutChapterInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
      connectOrCreate;

  final List<Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput?>?
      upsert;

  final Input$ViewedChapterCreateManyChapterInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ViewedChapterWhereUniqueInput?>? $set;

  final List<Input$ViewedChapterWhereUniqueInput?>? disconnect;

  final List<Input$ViewedChapterWhereUniqueInput?>? delete;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  final List<Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput?>?
      update;

  final List<Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput?>?
      updateMany;

  final List<Input$ViewedChapterScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateManyWithoutChapterInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateManyWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterUpdateManyWithoutChapterInput copyWith(
          {List<Input$ViewedChapterCreateWithoutChapterInput?>? Function()?
              create,
          List<Input$ViewedChapterCreateOrConnectWithoutChapterInput?>?
                  Function()?
              connectOrCreate,
          List<Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput?>?
                  Function()?
              upsert,
          Input$ViewedChapterCreateManyChapterInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? $set,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? disconnect,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? delete,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect,
          List<Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput?>?
                  Function()?
              update,
          List<Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput?>?
                  Function()?
              updateMany,
          List<Input$ViewedChapterScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ViewedChapterUpdateManyWithoutChapterInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateManyWithoutUserInput {
  Input$ViewedChapterUpdateManyWithoutUserInput(
      {this.create,
      this.connectOrCreate,
      this.upsert,
      this.createMany,
      this.$set,
      this.disconnect,
      this.delete,
      this.connect,
      this.update,
      this.updateMany,
      this.deleteMany});

  @override
  factory Input$ViewedChapterUpdateManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateManyWithoutUserInputFromJson(json);

  final List<Input$ViewedChapterCreateWithoutUserInput?>? create;

  final List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>?
      connectOrCreate;

  final List<Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput?>? upsert;

  final Input$ViewedChapterCreateManyUserInputEnvelope? createMany;

  @JsonKey(name: 'set')
  final List<Input$ViewedChapterWhereUniqueInput?>? $set;

  final List<Input$ViewedChapterWhereUniqueInput?>? disconnect;

  final List<Input$ViewedChapterWhereUniqueInput?>? delete;

  final List<Input$ViewedChapterWhereUniqueInput?>? connect;

  final List<Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput?>? update;

  final List<Input$ViewedChapterUpdateManyWithWhereWithoutUserInput?>?
      updateMany;

  final List<Input$ViewedChapterScalarWhereInput?>? deleteMany;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateManyWithoutUserInputToJson(this);
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      l$create == null ? null : Object.hashAll(l$create.map((v) => v)),
      l$connectOrCreate == null
          ? null
          : Object.hashAll(l$connectOrCreate.map((v) => v)),
      l$upsert == null ? null : Object.hashAll(l$upsert.map((v) => v)),
      l$createMany,
      l$$set == null ? null : Object.hashAll(l$$set.map((v) => v)),
      l$disconnect == null ? null : Object.hashAll(l$disconnect.map((v) => v)),
      l$delete == null ? null : Object.hashAll(l$delete.map((v) => v)),
      l$connect == null ? null : Object.hashAll(l$connect.map((v) => v)),
      l$update == null ? null : Object.hashAll(l$update.map((v) => v)),
      l$updateMany == null ? null : Object.hashAll(l$updateMany.map((v) => v)),
      l$deleteMany == null ? null : Object.hashAll(l$deleteMany.map((v) => v))
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateManyWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) return false;
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) return false;
      }
    } else if (l$create != lOther$create) {
      return false;
    }

    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length)
        return false;
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry)
          return false;
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }

    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) return false;
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) return false;
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }

    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (l$createMany != lOther$createMany) return false;
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) return false;
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) return false;
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }

    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) return false;
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) return false;
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }

    final l$delete = delete;
    final lOther$delete = other.delete;
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) return false;
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) return false;
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }

    final l$connect = connect;
    final lOther$connect = other.connect;
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) return false;
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) return false;
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }

    final l$update = update;
    final lOther$update = other.update;
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) return false;
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) return false;
      }
    } else if (l$update != lOther$update) {
      return false;
    }

    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) return false;
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) return false;
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }

    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) return false;
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) return false;
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }

    return true;
  }

  Input$ViewedChapterUpdateManyWithoutUserInput copyWith(
          {List<Input$ViewedChapterCreateWithoutUserInput?>? Function()? create,
          List<Input$ViewedChapterCreateOrConnectWithoutUserInput?>? Function()?
              connectOrCreate,
          List<Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput?>?
                  Function()?
              upsert,
          Input$ViewedChapterCreateManyUserInputEnvelope? Function()?
              createMany,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? $set,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? disconnect,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? delete,
          List<Input$ViewedChapterWhereUniqueInput?>? Function()? connect,
          List<Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput?>?
                  Function()?
              update,
          List<Input$ViewedChapterUpdateManyWithWhereWithoutUserInput?>?
                  Function()?
              updateMany,
          List<Input$ViewedChapterScalarWhereInput?>? Function()?
              deleteMany}) =>
      Input$ViewedChapterUpdateManyWithoutUserInput(
          create: create == null ? this.create : create(),
          connectOrCreate: connectOrCreate == null
              ? this.connectOrCreate
              : connectOrCreate(),
          upsert: upsert == null ? this.upsert : upsert(),
          createMany: createMany == null ? this.createMany : createMany(),
          $set: $set == null ? this.$set : $set(),
          disconnect: disconnect == null ? this.disconnect : disconnect(),
          delete: delete == null ? this.delete : delete(),
          connect: connect == null ? this.connect : connect(),
          update: update == null ? this.update : update(),
          updateMany: updateMany == null ? this.updateMany : updateMany(),
          deleteMany: deleteMany == null ? this.deleteMany : deleteMany());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput {
  Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput(
      {required this.where, required this.data});

  @override
  factory Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateManyWithWhereWithoutChapterInputFromJson(json);

  final Input$ViewedChapterScalarWhereInput where;

  final Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateManyWithWhereWithoutChapterInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput copyWith(
          {Input$ViewedChapterScalarWhereInput? where,
          Input$ViewedChapterUncheckedUpdateManyWithoutUserviewersInput?
              data}) =>
      Input$ViewedChapterUpdateManyWithWhereWithoutChapterInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateManyWithWhereWithoutUserInput {
  Input$ViewedChapterUpdateManyWithWhereWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ViewedChapterUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateManyWithWhereWithoutUserInputFromJson(json);

  final Input$ViewedChapterScalarWhereInput where;

  final Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateManyWithWhereWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateManyWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ViewedChapterUpdateManyWithWhereWithoutUserInput copyWith(
          {Input$ViewedChapterScalarWhereInput? where,
          Input$ViewedChapterUncheckedUpdateManyWithoutViewedChaptersInput?
              data}) =>
      Input$ViewedChapterUpdateManyWithWhereWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateWithoutChapterInput {
  Input$ViewedChapterUpdateWithoutChapterInput(
      {this.user, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUpdateWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateWithoutChapterInputFromJson(json);

  final Input$UserUpdateOneRequiredWithoutViewedChaptersInput? user;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateWithoutChapterInputToJson(this);
  int get hashCode {
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$user, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUpdateWithoutChapterInput copyWith(
          {Input$UserUpdateOneRequiredWithoutViewedChaptersInput? Function()?
              user,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUpdateWithoutChapterInput(
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateWithoutUserInput {
  Input$ViewedChapterUpdateWithoutUserInput(
      {this.chapter, this.createdAt, this.updatedAt});

  @override
  factory Input$ViewedChapterUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateWithoutUserInputFromJson(json);

  final Input$ChapterUpdateOneRequiredWithoutUserviewersInput? chapter;

  final Input$DateTimeFieldUpdateOperationsInput? createdAt;

  final Input$DateTimeFieldUpdateOperationsInput? updatedAt;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateWithoutUserInputToJson(this);
  int get hashCode {
    final l$chapter = chapter;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([l$chapter, l$createdAt, l$updatedAt]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$chapter = chapter;
    final lOther$chapter = other.chapter;
    if (l$chapter != lOther$chapter) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterUpdateWithoutUserInput copyWith(
          {Input$ChapterUpdateOneRequiredWithoutUserviewersInput? Function()?
              chapter,
          Input$DateTimeFieldUpdateOperationsInput? Function()? createdAt,
          Input$DateTimeFieldUpdateOperationsInput? Function()? updatedAt}) =>
      Input$ViewedChapterUpdateWithoutUserInput(
          chapter: chapter == null ? this.chapter : chapter(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput {
  Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput(
      {required this.where, required this.data});

  @override
  factory Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInputFromJson(
          json);

  final Input$ViewedChapterWhereUniqueInput where;

  final Input$ViewedChapterUncheckedUpdateWithoutChapterInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput copyWith(
          {Input$ViewedChapterWhereUniqueInput? where,
          Input$ViewedChapterUncheckedUpdateWithoutChapterInput? data}) =>
      Input$ViewedChapterUpdateWithWhereUniqueWithoutChapterInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput {
  Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput(
      {required this.where, required this.data});

  @override
  factory Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ViewedChapterWhereUniqueInput where;

  final Input$ViewedChapterUncheckedUpdateWithoutUserInput data;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([l$where, l$data]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) return false;
    return true;
  }

  Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput copyWith(
          {Input$ViewedChapterWhereUniqueInput? where,
          Input$ViewedChapterUncheckedUpdateWithoutUserInput? data}) =>
      Input$ViewedChapterUpdateWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          data: data == null ? this.data : data);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput {
  Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInputFromJson(
          json);

  final Input$ViewedChapterWhereUniqueInput where;

  final Input$ViewedChapterUncheckedUpdateWithoutChapterInput update;

  final Input$ViewedChapterUncheckedCreateWithoutChapterInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other
            is Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput copyWith(
          {Input$ViewedChapterWhereUniqueInput? where,
          Input$ViewedChapterUncheckedUpdateWithoutChapterInput? update,
          Input$ViewedChapterUncheckedCreateWithoutChapterInput? create}) =>
      Input$ViewedChapterUpsertWithWhereUniqueWithoutChapterInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput {
  Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput(
      {required this.where, required this.update, required this.create});

  @override
  factory Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final Input$ViewedChapterWhereUniqueInput where;

  final Input$ViewedChapterUncheckedUpdateWithoutUserInput update;

  final Input$ViewedChapterUncheckedCreateWithoutUserInput create;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInputToJson(this);
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([l$where, l$update, l$create]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput) ||
        runtimeType != other.runtimeType) return false;
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) return false;
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) return false;
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) return false;
    return true;
  }

  Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput copyWith(
          {Input$ViewedChapterWhereUniqueInput? where,
          Input$ViewedChapterUncheckedUpdateWithoutUserInput? update,
          Input$ViewedChapterUncheckedCreateWithoutUserInput? create}) =>
      Input$ViewedChapterUpsertWithWhereUniqueWithoutUserInput(
          where: where == null ? this.where : where,
          update: update == null ? this.update : update,
          create: create == null ? this.create : create);
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterWhereInput {
  Input$ViewedChapterWhereInput(
      {this.AND,
      this.OR,
      this.NOT,
      this.id,
      this.chapterId,
      this.chapter,
      this.userId,
      this.user,
      this.createdAt,
      this.updatedAt});

  @override
  factory Input$ViewedChapterWhereInput.fromJson(Map<String, dynamic> json) =>
      _$Input$ViewedChapterWhereInputFromJson(json);

  final List<Input$ViewedChapterWhereInput?>? AND;

  final List<Input$ViewedChapterWhereInput?>? OR;

  final List<Input$ViewedChapterWhereInput?>? NOT;

  final Input$IntFilter? id;

  final Input$IntFilter? chapterId;

  final Input$ChapterWhereInput? chapter;

  final Input$IntFilter? userId;

  final Input$UserWhereInput? user;

  final Input$DateTimeFilter? createdAt;

  final Input$DateTimeFilter? updatedAt;

  Map<String, dynamic> toJson() => _$Input$ViewedChapterWhereInputToJson(this);
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$chapterId = chapterId;
    final l$chapter = chapter;
    final l$userId = userId;
    final l$user = user;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      l$AND == null ? null : Object.hashAll(l$AND.map((v) => v)),
      l$OR == null ? null : Object.hashAll(l$OR.map((v) => v)),
      l$NOT == null ? null : Object.hashAll(l$NOT.map((v) => v)),
      l$id,
      l$chapterId,
      l$chapter,
      l$userId,
      l$user,
      l$createdAt,
      l$updatedAt
    ]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterWhereInput) ||
        runtimeType != other.runtimeType) return false;
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) return false;
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) return false;
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }

    final l$OR = OR;
    final lOther$OR = other.OR;
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) return false;
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) return false;
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }

    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) return false;
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) return false;
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }

    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    final l$chapterId = chapterId;
    final lOther$chapterId = other.chapterId;
    if (l$chapterId != lOther$chapterId) return false;
    final l$chapter = chapter;
    final lOther$chapter = other.chapter;
    if (l$chapter != lOther$chapter) return false;
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) return false;
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) return false;
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) return false;
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (l$updatedAt != lOther$updatedAt) return false;
    return true;
  }

  Input$ViewedChapterWhereInput copyWith(
          {List<Input$ViewedChapterWhereInput?>? Function()? AND,
          List<Input$ViewedChapterWhereInput?>? Function()? OR,
          List<Input$ViewedChapterWhereInput?>? Function()? NOT,
          Input$IntFilter? Function()? id,
          Input$IntFilter? Function()? chapterId,
          Input$ChapterWhereInput? Function()? chapter,
          Input$IntFilter? Function()? userId,
          Input$UserWhereInput? Function()? user,
          Input$DateTimeFilter? Function()? createdAt,
          Input$DateTimeFilter? Function()? updatedAt}) =>
      Input$ViewedChapterWhereInput(
          AND: AND == null ? this.AND : AND(),
          OR: OR == null ? this.OR : OR(),
          NOT: NOT == null ? this.NOT : NOT(),
          id: id == null ? this.id : id(),
          chapterId: chapterId == null ? this.chapterId : chapterId(),
          chapter: chapter == null ? this.chapter : chapter(),
          userId: userId == null ? this.userId : userId(),
          user: user == null ? this.user : user(),
          createdAt: createdAt == null ? this.createdAt : createdAt(),
          updatedAt: updatedAt == null ? this.updatedAt : updatedAt());
}

@JsonSerializable(explicitToJson: true)
class Input$ViewedChapterWhereUniqueInput {
  Input$ViewedChapterWhereUniqueInput({this.id});

  @override
  factory Input$ViewedChapterWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$Input$ViewedChapterWhereUniqueInputFromJson(json);

  final int? id;

  Map<String, dynamic> toJson() =>
      _$Input$ViewedChapterWhereUniqueInputToJson(this);
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (!(other is Input$ViewedChapterWhereUniqueInput) ||
        runtimeType != other.runtimeType) return false;
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) return false;
    return true;
  }

  Input$ViewedChapterWhereUniqueInput copyWith({int? Function()? id}) =>
      Input$ViewedChapterWhereUniqueInput(id: id == null ? this.id : id());
}

enum Enum$AdsPosition {
  @JsonValue('CHAPTER_BOTTOM')
  CHAPTER_BOTTOM,
  @JsonValue('CHAPTER_TOP')
  CHAPTER_TOP,
  @JsonValue('COMIC_RECOMENDATION')
  COMIC_RECOMENDATION,
  @JsonValue('HOME_TOP_COMIC')
  HOME_TOP_COMIC,
  $unknown
}

enum Enum$AdsScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('position')
  position,
  @JsonValue('url')
  url,
  @JsonValue('image')
  image,
  @JsonValue('index')
  index,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$AuthorScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('slug')
  slug,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ChangelogScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('version')
  version,
  @JsonValue('features')
  features,
  @JsonValue('userId')
  userId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ChapterQuality {
  @JsonValue('HQ')
  HQ,
  @JsonValue('LQ')
  LQ,
  @JsonValue('NORMAL')
  NORMAL,
  $unknown
}

enum Enum$ChapterScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('title')
  title,
  @JsonValue('cdn')
  cdn,
  @JsonValue('quality')
  quality,
  @JsonValue('views')
  views,
  @JsonValue('imageCount')
  imageCount,
  @JsonValue('originalImageCount')
  originalImageCount,
  @JsonValue('processed')
  processed,
  @JsonValue('needOptimize')
  needOptimize,
  @JsonValue('missing')
  missing,
  @JsonValue('batchs')
  batchs,
  @JsonValue('imageUrls')
  imageUrls,
  @JsonValue('imageDetails')
  imageDetails,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  @JsonValue('comicId')
  comicId,
  $unknown
}

enum Enum$ComicBookmarkScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('comicId')
  comicId,
  @JsonValue('userId')
  userId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ComicScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('slug')
  slug,
  @JsonValue('thumb')
  thumb,
  @JsonValue('type')
  type,
  @JsonValue('thumbWide')
  thumbWide,
  @JsonValue('altName')
  altName,
  @JsonValue('isHentai')
  isHentai,
  @JsonValue('released')
  released,
  @JsonValue('rating')
  rating,
  @JsonValue('views')
  views,
  @JsonValue('viewsHourly')
  viewsHourly,
  @JsonValue('viewsDaily')
  viewsDaily,
  @JsonValue('viewsWeek')
  viewsWeek,
  @JsonValue('description')
  description,
  @JsonValue('status')
  status,
  @JsonValue('age')
  age,
  @JsonValue('concept')
  concept,
  @JsonValue('lastChapterUpdateAt')
  lastChapterUpdateAt,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  @JsonValue('authorId')
  authorId,
  $unknown
}

enum Enum$GenreScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('name')
  name,
  @JsonValue('slug')
  slug,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$JsonNullValueFilter {
  @JsonValue('DbNull')
  DbNull,
  @JsonValue('JsonNull')
  JsonNull,
  @JsonValue('AnyNull')
  AnyNull,
  $unknown
}

enum Enum$MissingScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('data')
  data,
  @JsonValue('context')
  context,
  @JsonValue('resolved')
  resolved,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$NullableJsonNullValueInput {
  @JsonValue('DbNull')
  DbNull,
  @JsonValue('JsonNull')
  JsonNull,
  $unknown
}

enum Enum$PerfomanceAnalyticScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('operationName')
  operationName,
  @JsonValue('query')
  query,
  @JsonValue('variables')
  variables,
  @JsonValue('time')
  time,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$QueryMode {
  @JsonValue('default')
  $default,
  @JsonValue('insensitive')
  insensitive,
  $unknown
}

enum Enum$ReportScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('userId')
  userId,
  @JsonValue('name')
  name,
  @JsonValue('message')
  message,
  @JsonValue('contextIdentifier')
  contextIdentifier,
  @JsonValue('contextType')
  contextType,
  @JsonValue('resolved')
  resolved,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$SortOrder {
  @JsonValue('asc')
  asc,
  @JsonValue('desc')
  desc,
  $unknown
}

enum Enum$UserScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('email')
  email,
  @JsonValue('name')
  name,
  @JsonValue('isAdmin')
  isAdmin,
  @JsonValue('allowHentai')
  allowHentai,
  @JsonValue('password')
  password,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

enum Enum$ViewedChapterScalarFieldEnum {
  @JsonValue('id')
  id,
  @JsonValue('chapterId')
  chapterId,
  @JsonValue('userId')
  userId,
  @JsonValue('createdAt')
  createdAt,
  @JsonValue('updatedAt')
  updatedAt,
  $unknown
}

const possibleTypesMap = {};
